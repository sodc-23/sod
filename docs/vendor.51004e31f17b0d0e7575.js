/*! For license information please see vendor.51004e31f17b0d0e7575.js.LICENSE.txt */
(window.webpackJsonp = window.webpackJsonp || []).push([
  [5],
  [
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = __webpack_require__(83);
    },
    function (module, exports, __webpack_require__) {
      var ReactIs = __webpack_require__(10);
      module.exports = __webpack_require__(101)(ReactIs.isElement, !0);
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function _extends() {
        return (_extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
          }).apply(this, arguments);
      }
      __webpack_require__.d(__webpack_exports__, 'a', function () {
        return _extends;
      });
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_exports__.a = function warning(condition, message) {
        if (!condition) {
          var text = 'Warning: ' + message;
          'undefined' != typeof console && console.warn(text);
          try {
            throw Error(text);
          } catch (x) {}
        }
      };
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function () {
        return MemoryRouter;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function () {
          return Prompt;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function () {
          return Redirect;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function () {
          return Route;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function () {
          return Router;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function () {
          return StaticRouter;
        }),
        __webpack_require__.d(__webpack_exports__, 'g', function () {
          return Switch;
        }),
        __webpack_require__.d(__webpack_exports__, 'h', function () {
          return context;
        }),
        __webpack_require__.d(__webpack_exports__, 'i', function () {
          return generatePath;
        }),
        __webpack_require__.d(__webpack_exports__, 'j', function () {
          return matchPath;
        }),
        __webpack_require__.d(__webpack_exports__, 'k', function () {
          return useHistory;
        }),
        __webpack_require__.d(__webpack_exports__, 'l', function () {
          return useLocation;
        }),
        __webpack_require__.d(__webpack_exports__, 'm', function () {
          return useParams;
        }),
        __webpack_require__.d(__webpack_exports__, 'n', function () {
          return useRouteMatch;
        }),
        __webpack_require__.d(__webpack_exports__, 'o', function () {
          return withRouter;
        });
      var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0),
        react__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__),
        prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1),
        prop_types__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(
          prop_types__WEBPACK_IMPORTED_MODULE_2__
        ),
        history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9),
        tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3),
        mini_create_react_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(42),
        tiny_invariant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6),
        _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2),
        path_to_regexp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(43),
        path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(
          path_to_regexp__WEBPACK_IMPORTED_MODULE_8__
        ),
        react_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(10),
        _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(5),
        hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(14),
        hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11___default = __webpack_require__.n(
          hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11__
        ),
        historyContext = (function createNamedContext(name) {
          var context = Object(mini_create_react_context__WEBPACK_IMPORTED_MODULE_5__.a)();
          return (context.displayName = name), context;
        })('Router-History'),
        context = (function createNamedContext(name) {
          var context = Object(mini_create_react_context__WEBPACK_IMPORTED_MODULE_5__.a)();
          return (context.displayName = name), context;
        })('Router'),
        Router = (function (_React$Component) {
          function Router(props) {
            var _this;
            return (
              ((_this = _React$Component.call(this, props) || this).state = { location: props.history.location }),
              (_this._isMounted = !1),
              (_this._pendingLocation = null),
              props.staticContext ||
                (_this.unlisten = props.history.listen(function (location) {
                  _this._isMounted ? _this.setState({ location }) : (_this._pendingLocation = location);
                })),
              _this
            );
          }
          Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__.a)(Router, _React$Component),
            (Router.computeRootMatch = function computeRootMatch(pathname) {
              return { path: '/', url: '/', params: {}, isExact: '/' === pathname };
            });
          var _proto = Router.prototype;
          return (
            (_proto.componentDidMount = function componentDidMount() {
              (this._isMounted = !0), this._pendingLocation && this.setState({ location: this._pendingLocation });
            }),
            (_proto.componentWillUnmount = function componentWillUnmount() {
              this.unlisten && this.unlisten();
            }),
            (_proto.render = function render() {
              return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(
                context.Provider,
                {
                  value: {
                    history: this.props.history,
                    location: this.state.location,
                    match: Router.computeRootMatch(this.state.location.pathname),
                    staticContext: this.props.staticContext,
                  },
                },
                react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(historyContext.Provider, {
                  children: this.props.children || null,
                  value: this.props.history,
                })
              );
            }),
            Router
          );
        })(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);
      (Router.propTypes = {
        children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
        history: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired,
        staticContext: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
      }),
        (Router.prototype.componentDidUpdate = function (prevProps) {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
            prevProps.history === this.props.history,
            'You cannot change <Router history>'
          );
        });
      var MemoryRouter = (function (_React$Component) {
        function MemoryRouter() {
          for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return (
            ((_this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this).history = Object(
              history__WEBPACK_IMPORTED_MODULE_3__.d
            )(_this.props)),
            _this
          );
        }
        return (
          Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__.a)(
            MemoryRouter,
            _React$Component
          ),
          (MemoryRouter.prototype.render = function render() {
            return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Router, {
              history: this.history,
              children: this.props.children,
            });
          }),
          MemoryRouter
        );
      })(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);
      (MemoryRouter.propTypes = {
        initialEntries: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,
        initialIndex: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,
        getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
        keyLength: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,
        children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
      }),
        (MemoryRouter.prototype.componentDidMount = function () {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
            !this.props.history,
            '<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.'
          );
        });
      var Lifecycle = (function (_React$Component) {
        function Lifecycle() {
          return _React$Component.apply(this, arguments) || this;
        }
        Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__.a)(Lifecycle, _React$Component);
        var _proto = Lifecycle.prototype;
        return (
          (_proto.componentDidMount = function componentDidMount() {
            this.props.onMount && this.props.onMount.call(this, this);
          }),
          (_proto.componentDidUpdate = function componentDidUpdate(prevProps) {
            this.props.onUpdate && this.props.onUpdate.call(this, this, prevProps);
          }),
          (_proto.componentWillUnmount = function componentWillUnmount() {
            this.props.onUnmount && this.props.onUnmount.call(this, this);
          }),
          (_proto.render = function render() {
            return null;
          }),
          Lifecycle
        );
      })(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);
      function Prompt(_ref) {
        var message = _ref.message,
          _ref$when = _ref.when,
          when = void 0 === _ref$when || _ref$when;
        return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
          if (
            (context ||
              Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
                !1,
                'You should not use <Prompt> outside a <Router>'
              ),
            !when || context.staticContext)
          )
            return null;
          var method = context.history.block;
          return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Lifecycle, {
            onMount: function onMount(self) {
              self.release = method(message);
            },
            onUpdate: function onUpdate(self, prevProps) {
              prevProps.message !== message && (self.release(), (self.release = method(message)));
            },
            onUnmount: function onUnmount(self) {
              self.release();
            },
            message,
          });
        });
      }
      var messageType = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([
        prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
        prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
      ]);
      Prompt.propTypes = {
        when: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
        message: messageType.isRequired,
      };
      var cache = {},
        cacheCount = 0;
      function generatePath(path, params) {
        return (
          void 0 === path && (path = '/'),
          void 0 === params && (params = {}),
          '/' === path
            ? path
            : (function compilePath(path) {
                if (cache[path]) return cache[path];
                var generator = path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default.a.compile(path);
                return cacheCount < 1e4 && ((cache[path] = generator), cacheCount++), generator;
              })(path)(params, { pretty: !0 })
        );
      }
      function Redirect(_ref) {
        var computedMatch = _ref.computedMatch,
          to = _ref.to,
          _ref$push = _ref.push,
          push = void 0 !== _ref$push && _ref$push;
        return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
          context ||
            Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
              !1,
              'You should not use <Redirect> outside a <Router>'
            );
          var history = context.history,
            staticContext = context.staticContext,
            method = push ? history.push : history.replace,
            location = Object(history__WEBPACK_IMPORTED_MODULE_3__.c)(
              computedMatch
                ? 'string' == typeof to
                  ? generatePath(to, computedMatch.params)
                  : Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)({}, to, {
                      pathname: generatePath(to.pathname, computedMatch.params),
                    })
                : to
            );
          return staticContext
            ? (method(location), null)
            : react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Lifecycle, {
                onMount: function onMount() {
                  method(location);
                },
                onUpdate: function onUpdate(self, prevProps) {
                  var prevLocation = Object(history__WEBPACK_IMPORTED_MODULE_3__.c)(prevProps.to);
                  Object(history__WEBPACK_IMPORTED_MODULE_3__.f)(
                    prevLocation,
                    Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)({}, location, {
                      key: prevLocation.key,
                    })
                  ) || method(location);
                },
                to,
              });
        });
      }
      Redirect.propTypes = {
        push: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
        from: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
        to: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
        ]).isRequired,
      };
      var cache$1 = {},
        cacheCount$1 = 0;
      function matchPath(pathname, options) {
        void 0 === options && (options = {}),
          ('string' == typeof options || Array.isArray(options)) && (options = { path: options });
        var _options = options,
          path = _options.path,
          _options$exact = _options.exact,
          exact = void 0 !== _options$exact && _options$exact,
          _options$strict = _options.strict,
          strict = void 0 !== _options$strict && _options$strict,
          _options$sensitive = _options.sensitive,
          sensitive = void 0 !== _options$sensitive && _options$sensitive;
        return [].concat(path).reduce(function (matched, path) {
          if (!path && '' !== path) return null;
          if (matched) return matched;
          var _compilePath = (function compilePath$1(path, options) {
              var cacheKey = '' + options.end + options.strict + options.sensitive,
                pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
              if (pathCache[path]) return pathCache[path];
              var keys = [],
                result = { regexp: path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default()(path, keys, options), keys };
              return cacheCount$1 < 1e4 && ((pathCache[path] = result), cacheCount$1++), result;
            })(path, { end: exact, strict, sensitive }),
            regexp = _compilePath.regexp,
            keys = _compilePath.keys,
            match = regexp.exec(pathname);
          if (!match) return null;
          var url = match[0],
            values = match.slice(1),
            isExact = pathname === url;
          return exact && !isExact
            ? null
            : {
                path,
                url: '/' === path && '' === url ? '/' : url,
                isExact,
                params: keys.reduce(function (memo, key, index) {
                  return (memo[key.name] = values[index]), memo;
                }, {}),
              };
        }, null);
      }
      function isEmptyChildren(children) {
        return 0 === react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.count(children);
      }
      function evalChildrenDev(children, props, path) {
        var value = children(props);
        return (
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
            void 0 !== value,
            'You returned `undefined` from the `children` function of <Route' +
              (path ? ' path="' + path + '"' : '') +
              '>, but you should have returned a React element or `null`'
          ),
          value || null
        );
      }
      var Route = (function (_React$Component) {
        function Route() {
          return _React$Component.apply(this, arguments) || this;
        }
        return (
          Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__.a)(Route, _React$Component),
          (Route.prototype.render = function render() {
            var _this = this;
            return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (
              context$1
            ) {
              context$1 ||
                Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
                  !1,
                  'You should not use <Route> outside a <Router>'
                );
              var location = _this.props.location || context$1.location,
                match = _this.props.computedMatch
                  ? _this.props.computedMatch
                  : _this.props.path
                  ? matchPath(location.pathname, _this.props)
                  : context$1.match,
                props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)({}, context$1, {
                  location,
                  match,
                }),
                _this$props = _this.props,
                children = _this$props.children,
                component = _this$props.component,
                render = _this$props.render;
              return (
                Array.isArray(children) && 0 === children.length && (children = null),
                react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(
                  context.Provider,
                  { value: props },
                  props.match
                    ? children
                      ? 'function' == typeof children
                        ? evalChildrenDev(children, props, _this.props.path)
                        : children
                      : component
                      ? react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(component, props)
                      : render
                      ? render(props)
                      : null
                    : 'function' == typeof children
                    ? evalChildrenDev(children, props, _this.props.path)
                    : null
                )
              );
            });
          }),
          Route
        );
      })(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);
      function addLeadingSlash(path) {
        return '/' === path.charAt(0) ? path : '/' + path;
      }
      function stripBasename(basename, location) {
        if (!basename) return location;
        var base = addLeadingSlash(basename);
        return 0 !== location.pathname.indexOf(base)
          ? location
          : Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)({}, location, {
              pathname: location.pathname.substr(base.length),
            });
      }
      function createURL(location) {
        return 'string' == typeof location ? location : Object(history__WEBPACK_IMPORTED_MODULE_3__.e)(location);
      }
      function staticHandler(methodName) {
        return function () {
          Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(!1, 'You cannot %s with <StaticRouter>', methodName);
        };
      }
      function noop() {}
      (Route.propTypes = {
        children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
        ]),
        component: function component(props, propName) {
          if (props[propName] && !Object(react_is__WEBPACK_IMPORTED_MODULE_9__.isValidElementType)(props[propName]))
            return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
        },
        exact: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
        location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
        path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.arrayOf(
            prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string
          ),
        ]),
        render: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
        sensitive: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
        strict: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
      }),
        (Route.prototype.componentDidMount = function () {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
            !(this.props.children && !isEmptyChildren(this.props.children) && this.props.component),
            'You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored'
          ),
            Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
              !(this.props.children && !isEmptyChildren(this.props.children) && this.props.render),
              'You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored'
            ),
            Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
              !(this.props.component && this.props.render),
              'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored'
            );
        }),
        (Route.prototype.componentDidUpdate = function (prevProps) {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
            !(this.props.location && !prevProps.location),
            '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'
          ),
            Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
              !(!this.props.location && prevProps.location),
              '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'
            );
        });
      var StaticRouter = (function (_React$Component) {
        function StaticRouter() {
          for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return (
            ((_this =
              _React$Component.call.apply(_React$Component, [this].concat(args)) || this).handlePush = function (
              location
            ) {
              return _this.navigateTo(location, 'PUSH');
            }),
            (_this.handleReplace = function (location) {
              return _this.navigateTo(location, 'REPLACE');
            }),
            (_this.handleListen = function () {
              return noop;
            }),
            (_this.handleBlock = function () {
              return noop;
            }),
            _this
          );
        }
        Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__.a)(StaticRouter, _React$Component);
        var _proto = StaticRouter.prototype;
        return (
          (_proto.navigateTo = function navigateTo(location, action) {
            var _this$props = this.props,
              _this$props$basename = _this$props.basename,
              basename = void 0 === _this$props$basename ? '' : _this$props$basename,
              _this$props$context = _this$props.context,
              context = void 0 === _this$props$context ? {} : _this$props$context;
            (context.action = action),
              (context.location = (function addBasename(basename, location) {
                return basename
                  ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)({}, location, {
                      pathname: addLeadingSlash(basename) + location.pathname,
                    })
                  : location;
              })(basename, Object(history__WEBPACK_IMPORTED_MODULE_3__.c)(location))),
              (context.url = createURL(context.location));
          }),
          (_proto.render = function render() {
            var _this$props2 = this.props,
              _this$props2$basename = _this$props2.basename,
              basename = void 0 === _this$props2$basename ? '' : _this$props2$basename,
              _this$props2$context = _this$props2.context,
              context = void 0 === _this$props2$context ? {} : _this$props2$context,
              _this$props2$location = _this$props2.location,
              location = void 0 === _this$props2$location ? '/' : _this$props2$location,
              rest = Object(
                _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__.a
              )(_this$props2, ['basename', 'context', 'location']),
              history = {
                createHref: function createHref(path) {
                  return addLeadingSlash(basename + createURL(path));
                },
                action: 'POP',
                location: stripBasename(basename, Object(history__WEBPACK_IMPORTED_MODULE_3__.c)(location)),
                push: this.handlePush,
                replace: this.handleReplace,
                go: staticHandler('go'),
                goBack: staticHandler('goBack'),
                goForward: staticHandler('goForward'),
                listen: this.handleListen,
                block: this.handleBlock,
              };
            return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(
              Router,
              Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)({}, rest, {
                history,
                staticContext: context,
              })
            );
          }),
          StaticRouter
        );
      })(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);
      (StaticRouter.propTypes = {
        basename: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
        context: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
        location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
          prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
        ]),
      }),
        (StaticRouter.prototype.componentDidMount = function () {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
            !this.props.history,
            '<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.'
          );
        });
      var Switch = (function (_React$Component) {
        function Switch() {
          return _React$Component.apply(this, arguments) || this;
        }
        return (
          Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__.a)(Switch, _React$Component),
          (Switch.prototype.render = function render() {
            var _this = this;
            return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (
              context
            ) {
              context ||
                Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
                  !1,
                  'You should not use <Switch> outside a <Router>'
                );
              var element,
                match,
                location = _this.props.location || context.location;
              return (
                react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.forEach(_this.props.children, function (child) {
                  if (null == match && react__WEBPACK_IMPORTED_MODULE_1___default.a.isValidElement(child)) {
                    element = child;
                    var path = child.props.path || child.props.from;
                    match = path
                      ? matchPath(
                          location.pathname,
                          Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)({}, child.props, {
                            path,
                          })
                        )
                      : context.match;
                  }
                }),
                match
                  ? react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(element, {
                      location,
                      computedMatch: match,
                    })
                  : null
              );
            });
          }),
          Switch
        );
      })(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);
      function withRouter(Component) {
        var displayName = 'withRouter(' + (Component.displayName || Component.name) + ')',
          C = function C(props) {
            var wrappedComponentRef = props.wrappedComponentRef,
              remainingProps = Object(
                _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__.a
              )(props, ['wrappedComponentRef']);
            return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (
              context
            ) {
              return (
                context ||
                  Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
                    !1,
                    'You should not use <' + displayName + ' /> outside a <Router>'
                  ),
                react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(
                  Component,
                  Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__.a)(
                    {},
                    remainingProps,
                    context,
                    { ref: wrappedComponentRef }
                  )
                )
              );
            });
          };
        return (
          (C.displayName = displayName),
          (C.WrappedComponent = Component),
          (C.propTypes = {
            wrappedComponentRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([
              prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
              prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
              prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
            ]),
          }),
          hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11___default()(C, Component)
        );
      }
      (Switch.propTypes = {
        children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
        location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
      }),
        (Switch.prototype.componentDidUpdate = function (prevProps) {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
            !(this.props.location && !prevProps.location),
            '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'
          ),
            Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__.a)(
              !(!this.props.location && prevProps.location),
              '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'
            );
        });
      var useContext = react__WEBPACK_IMPORTED_MODULE_1___default.a.useContext;
      function useHistory() {
        return (
          'function' != typeof useContext &&
            Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
              !1,
              'You must use React >= 16.8 in order to use useHistory()'
            ),
          useContext(historyContext)
        );
      }
      function useLocation() {
        return (
          'function' != typeof useContext &&
            Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
              !1,
              'You must use React >= 16.8 in order to use useLocation()'
            ),
          useContext(context).location
        );
      }
      function useParams() {
        'function' != typeof useContext &&
          Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
            !1,
            'You must use React >= 16.8 in order to use useParams()'
          );
        var match = useContext(context).match;
        return match ? match.params : {};
      }
      function useRouteMatch(path) {
        'function' != typeof useContext &&
          Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__.a)(
            !1,
            'You must use React >= 16.8 in order to use useRouteMatch()'
          );
        var location = useLocation(),
          match = useContext(context).match;
        return path ? matchPath(location.pathname, path) : match;
      }
      if ('undefined' != typeof window) {
        var global = window,
          key = '__react_router_build__',
          buildNames = { cjs: 'CommonJS', esm: 'ES modules', umd: 'UMD' };
        if (global[key] && 'esm' !== global[key]) {
          var initialBuildName = buildNames[global[key]];
          throw new Error(
            'You are loading the ' +
              buildNames.esm +
              ' build of React Router on a page that is already running the ' +
              initialBuildName +
              " build, so things won't work right."
          );
        }
        global[key] = 'esm';
      }
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (null == source) return {};
        var key,
          i,
          target = {},
          sourceKeys = Object.keys(source);
        for (i = 0; i < sourceKeys.length; i++)
          (key = sourceKeys[i]), excluded.indexOf(key) >= 0 || (target[key] = source[key]);
        return target;
      }
      __webpack_require__.d(__webpack_exports__, 'a', function () {
        return _objectWithoutPropertiesLoose;
      });
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_exports__.a = function invariant(condition, message) {
        if (!condition) throw new Error('Invariant failed: ' + (message || ''));
      };
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function _inheritsLoose(subClass, superClass) {
        (subClass.prototype = Object.create(superClass.prototype)),
          (subClass.prototype.constructor = subClass),
          (subClass.__proto__ = superClass);
      }
      __webpack_require__.d(__webpack_exports__, 'a', function () {
        return _inheritsLoose;
      });
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var bind = __webpack_require__(67),
        toString = Object.prototype.toString;
      function isArray(val) {
        return '[object Array]' === toString.call(val);
      }
      function isUndefined(val) {
        return void 0 === val;
      }
      function isObject(val) {
        return null !== val && 'object' == typeof val;
      }
      function isFunction(val) {
        return '[object Function]' === toString.call(val);
      }
      function forEach(obj, fn) {
        if (null != obj)
          if (('object' != typeof obj && (obj = [obj]), isArray(obj)))
            for (var i = 0, l = obj.length; i < l; i++) fn.call(null, obj[i], i, obj);
          else for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && fn.call(null, obj[key], key, obj);
      }
      module.exports = {
        isArray,
        isArrayBuffer: function isArrayBuffer(val) {
          return '[object ArrayBuffer]' === toString.call(val);
        },
        isBuffer: function isBuffer(val) {
          return (
            null !== val &&
            !isUndefined(val) &&
            null !== val.constructor &&
            !isUndefined(val.constructor) &&
            'function' == typeof val.constructor.isBuffer &&
            val.constructor.isBuffer(val)
          );
        },
        isFormData: function isFormData(val) {
          return 'undefined' != typeof FormData && val instanceof FormData;
        },
        isArrayBufferView: function isArrayBufferView(val) {
          return 'undefined' != typeof ArrayBuffer && ArrayBuffer.isView
            ? ArrayBuffer.isView(val)
            : val && val.buffer && val.buffer instanceof ArrayBuffer;
        },
        isString: function isString(val) {
          return 'string' == typeof val;
        },
        isNumber: function isNumber(val) {
          return 'number' == typeof val;
        },
        isObject,
        isUndefined,
        isDate: function isDate(val) {
          return '[object Date]' === toString.call(val);
        },
        isFile: function isFile(val) {
          return '[object File]' === toString.call(val);
        },
        isBlob: function isBlob(val) {
          return '[object Blob]' === toString.call(val);
        },
        isFunction,
        isStream: function isStream(val) {
          return isObject(val) && isFunction(val.pipe);
        },
        isURLSearchParams: function isURLSearchParams(val) {
          return 'undefined' != typeof URLSearchParams && val instanceof URLSearchParams;
        },
        isStandardBrowserEnv: function isStandardBrowserEnv() {
          return (
            ('undefined' == typeof navigator ||
              ('ReactNative' !== navigator.product &&
                'NativeScript' !== navigator.product &&
                'NS' !== navigator.product)) &&
            'undefined' != typeof window &&
            'undefined' != typeof document
          );
        },
        forEach,
        merge: function merge() {
          var result = {};
          function assignValue(val, key) {
            'object' == typeof result[key] && 'object' == typeof val
              ? (result[key] = merge(result[key], val))
              : (result[key] = val);
          }
          for (var i = 0, l = arguments.length; i < l; i++) forEach(arguments[i], assignValue);
          return result;
        },
        deepMerge: function deepMerge() {
          var result = {};
          function assignValue(val, key) {
            'object' == typeof result[key] && 'object' == typeof val
              ? (result[key] = deepMerge(result[key], val))
              : (result[key] = 'object' == typeof val ? deepMerge({}, val) : val);
          }
          for (var i = 0, l = arguments.length; i < l; i++) forEach(arguments[i], assignValue);
          return result;
        },
        extend: function extend(a, b, thisArg) {
          return (
            forEach(b, function assignValue(val, key) {
              a[key] = thisArg && 'function' == typeof val ? bind(val, thisArg) : val;
            }),
            a
          );
        },
        trim: function trim(str) {
          return str.replace(/^\s*/, '').replace(/\s*$/, '');
        },
      };
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function () {
        return createBrowserHistory;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function () {
          return createHashHistory;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function () {
          return createMemoryHistory;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function () {
          return createLocation;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function () {
          return locationsAreEqual;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function () {
          return createPath;
        });
      var esm_extends = __webpack_require__(2);
      function isAbsolute(pathname) {
        return '/' === pathname.charAt(0);
      }
      function spliceOne(list, index) {
        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
        list.pop();
      }
      var resolve_pathname = function resolvePathname(to, from) {
        void 0 === from && (from = '');
        var hasTrailingSlash,
          toParts = (to && to.split('/')) || [],
          fromParts = (from && from.split('/')) || [],
          isToAbs = to && isAbsolute(to),
          isFromAbs = from && isAbsolute(from),
          mustEndAbs = isToAbs || isFromAbs;
        if (
          (to && isAbsolute(to)
            ? (fromParts = toParts)
            : toParts.length && (fromParts.pop(), (fromParts = fromParts.concat(toParts))),
          !fromParts.length)
        )
          return '/';
        if (fromParts.length) {
          var last = fromParts[fromParts.length - 1];
          hasTrailingSlash = '.' === last || '..' === last || '' === last;
        } else hasTrailingSlash = !1;
        for (var up = 0, i = fromParts.length; i >= 0; i--) {
          var part = fromParts[i];
          '.' === part
            ? spliceOne(fromParts, i)
            : '..' === part
            ? (spliceOne(fromParts, i), up++)
            : up && (spliceOne(fromParts, i), up--);
        }
        if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');
        !mustEndAbs || '' === fromParts[0] || (fromParts[0] && isAbsolute(fromParts[0])) || fromParts.unshift('');
        var result = fromParts.join('/');
        return hasTrailingSlash && '/' !== result.substr(-1) && (result += '/'), result;
      };
      function value_equal_valueOf(obj) {
        return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
      }
      var value_equal = function valueEqual(a, b) {
          if (a === b) return !0;
          if (null == a || null == b) return !1;
          if (Array.isArray(a))
            return (
              Array.isArray(b) &&
              a.length === b.length &&
              a.every(function (item, index) {
                return valueEqual(item, b[index]);
              })
            );
          if ('object' == typeof a || 'object' == typeof b) {
            var aValue = value_equal_valueOf(a),
              bValue = value_equal_valueOf(b);
            return aValue !== a || bValue !== b
              ? valueEqual(aValue, bValue)
              : Object.keys(Object.assign({}, a, b)).every(function (key) {
                  return valueEqual(a[key], b[key]);
                });
          }
          return !1;
        },
        tiny_warning_esm = __webpack_require__(3),
        tiny_invariant_esm = __webpack_require__(6);
      function addLeadingSlash(path) {
        return '/' === path.charAt(0) ? path : '/' + path;
      }
      function stripLeadingSlash(path) {
        return '/' === path.charAt(0) ? path.substr(1) : path;
      }
      function hasBasename(path, prefix) {
        return (
          0 === path.toLowerCase().indexOf(prefix.toLowerCase()) && -1 !== '/?#'.indexOf(path.charAt(prefix.length))
        );
      }
      function stripBasename(path, prefix) {
        return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
      }
      function stripTrailingSlash(path) {
        return '/' === path.charAt(path.length - 1) ? path.slice(0, -1) : path;
      }
      function createPath(location) {
        var pathname = location.pathname,
          search = location.search,
          hash = location.hash,
          path = pathname || '/';
        return (
          search && '?' !== search && (path += '?' === search.charAt(0) ? search : '?' + search),
          hash && '#' !== hash && (path += '#' === hash.charAt(0) ? hash : '#' + hash),
          path
        );
      }
      function createLocation(path, state, key, currentLocation) {
        var location;
        'string' == typeof path
          ? ((location = (function parsePath(path) {
              var pathname = path || '/',
                search = '',
                hash = '',
                hashIndex = pathname.indexOf('#');
              -1 !== hashIndex && ((hash = pathname.substr(hashIndex)), (pathname = pathname.substr(0, hashIndex)));
              var searchIndex = pathname.indexOf('?');
              return (
                -1 !== searchIndex &&
                  ((search = pathname.substr(searchIndex)), (pathname = pathname.substr(0, searchIndex))),
                { pathname, search: '?' === search ? '' : search, hash: '#' === hash ? '' : hash }
              );
            })(path)).state = state)
          : (void 0 === (location = Object(esm_extends.a)({}, path)).pathname && (location.pathname = ''),
            location.search
              ? '?' !== location.search.charAt(0) && (location.search = '?' + location.search)
              : (location.search = ''),
            location.hash
              ? '#' !== location.hash.charAt(0) && (location.hash = '#' + location.hash)
              : (location.hash = ''),
            void 0 !== state && void 0 === location.state && (location.state = state));
        try {
          location.pathname = decodeURI(location.pathname);
        } catch (e) {
          throw e instanceof URIError
            ? new URIError(
                'Pathname "' +
                  location.pathname +
                  '" could not be decoded. This is likely caused by an invalid percent-encoding.'
              )
            : e;
        }
        return (
          key && (location.key = key),
          currentLocation
            ? location.pathname
              ? '/' !== location.pathname.charAt(0) &&
                (location.pathname = resolve_pathname(location.pathname, currentLocation.pathname))
              : (location.pathname = currentLocation.pathname)
            : location.pathname || (location.pathname = '/'),
          location
        );
      }
      function locationsAreEqual(a, b) {
        return (
          a.pathname === b.pathname &&
          a.search === b.search &&
          a.hash === b.hash &&
          a.key === b.key &&
          value_equal(a.state, b.state)
        );
      }
      function createTransitionManager() {
        var prompt = null;
        var listeners = [];
        return {
          setPrompt: function setPrompt(nextPrompt) {
            return (
              Object(tiny_warning_esm.a)(null == prompt, 'A history supports only one prompt at a time'),
              (prompt = nextPrompt),
              function () {
                prompt === nextPrompt && (prompt = null);
              }
            );
          },
          confirmTransitionTo: function confirmTransitionTo(location, action, getUserConfirmation, callback) {
            if (null != prompt) {
              var result = 'function' == typeof prompt ? prompt(location, action) : prompt;
              'string' == typeof result
                ? 'function' == typeof getUserConfirmation
                  ? getUserConfirmation(result, callback)
                  : (Object(tiny_warning_esm.a)(
                      !1,
                      'A history needs a getUserConfirmation function in order to use a prompt message'
                    ),
                    callback(!0))
                : callback(!1 !== result);
            } else callback(!0);
          },
          appendListener: function appendListener(fn) {
            var isActive = !0;
            function listener() {
              isActive && fn.apply(void 0, arguments);
            }
            return (
              listeners.push(listener),
              function () {
                (isActive = !1),
                  (listeners = listeners.filter(function (item) {
                    return item !== listener;
                  }));
              }
            );
          },
          notifyListeners: function notifyListeners() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
              args[_key] = arguments[_key];
            listeners.forEach(function (listener) {
              return listener.apply(void 0, args);
            });
          },
        };
      }
      var canUseDOM = !('undefined' == typeof window || !window.document || !window.document.createElement);
      function getConfirmation(message, callback) {
        callback(window.confirm(message));
      }
      function getHistoryState() {
        try {
          return window.history.state || {};
        } catch (e) {
          return {};
        }
      }
      function createBrowserHistory(props) {
        void 0 === props && (props = {}), canUseDOM || Object(tiny_invariant_esm.a)(!1, 'Browser history needs a DOM');
        var globalHistory = window.history,
          canUseHistory = (function supportsHistory() {
            var ua = window.navigator.userAgent;
            return (
              ((-1 === ua.indexOf('Android 2.') && -1 === ua.indexOf('Android 4.0')) ||
                -1 === ua.indexOf('Mobile Safari') ||
                -1 !== ua.indexOf('Chrome') ||
                -1 !== ua.indexOf('Windows Phone')) &&
              window.history &&
              'pushState' in window.history
            );
          })(),
          needsHashChangeListener = !(function supportsPopStateOnHashChange() {
            return -1 === window.navigator.userAgent.indexOf('Trident');
          })(),
          _props = props,
          _props$forceRefresh = _props.forceRefresh,
          forceRefresh = void 0 !== _props$forceRefresh && _props$forceRefresh,
          _props$getUserConfirm = _props.getUserConfirmation,
          getUserConfirmation = void 0 === _props$getUserConfirm ? getConfirmation : _props$getUserConfirm,
          _props$keyLength = _props.keyLength,
          keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength,
          basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
        function getDOMLocation(historyState) {
          var _ref = historyState || {},
            key = _ref.key,
            state = _ref.state,
            _window$location = window.location,
            path = _window$location.pathname + _window$location.search + _window$location.hash;
          return (
            Object(tiny_warning_esm.a)(
              !basename || hasBasename(path, basename),
              'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' +
                path +
                '" to begin with "' +
                basename +
                '".'
            ),
            basename && (path = stripBasename(path, basename)),
            createLocation(path, state, key)
          );
        }
        function createKey() {
          return Math.random().toString(36).substr(2, keyLength);
        }
        var transitionManager = createTransitionManager();
        function setState(nextState) {
          Object(esm_extends.a)(history, nextState),
            (history.length = globalHistory.length),
            transitionManager.notifyListeners(history.location, history.action);
        }
        function handlePopState(event) {
          (function isExtraneousPopstateEvent(event) {
            return void 0 === event.state && -1 === navigator.userAgent.indexOf('CriOS');
          })(event) || handlePop(getDOMLocation(event.state));
        }
        function handleHashChange() {
          handlePop(getDOMLocation(getHistoryState()));
        }
        var forceNextPop = !1;
        function handlePop(location) {
          if (forceNextPop) (forceNextPop = !1), setState();
          else {
            transitionManager.confirmTransitionTo(location, 'POP', getUserConfirmation, function (ok) {
              ok
                ? setState({ action: 'POP', location })
                : (function revertPop(fromLocation) {
                    var toLocation = history.location,
                      toIndex = allKeys.indexOf(toLocation.key);
                    -1 === toIndex && (toIndex = 0);
                    var fromIndex = allKeys.indexOf(fromLocation.key);
                    -1 === fromIndex && (fromIndex = 0);
                    var delta = toIndex - fromIndex;
                    delta && ((forceNextPop = !0), go(delta));
                  })(location);
            });
          }
        }
        var initialLocation = getDOMLocation(getHistoryState()),
          allKeys = [initialLocation.key];
        function createHref(location) {
          return basename + createPath(location);
        }
        function go(n) {
          globalHistory.go(n);
        }
        var listenerCount = 0;
        function checkDOMListeners(delta) {
          1 === (listenerCount += delta) && 1 === delta
            ? (window.addEventListener('popstate', handlePopState),
              needsHashChangeListener && window.addEventListener('hashchange', handleHashChange))
            : 0 === listenerCount &&
              (window.removeEventListener('popstate', handlePopState),
              needsHashChangeListener && window.removeEventListener('hashchange', handleHashChange));
        }
        var isBlocked = !1;
        var history = {
          length: globalHistory.length,
          action: 'POP',
          location: initialLocation,
          createHref,
          push: function push(path, state) {
            Object(tiny_warning_esm.a)(
              !('object' == typeof path && void 0 !== path.state && void 0 !== state),
              'You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored'
            );
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, 'PUSH', getUserConfirmation, function (ok) {
              if (ok) {
                var href = createHref(location),
                  key = location.key,
                  state = location.state;
                if (canUseHistory)
                  if ((globalHistory.pushState({ key, state }, null, href), forceRefresh)) window.location.href = href;
                  else {
                    var prevIndex = allKeys.indexOf(history.location.key),
                      nextKeys = allKeys.slice(0, prevIndex + 1);
                    nextKeys.push(location.key), (allKeys = nextKeys), setState({ action: 'PUSH', location });
                  }
                else
                  Object(tiny_warning_esm.a)(
                    void 0 === state,
                    'Browser history cannot push state in browsers that do not support HTML5 history'
                  ),
                    (window.location.href = href);
              }
            });
          },
          replace: function replace(path, state) {
            Object(tiny_warning_esm.a)(
              !('object' == typeof path && void 0 !== path.state && void 0 !== state),
              'You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored'
            );
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, 'REPLACE', getUserConfirmation, function (ok) {
              if (ok) {
                var href = createHref(location),
                  key = location.key,
                  state = location.state;
                if (canUseHistory)
                  if ((globalHistory.replaceState({ key, state }, null, href), forceRefresh))
                    window.location.replace(href);
                  else {
                    var prevIndex = allKeys.indexOf(history.location.key);
                    -1 !== prevIndex && (allKeys[prevIndex] = location.key), setState({ action: 'REPLACE', location });
                  }
                else
                  Object(tiny_warning_esm.a)(
                    void 0 === state,
                    'Browser history cannot replace state in browsers that do not support HTML5 history'
                  ),
                    window.location.replace(href);
              }
            });
          },
          go,
          goBack: function goBack() {
            go(-1);
          },
          goForward: function goForward() {
            go(1);
          },
          block: function block(prompt) {
            void 0 === prompt && (prompt = !1);
            var unblock = transitionManager.setPrompt(prompt);
            return (
              isBlocked || (checkDOMListeners(1), (isBlocked = !0)),
              function () {
                return isBlocked && ((isBlocked = !1), checkDOMListeners(-1)), unblock();
              }
            );
          },
          listen: function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            return (
              checkDOMListeners(1),
              function () {
                checkDOMListeners(-1), unlisten();
              }
            );
          },
        };
        return history;
      }
      var HashPathCoders = {
        hashbang: {
          encodePath: function encodePath(path) {
            return '!' === path.charAt(0) ? path : '!/' + stripLeadingSlash(path);
          },
          decodePath: function decodePath(path) {
            return '!' === path.charAt(0) ? path.substr(1) : path;
          },
        },
        noslash: { encodePath: stripLeadingSlash, decodePath: addLeadingSlash },
        slash: { encodePath: addLeadingSlash, decodePath: addLeadingSlash },
      };
      function stripHash(url) {
        var hashIndex = url.indexOf('#');
        return -1 === hashIndex ? url : url.slice(0, hashIndex);
      }
      function getHashPath() {
        var href = window.location.href,
          hashIndex = href.indexOf('#');
        return -1 === hashIndex ? '' : href.substring(hashIndex + 1);
      }
      function replaceHashPath(path) {
        window.location.replace(stripHash(window.location.href) + '#' + path);
      }
      function createHashHistory(props) {
        void 0 === props && (props = {}), canUseDOM || Object(tiny_invariant_esm.a)(!1, 'Hash history needs a DOM');
        var globalHistory = window.history,
          canGoWithoutReload = (function supportsGoWithoutReloadUsingHash() {
            return -1 === window.navigator.userAgent.indexOf('Firefox');
          })(),
          _props = props,
          _props$getUserConfirm = _props.getUserConfirmation,
          getUserConfirmation = void 0 === _props$getUserConfirm ? getConfirmation : _props$getUserConfirm,
          _props$hashType = _props.hashType,
          hashType = void 0 === _props$hashType ? 'slash' : _props$hashType,
          basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '',
          _HashPathCoders$hashT = HashPathCoders[hashType],
          encodePath = _HashPathCoders$hashT.encodePath,
          decodePath = _HashPathCoders$hashT.decodePath;
        function getDOMLocation() {
          var path = decodePath(getHashPath());
          return (
            Object(tiny_warning_esm.a)(
              !basename || hasBasename(path, basename),
              'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' +
                path +
                '" to begin with "' +
                basename +
                '".'
            ),
            basename && (path = stripBasename(path, basename)),
            createLocation(path)
          );
        }
        var transitionManager = createTransitionManager();
        function setState(nextState) {
          Object(esm_extends.a)(history, nextState),
            (history.length = globalHistory.length),
            transitionManager.notifyListeners(history.location, history.action);
        }
        var forceNextPop = !1,
          ignorePath = null;
        function handleHashChange() {
          var path = getHashPath(),
            encodedPath = encodePath(path);
          if (path !== encodedPath) replaceHashPath(encodedPath);
          else {
            var location = getDOMLocation(),
              prevLocation = history.location;
            if (
              !forceNextPop &&
              (function locationsAreEqual$$1(a, b) {
                return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
              })(prevLocation, location)
            )
              return;
            if (ignorePath === createPath(location)) return;
            (ignorePath = null),
              (function handlePop(location) {
                if (forceNextPop) (forceNextPop = !1), setState();
                else {
                  transitionManager.confirmTransitionTo(location, 'POP', getUserConfirmation, function (ok) {
                    ok
                      ? setState({ action: 'POP', location })
                      : (function revertPop(fromLocation) {
                          var toLocation = history.location,
                            toIndex = allPaths.lastIndexOf(createPath(toLocation));
                          -1 === toIndex && (toIndex = 0);
                          var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
                          -1 === fromIndex && (fromIndex = 0);
                          var delta = toIndex - fromIndex;
                          delta && ((forceNextPop = !0), go(delta));
                        })(location);
                  });
                }
              })(location);
          }
        }
        var path = getHashPath(),
          encodedPath = encodePath(path);
        path !== encodedPath && replaceHashPath(encodedPath);
        var initialLocation = getDOMLocation(),
          allPaths = [createPath(initialLocation)];
        function go(n) {
          Object(tiny_warning_esm.a)(
            canGoWithoutReload,
            'Hash history go(n) causes a full page reload in this browser'
          ),
            globalHistory.go(n);
        }
        var listenerCount = 0;
        function checkDOMListeners(delta) {
          1 === (listenerCount += delta) && 1 === delta
            ? window.addEventListener('hashchange', handleHashChange)
            : 0 === listenerCount && window.removeEventListener('hashchange', handleHashChange);
        }
        var isBlocked = !1;
        var history = {
          length: globalHistory.length,
          action: 'POP',
          location: initialLocation,
          createHref: function createHref(location) {
            var baseTag = document.querySelector('base'),
              href = '';
            return (
              baseTag && baseTag.getAttribute('href') && (href = stripHash(window.location.href)),
              href + '#' + encodePath(basename + createPath(location))
            );
          },
          push: function push(path, state) {
            Object(tiny_warning_esm.a)(void 0 === state, 'Hash history cannot push state; it is ignored');
            var location = createLocation(path, void 0, void 0, history.location);
            transitionManager.confirmTransitionTo(location, 'PUSH', getUserConfirmation, function (ok) {
              if (ok) {
                var path = createPath(location),
                  encodedPath = encodePath(basename + path);
                if (getHashPath() !== encodedPath) {
                  (ignorePath = path),
                    (function pushHashPath(path) {
                      window.location.hash = path;
                    })(encodedPath);
                  var prevIndex = allPaths.lastIndexOf(createPath(history.location)),
                    nextPaths = allPaths.slice(0, prevIndex + 1);
                  nextPaths.push(path), (allPaths = nextPaths), setState({ action: 'PUSH', location });
                } else
                  Object(tiny_warning_esm.a)(
                    !1,
                    'Hash history cannot PUSH the same path; a new entry will not be added to the history stack'
                  ),
                    setState();
              }
            });
          },
          replace: function replace(path, state) {
            Object(tiny_warning_esm.a)(void 0 === state, 'Hash history cannot replace state; it is ignored');
            var location = createLocation(path, void 0, void 0, history.location);
            transitionManager.confirmTransitionTo(location, 'REPLACE', getUserConfirmation, function (ok) {
              if (ok) {
                var path = createPath(location),
                  encodedPath = encodePath(basename + path);
                getHashPath() !== encodedPath && ((ignorePath = path), replaceHashPath(encodedPath));
                var prevIndex = allPaths.indexOf(createPath(history.location));
                -1 !== prevIndex && (allPaths[prevIndex] = path), setState({ action: 'REPLACE', location });
              }
            });
          },
          go,
          goBack: function goBack() {
            go(-1);
          },
          goForward: function goForward() {
            go(1);
          },
          block: function block(prompt) {
            void 0 === prompt && (prompt = !1);
            var unblock = transitionManager.setPrompt(prompt);
            return (
              isBlocked || (checkDOMListeners(1), (isBlocked = !0)),
              function () {
                return isBlocked && ((isBlocked = !1), checkDOMListeners(-1)), unblock();
              }
            );
          },
          listen: function listen(listener) {
            var unlisten = transitionManager.appendListener(listener);
            return (
              checkDOMListeners(1),
              function () {
                checkDOMListeners(-1), unlisten();
              }
            );
          },
        };
        return history;
      }
      function clamp(n, lowerBound, upperBound) {
        return Math.min(Math.max(n, lowerBound), upperBound);
      }
      function createMemoryHistory(props) {
        void 0 === props && (props = {});
        var _props = props,
          getUserConfirmation = _props.getUserConfirmation,
          _props$initialEntries = _props.initialEntries,
          initialEntries = void 0 === _props$initialEntries ? ['/'] : _props$initialEntries,
          _props$initialIndex = _props.initialIndex,
          initialIndex = void 0 === _props$initialIndex ? 0 : _props$initialIndex,
          _props$keyLength = _props.keyLength,
          keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength,
          transitionManager = createTransitionManager();
        function setState(nextState) {
          Object(esm_extends.a)(history, nextState),
            (history.length = history.entries.length),
            transitionManager.notifyListeners(history.location, history.action);
        }
        function createKey() {
          return Math.random().toString(36).substr(2, keyLength);
        }
        var index = clamp(initialIndex, 0, initialEntries.length - 1),
          entries = initialEntries.map(function (entry) {
            return createLocation(entry, void 0, 'string' == typeof entry ? createKey() : entry.key || createKey());
          }),
          createHref = createPath;
        function go(n) {
          var nextIndex = clamp(history.index + n, 0, history.entries.length - 1),
            location = history.entries[nextIndex];
          transitionManager.confirmTransitionTo(location, 'POP', getUserConfirmation, function (ok) {
            ok ? setState({ action: 'POP', location, index: nextIndex }) : setState();
          });
        }
        var history = {
          length: entries.length,
          action: 'POP',
          location: entries[index],
          index,
          entries,
          createHref,
          push: function push(path, state) {
            Object(tiny_warning_esm.a)(
              !('object' == typeof path && void 0 !== path.state && void 0 !== state),
              'You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored'
            );
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, 'PUSH', getUserConfirmation, function (ok) {
              if (ok) {
                var nextIndex = history.index + 1,
                  nextEntries = history.entries.slice(0);
                nextEntries.length > nextIndex
                  ? nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location)
                  : nextEntries.push(location),
                  setState({ action: 'PUSH', location, index: nextIndex, entries: nextEntries });
              }
            });
          },
          replace: function replace(path, state) {
            Object(tiny_warning_esm.a)(
              !('object' == typeof path && void 0 !== path.state && void 0 !== state),
              'You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored'
            );
            var location = createLocation(path, state, createKey(), history.location);
            transitionManager.confirmTransitionTo(location, 'REPLACE', getUserConfirmation, function (ok) {
              ok && ((history.entries[history.index] = location), setState({ action: 'REPLACE', location }));
            });
          },
          go,
          goBack: function goBack() {
            go(-1);
          },
          goForward: function goForward() {
            go(1);
          },
          canGo: function canGo(n) {
            var nextIndex = history.index + n;
            return nextIndex >= 0 && nextIndex < history.entries.length;
          },
          block: function block(prompt) {
            return void 0 === prompt && (prompt = !1), transitionManager.setPrompt(prompt);
          },
          listen: function listen(listener) {
            return transitionManager.appendListener(listener);
          },
        };
        return history;
      }
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = __webpack_require__(100);
    },
    function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      !(function () {
        'use strict';
        var hasOwn = {}.hasOwnProperty;
        function classNames() {
          for (var classes = [], i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              var argType = typeof arg;
              if ('string' === argType || 'number' === argType) classes.push((this && this[arg]) || arg);
              else if (Array.isArray(arg)) classes.push(classNames.apply(this, arg));
              else if ('object' === argType)
                for (var key in arg) hasOwn.call(arg, key) && arg[key] && classes.push((this && this[key]) || key);
            }
          }
          return classes.join(' ');
        }
        module.exports
          ? ((classNames.default = classNames), (module.exports = classNames))
          : void 0 ===
              (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                return classNames;
              }.apply(exports, [])) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
      })();
    },
    function (module, exports, __webpack_require__) {
      var freeGlobal = __webpack_require__(53),
        freeSelf = 'object' == typeof self && self && self.Object === Object && self,
        root = freeGlobal || freeSelf || Function('return this')();
      module.exports = root;
    },
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      var reactIs = __webpack_require__(10),
        REACT_STATICS = {
          childContextTypes: !0,
          contextType: !0,
          contextTypes: !0,
          defaultProps: !0,
          displayName: !0,
          getDefaultProps: !0,
          getDerivedStateFromError: !0,
          getDerivedStateFromProps: !0,
          mixins: !0,
          propTypes: !0,
          type: !0,
        },
        KNOWN_STATICS = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 },
        MEMO_STATICS = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 },
        TYPE_STATICS = {};
      function getStatics(component) {
        return reactIs.isMemo(component) ? MEMO_STATICS : TYPE_STATICS[component.$$typeof] || REACT_STATICS;
      }
      (TYPE_STATICS[reactIs.ForwardRef] = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
      }),
        (TYPE_STATICS[reactIs.Memo] = MEMO_STATICS);
      var defineProperty = Object.defineProperty,
        getOwnPropertyNames = Object.getOwnPropertyNames,
        getOwnPropertySymbols = Object.getOwnPropertySymbols,
        getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
        getPrototypeOf = Object.getPrototypeOf,
        objectPrototype = Object.prototype;
      module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if ('string' != typeof sourceComponent) {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            inheritedComponent &&
              inheritedComponent !== objectPrototype &&
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
          var keys = getOwnPropertyNames(sourceComponent);
          getOwnPropertySymbols && (keys = keys.concat(getOwnPropertySymbols(sourceComponent)));
          for (
            var targetStatics = getStatics(targetComponent), sourceStatics = getStatics(sourceComponent), i = 0;
            i < keys.length;
            ++i
          ) {
            var key = keys[i];
            if (
              !(
                KNOWN_STATICS[key] ||
                (blacklist && blacklist[key]) ||
                (sourceStatics && sourceStatics[key]) ||
                (targetStatics && targetStatics[key])
              )
            ) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e) {}
            }
          }
        }
        return targetComponent;
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var getOwnPropertySymbols = Object.getOwnPropertySymbols,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (null == val) throw new TypeError('Object.assign cannot be called with null or undefined');
        return Object(val);
      }
      module.exports = (function shouldUseNative() {
        try {
          if (!Object.assign) return !1;
          var test1 = new String('abc');
          if (((test1[5] = 'de'), '5' === Object.getOwnPropertyNames(test1)[0])) return !1;
          for (var test2 = {}, i = 0; i < 10; i++) test2['_' + String.fromCharCode(i)] = i;
          if (
            '0123456789' !==
            Object.getOwnPropertyNames(test2)
              .map(function (n) {
                return test2[n];
              })
              .join('')
          )
            return !1;
          var test3 = {};
          return (
            'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
              test3[letter] = letter;
            }),
            'abcdefghijklmnopqrst' === Object.keys(Object.assign({}, test3)).join('')
          );
        } catch (err) {
          return !1;
        }
      })()
        ? Object.assign
        : function (target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
              for (var key in (from = Object(arguments[s]))) hasOwnProperty.call(from, key) && (to[key] = from[key]);
              if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++)
                  propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
              }
            }
            return to;
          };
    },
    function (module, exports, __webpack_require__) {
      var baseIsNative = __webpack_require__(116),
        getValue = __webpack_require__(119);
      module.exports = function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      };
    },
    function (module, exports, __webpack_require__) {
      var Symbol = __webpack_require__(38),
        getRawTag = __webpack_require__(107),
        objectToString = __webpack_require__(108),
        symToStringTag = Symbol ? Symbol.toStringTag : void 0;
      module.exports = function baseGetTag(value) {
        return null == value
          ? void 0 === value
            ? '[object Undefined]'
            : '[object Null]'
          : symToStringTag && symToStringTag in Object(value)
          ? getRawTag(value)
          : objectToString(value);
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function isPrefixedValue(value) {
          return 'string' == typeof value && regex.test(value);
        });
      var regex = /-webkit-|-moz-|-ms-/;
      module.exports = exports.default;
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.r(__webpack_exports__),
        __webpack_require__.d(__webpack_exports__, '__DO_NOT_USE__ActionTypes', function () {
          return ActionTypes;
        }),
        __webpack_require__.d(__webpack_exports__, 'applyMiddleware', function () {
          return applyMiddleware;
        }),
        __webpack_require__.d(__webpack_exports__, 'bindActionCreators', function () {
          return bindActionCreators;
        }),
        __webpack_require__.d(__webpack_exports__, 'combineReducers', function () {
          return combineReducers;
        }),
        __webpack_require__.d(__webpack_exports__, 'compose', function () {
          return compose;
        }),
        __webpack_require__.d(__webpack_exports__, 'createStore', function () {
          return createStore;
        });
      var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41),
        randomString = function randomString() {
          return Math.random().toString(36).substring(7).split('').join('.');
        },
        ActionTypes = {
          INIT: '@@redux/INIT' + randomString(),
          REPLACE: '@@redux/REPLACE' + randomString(),
          PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
            return '@@redux/PROBE_UNKNOWN_ACTION' + randomString();
          },
        };
      function isPlainObject(obj) {
        if ('object' != typeof obj || null === obj) return !1;
        for (var proto = obj; null !== Object.getPrototypeOf(proto); ) proto = Object.getPrototypeOf(proto);
        return Object.getPrototypeOf(obj) === proto;
      }
      function createStore(reducer, preloadedState, enhancer) {
        var _ref2;
        if (
          ('function' == typeof preloadedState && 'function' == typeof enhancer) ||
          ('function' == typeof enhancer && 'function' == typeof arguments[3])
        )
          throw new Error(
            'It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function.'
          );
        if (
          ('function' == typeof preloadedState &&
            void 0 === enhancer &&
            ((enhancer = preloadedState), (preloadedState = void 0)),
          void 0 !== enhancer)
        ) {
          if ('function' != typeof enhancer) throw new Error('Expected the enhancer to be a function.');
          return enhancer(createStore)(reducer, preloadedState);
        }
        if ('function' != typeof reducer) throw new Error('Expected the reducer to be a function.');
        var currentReducer = reducer,
          currentState = preloadedState,
          currentListeners = [],
          nextListeners = currentListeners,
          isDispatching = !1;
        function ensureCanMutateNextListeners() {
          nextListeners === currentListeners && (nextListeners = currentListeners.slice());
        }
        function getState() {
          if (isDispatching)
            throw new Error(
              'You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.'
            );
          return currentState;
        }
        function subscribe(listener) {
          if ('function' != typeof listener) throw new Error('Expected the listener to be a function.');
          if (isDispatching)
            throw new Error(
              'You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api-reference/store#subscribelistener for more details.'
            );
          var isSubscribed = !0;
          return (
            ensureCanMutateNextListeners(),
            nextListeners.push(listener),
            function unsubscribe() {
              if (isSubscribed) {
                if (isDispatching)
                  throw new Error(
                    'You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api-reference/store#subscribelistener for more details.'
                  );
                (isSubscribed = !1), ensureCanMutateNextListeners();
                var index = nextListeners.indexOf(listener);
                nextListeners.splice(index, 1), (currentListeners = null);
              }
            }
          );
        }
        function dispatch(action) {
          if (!isPlainObject(action))
            throw new Error('Actions must be plain objects. Use custom middleware for async actions.');
          if (void 0 === action.type)
            throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
          if (isDispatching) throw new Error('Reducers may not dispatch actions.');
          try {
            (isDispatching = !0), (currentState = currentReducer(currentState, action));
          } finally {
            isDispatching = !1;
          }
          for (var listeners = (currentListeners = nextListeners), i = 0; i < listeners.length; i++) {
            (0, listeners[i])();
          }
          return action;
        }
        function replaceReducer(nextReducer) {
          if ('function' != typeof nextReducer) throw new Error('Expected the nextReducer to be a function.');
          (currentReducer = nextReducer), dispatch({ type: ActionTypes.REPLACE });
        }
        function observable() {
          var _ref,
            outerSubscribe = subscribe;
          return (
            ((_ref = {
              subscribe: function subscribe(observer) {
                if ('object' != typeof observer || null === observer)
                  throw new TypeError('Expected the observer to be an object.');
                function observeState() {
                  observer.next && observer.next(getState());
                }
                return observeState(), { unsubscribe: outerSubscribe(observeState) };
              },
            })[symbol_observable__WEBPACK_IMPORTED_MODULE_0__.a] = function () {
              return this;
            }),
            _ref
          );
        }
        return (
          dispatch({ type: ActionTypes.INIT }),
          ((_ref2 = { dispatch, subscribe, getState, replaceReducer })[
            symbol_observable__WEBPACK_IMPORTED_MODULE_0__.a
          ] = observable),
          _ref2
        );
      }
      function warning(message) {
        'undefined' != typeof console && 'function' == typeof console.error && console.error(message);
        try {
          throw new Error(message);
        } catch (e) {}
      }
      function getUndefinedStateErrorMessage(key, action) {
        var actionType = action && action.type;
        return (
          'Given ' +
          ((actionType && 'action "' + String(actionType) + '"') || 'an action') +
          ', reducer "' +
          key +
          '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.'
        );
      }
      function combineReducers(reducers) {
        for (var reducerKeys = Object.keys(reducers), finalReducers = {}, i = 0; i < reducerKeys.length; i++) {
          var key = reducerKeys[i];
          void 0 === reducers[key] && warning('No reducer provided for key "' + key + '"'),
            'function' == typeof reducers[key] && (finalReducers[key] = reducers[key]);
        }
        var unexpectedKeyCache,
          shapeAssertionError,
          finalReducerKeys = Object.keys(finalReducers);
        unexpectedKeyCache = {};
        try {
          !(function assertReducerShape(reducers) {
            Object.keys(reducers).forEach(function (key) {
              var reducer = reducers[key];
              if (void 0 === reducer(void 0, { type: ActionTypes.INIT }))
                throw new Error(
                  'Reducer "' +
                    key +
                    '" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don\'t want to set a value for this reducer, you can use null instead of undefined.'
                );
              if (void 0 === reducer(void 0, { type: ActionTypes.PROBE_UNKNOWN_ACTION() }))
                throw new Error(
                  'Reducer "' +
                    key +
                    '" returned undefined when probed with a random type. Don\'t try to handle ' +
                    ActionTypes.INIT +
                    ' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.'
                );
            });
          })(finalReducers);
        } catch (e) {
          shapeAssertionError = e;
        }
        return function combination(state, action) {
          if ((void 0 === state && (state = {}), shapeAssertionError)) throw shapeAssertionError;
          var warningMessage = (function getUnexpectedStateShapeWarningMessage(
            inputState,
            reducers,
            action,
            unexpectedKeyCache
          ) {
            var reducerKeys = Object.keys(reducers),
              argumentName =
                action && action.type === ActionTypes.INIT
                  ? 'preloadedState argument passed to createStore'
                  : 'previous state received by the reducer';
            if (0 === reducerKeys.length)
              return 'Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.';
            if (!isPlainObject(inputState))
              return (
                'The ' +
                argumentName +
                ' has unexpected type of "' +
                {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] +
                '". Expected argument to be an object with the following keys: "' +
                reducerKeys.join('", "') +
                '"'
              );
            var unexpectedKeys = Object.keys(inputState).filter(function (key) {
              return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
            });
            return (
              unexpectedKeys.forEach(function (key) {
                unexpectedKeyCache[key] = !0;
              }),
              action && action.type === ActionTypes.REPLACE
                ? void 0
                : unexpectedKeys.length > 0
                ? 'Unexpected ' +
                  (unexpectedKeys.length > 1 ? 'keys' : 'key') +
                  ' "' +
                  unexpectedKeys.join('", "') +
                  '" found in ' +
                  argumentName +
                  '. Expected to find one of the known reducer keys instead: "' +
                  reducerKeys.join('", "') +
                  '". Unexpected keys will be ignored.'
                : void 0
            );
          })(state, finalReducers, action, unexpectedKeyCache);
          warningMessage && warning(warningMessage);
          for (var hasChanged = !1, nextState = {}, _i = 0; _i < finalReducerKeys.length; _i++) {
            var _key = finalReducerKeys[_i],
              reducer = finalReducers[_key],
              previousStateForKey = state[_key],
              nextStateForKey = reducer(previousStateForKey, action);
            if (void 0 === nextStateForKey) {
              var errorMessage = getUndefinedStateErrorMessage(_key, action);
              throw new Error(errorMessage);
            }
            (nextState[_key] = nextStateForKey), (hasChanged = hasChanged || nextStateForKey !== previousStateForKey);
          }
          return (hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length) ? nextState : state;
        };
      }
      function bindActionCreator(actionCreator, dispatch) {
        return function () {
          return dispatch(actionCreator.apply(this, arguments));
        };
      }
      function bindActionCreators(actionCreators, dispatch) {
        if ('function' == typeof actionCreators) return bindActionCreator(actionCreators, dispatch);
        if ('object' != typeof actionCreators || null === actionCreators)
          throw new Error(
            'bindActionCreators expected an object or a function, instead received ' +
              (null === actionCreators ? 'null' : typeof actionCreators) +
              '. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?'
          );
        var boundActionCreators = {};
        for (var key in actionCreators) {
          var actionCreator = actionCreators[key];
          'function' == typeof actionCreator && (boundActionCreators[key] = bindActionCreator(actionCreator, dispatch));
        }
        return boundActionCreators;
      }
      function _defineProperty(obj, key, value) {
        return (
          key in obj
            ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 })
            : (obj[key] = value),
          obj
        );
      }
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        return (
          Object.getOwnPropertySymbols && keys.push.apply(keys, Object.getOwnPropertySymbols(object)),
          enumerableOnly &&
            (keys = keys.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })),
          keys
        );
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {};
          i % 2
            ? ownKeys(source, !0).forEach(function (key) {
                _defineProperty(target, key, source[key]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
            : ownKeys(source).forEach(function (key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
        }
        return target;
      }
      function compose() {
        for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++)
          funcs[_key] = arguments[_key];
        return 0 === funcs.length
          ? function (arg) {
              return arg;
            }
          : 1 === funcs.length
          ? funcs[0]
          : funcs.reduce(function (a, b) {
              return function () {
                return a(b.apply(void 0, arguments));
              };
            });
      }
      function applyMiddleware() {
        for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++)
          middlewares[_key] = arguments[_key];
        return function (createStore) {
          return function () {
            var store = createStore.apply(void 0, arguments),
              _dispatch = function dispatch() {
                throw new Error(
                  'Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.'
                );
              },
              middlewareAPI = {
                getState: store.getState,
                dispatch: function dispatch() {
                  return _dispatch.apply(void 0, arguments);
                },
              },
              chain = middlewares.map(function (middleware) {
                return middleware(middlewareAPI);
              });
            return _objectSpread2({}, store, { dispatch: (_dispatch = compose.apply(void 0, chain)(store.dispatch)) });
          };
        };
      }
      function isCrushed() {}
      'string' == typeof isCrushed.name &&
        'isCrushed' !== isCrushed.name &&
        warning(
          'You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.'
        );
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      const Tabify = __webpack_require__(158);
      module.exports = { Tabs: Tabify.Tabs, Tab: Tabify.Tab };
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.r(__webpack_exports__),
        __webpack_require__.d(__webpack_exports__, 'Provider', function () {
          return components_Provider;
        }),
        __webpack_require__.d(__webpack_exports__, 'connectAdvanced', function () {
          return connectAdvanced;
        }),
        __webpack_require__.d(__webpack_exports__, 'ReactReduxContext', function () {
          return ReactReduxContext;
        }),
        __webpack_require__.d(__webpack_exports__, 'connect', function () {
          return connect_connect;
        }),
        __webpack_require__.d(__webpack_exports__, 'batch', function () {
          return react_dom.unstable_batchedUpdates;
        }),
        __webpack_require__.d(__webpack_exports__, 'useDispatch', function () {
          return useDispatch;
        }),
        __webpack_require__.d(__webpack_exports__, 'createDispatchHook', function () {
          return createDispatchHook;
        }),
        __webpack_require__.d(__webpack_exports__, 'useSelector', function () {
          return useSelector_useSelector;
        }),
        __webpack_require__.d(__webpack_exports__, 'createSelectorHook', function () {
          return createSelectorHook;
        }),
        __webpack_require__.d(__webpack_exports__, 'useStore', function () {
          return useStore_useStore;
        }),
        __webpack_require__.d(__webpack_exports__, 'createStoreHook', function () {
          return createStoreHook;
        }),
        __webpack_require__.d(__webpack_exports__, 'shallowEqual', function () {
          return shallowEqual;
        });
      var react = __webpack_require__(0),
        react_default = __webpack_require__.n(react),
        prop_types = __webpack_require__(1),
        prop_types_default = __webpack_require__.n(prop_types),
        ReactReduxContext = react_default.a.createContext(null);
      ReactReduxContext.displayName = 'ReactRedux';
      var batch_batch = function defaultNoopBatch(callback) {
          callback();
        },
        nullListeners = { notify: function notify() {} };
      function createListenerCollection() {
        var batch = (function getBatch() {
            return batch_batch;
          })(),
          first = null,
          last = null;
        return {
          clear: function clear() {
            (first = null), (last = null);
          },
          notify: function notify() {
            batch(function () {
              for (var listener = first; listener; ) listener.callback(), (listener = listener.next);
            });
          },
          get: function get() {
            for (var listeners = [], listener = first; listener; ) listeners.push(listener), (listener = listener.next);
            return listeners;
          },
          subscribe: function subscribe(callback) {
            var isSubscribed = !0,
              listener = (last = { callback, next: null, prev: last });
            return (
              listener.prev ? (listener.prev.next = listener) : (first = listener),
              function unsubscribe() {
                isSubscribed &&
                  null !== first &&
                  ((isSubscribed = !1),
                  listener.next ? (listener.next.prev = listener.prev) : (last = listener.prev),
                  listener.prev ? (listener.prev.next = listener.next) : (first = listener.next));
              }
            );
          },
        };
      }
      var Subscription = (function () {
        function Subscription(store, parentSub) {
          (this.store = store),
            (this.parentSub = parentSub),
            (this.unsubscribe = null),
            (this.listeners = nullListeners),
            (this.handleChangeWrapper = this.handleChangeWrapper.bind(this));
        }
        var _proto = Subscription.prototype;
        return (
          (_proto.addNestedSub = function addNestedSub(listener) {
            return this.trySubscribe(), this.listeners.subscribe(listener);
          }),
          (_proto.notifyNestedSubs = function notifyNestedSubs() {
            this.listeners.notify();
          }),
          (_proto.handleChangeWrapper = function handleChangeWrapper() {
            this.onStateChange && this.onStateChange();
          }),
          (_proto.isSubscribed = function isSubscribed() {
            return Boolean(this.unsubscribe);
          }),
          (_proto.trySubscribe = function trySubscribe() {
            this.unsubscribe ||
              ((this.unsubscribe = this.parentSub
                ? this.parentSub.addNestedSub(this.handleChangeWrapper)
                : this.store.subscribe(this.handleChangeWrapper)),
              (this.listeners = createListenerCollection()));
          }),
          (_proto.tryUnsubscribe = function tryUnsubscribe() {
            this.unsubscribe &&
              (this.unsubscribe(), (this.unsubscribe = null), this.listeners.clear(), (this.listeners = nullListeners));
          }),
          Subscription
        );
      })();
      function Provider(_ref) {
        var store = _ref.store,
          context = _ref.context,
          children = _ref.children,
          contextValue = Object(react.useMemo)(
            function () {
              var subscription = new Subscription(store);
              return (subscription.onStateChange = subscription.notifyNestedSubs), { store, subscription };
            },
            [store]
          ),
          previousState = Object(react.useMemo)(
            function () {
              return store.getState();
            },
            [store]
          );
        Object(react.useEffect)(
          function () {
            var subscription = contextValue.subscription;
            return (
              subscription.trySubscribe(),
              previousState !== store.getState() && subscription.notifyNestedSubs(),
              function () {
                subscription.tryUnsubscribe(), (subscription.onStateChange = null);
              }
            );
          },
          [contextValue, previousState]
        );
        var Context = context || ReactReduxContext;
        return react_default.a.createElement(Context.Provider, { value: contextValue }, children);
      }
      Provider.propTypes = {
        store: prop_types_default.a.shape({
          subscribe: prop_types_default.a.func.isRequired,
          dispatch: prop_types_default.a.func.isRequired,
          getState: prop_types_default.a.func.isRequired,
        }),
        context: prop_types_default.a.object,
        children: prop_types_default.a.any,
      };
      var components_Provider = Provider,
        esm_extends = __webpack_require__(2),
        objectWithoutPropertiesLoose = __webpack_require__(5),
        hoist_non_react_statics_cjs = __webpack_require__(14),
        hoist_non_react_statics_cjs_default = __webpack_require__.n(hoist_non_react_statics_cjs),
        react_is = __webpack_require__(10),
        useIsomorphicLayoutEffect =
          'undefined' != typeof window && void 0 !== window.document && void 0 !== window.document.createElement
            ? react.useLayoutEffect
            : react.useEffect,
        EMPTY_ARRAY = [],
        NO_SUBSCRIPTION_ARRAY = [null, null];
      function storeStateUpdatesReducer(state, action) {
        var updateCount = state[1];
        return [action.payload, updateCount + 1];
      }
      function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
        useIsomorphicLayoutEffect(function () {
          return effectFunc.apply(void 0, effectArgs);
        }, dependencies);
      }
      function captureWrapperProps(
        lastWrapperProps,
        lastChildProps,
        renderIsScheduled,
        wrapperProps,
        actualChildProps,
        childPropsFromStoreUpdate,
        notifyNestedSubs
      ) {
        (lastWrapperProps.current = wrapperProps),
          (lastChildProps.current = actualChildProps),
          (renderIsScheduled.current = !1),
          childPropsFromStoreUpdate.current && ((childPropsFromStoreUpdate.current = null), notifyNestedSubs());
      }
      function subscribeUpdates(
        shouldHandleStateChanges,
        store,
        subscription,
        childPropsSelector,
        lastWrapperProps,
        lastChildProps,
        renderIsScheduled,
        childPropsFromStoreUpdate,
        notifyNestedSubs,
        forceComponentUpdateDispatch
      ) {
        if (shouldHandleStateChanges) {
          var didUnsubscribe = !1,
            lastThrownError = null,
            checkForUpdates = function checkForUpdates() {
              if (!didUnsubscribe) {
                var newChildProps,
                  error,
                  latestStoreState = store.getState();
                try {
                  newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
                } catch (e) {
                  (error = e), (lastThrownError = e);
                }
                error || (lastThrownError = null),
                  newChildProps === lastChildProps.current
                    ? renderIsScheduled.current || notifyNestedSubs()
                    : ((lastChildProps.current = newChildProps),
                      (childPropsFromStoreUpdate.current = newChildProps),
                      (renderIsScheduled.current = !0),
                      forceComponentUpdateDispatch({ type: 'STORE_UPDATED', payload: { error } }));
              }
            };
          (subscription.onStateChange = checkForUpdates), subscription.trySubscribe(), checkForUpdates();
          return function unsubscribeWrapper() {
            if (
              ((didUnsubscribe = !0),
              subscription.tryUnsubscribe(),
              (subscription.onStateChange = null),
              lastThrownError)
            )
              throw lastThrownError;
          };
        }
      }
      var initStateUpdates = function initStateUpdates() {
        return [null, 0];
      };
      function connectAdvanced(selectorFactory, _ref) {
        void 0 === _ref && (_ref = {});
        var _ref2 = _ref,
          _ref2$getDisplayName = _ref2.getDisplayName,
          getDisplayName =
            void 0 === _ref2$getDisplayName
              ? function (name) {
                  return 'ConnectAdvanced(' + name + ')';
                }
              : _ref2$getDisplayName,
          _ref2$methodName = _ref2.methodName,
          methodName = void 0 === _ref2$methodName ? 'connectAdvanced' : _ref2$methodName,
          _ref2$renderCountProp = _ref2.renderCountProp,
          renderCountProp = void 0 === _ref2$renderCountProp ? void 0 : _ref2$renderCountProp,
          _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
          shouldHandleStateChanges = void 0 === _ref2$shouldHandleSta || _ref2$shouldHandleSta,
          _ref2$storeKey = _ref2.storeKey,
          storeKey = void 0 === _ref2$storeKey ? 'store' : _ref2$storeKey,
          _ref2$withRef = _ref2.withRef,
          withRef = void 0 !== _ref2$withRef && _ref2$withRef,
          _ref2$forwardRef = _ref2.forwardRef,
          forwardRef = void 0 !== _ref2$forwardRef && _ref2$forwardRef,
          _ref2$context = _ref2.context,
          context = void 0 === _ref2$context ? ReactReduxContext : _ref2$context,
          connectOptions = Object(objectWithoutPropertiesLoose.a)(_ref2, [
            'getDisplayName',
            'methodName',
            'renderCountProp',
            'shouldHandleStateChanges',
            'storeKey',
            'withRef',
            'forwardRef',
            'context',
          ]);
        if (void 0 !== renderCountProp)
          throw new Error(
            'renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension'
          );
        if (withRef)
          throw new Error('withRef is removed. To access the wrapped instance, use a ref on the connected component');
        if ('store' !== storeKey)
          throw new Error(
            "storeKey has been removed and does not do anything. To use a custom Redux store for specific components, create a custom React context with React.createContext(), and pass the context object to React Redux's Provider and specific components like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. You may also pass a {context : MyContext} option to connect"
          );
        var Context = context;
        return function wrapWithConnect(WrappedComponent) {
          if (!Object(react_is.isValidElementType)(WrappedComponent))
            throw new Error(
              'You must pass a component to the function returned by ' +
                methodName +
                '. Instead received ' +
                (function stringifyComponent(Comp) {
                  try {
                    return JSON.stringify(Comp);
                  } catch (err) {
                    return String(Comp);
                  }
                })(WrappedComponent)
            );
          var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component',
            displayName = getDisplayName(wrappedComponentName),
            selectorFactoryOptions = Object(esm_extends.a)({}, connectOptions, {
              getDisplayName,
              methodName,
              renderCountProp,
              shouldHandleStateChanges,
              storeKey,
              displayName,
              wrappedComponentName,
              WrappedComponent,
            }),
            pure = connectOptions.pure;
          var usePureOnlyMemo = pure
            ? react.useMemo
            : function (callback) {
                return callback();
              };
          function ConnectFunction(props) {
            var _useMemo = Object(react.useMemo)(
                function () {
                  var reactReduxForwardedRef = props.reactReduxForwardedRef,
                    wrapperProps = Object(objectWithoutPropertiesLoose.a)(props, ['reactReduxForwardedRef']);
                  return [props.context, reactReduxForwardedRef, wrapperProps];
                },
                [props]
              ),
              propsContext = _useMemo[0],
              reactReduxForwardedRef = _useMemo[1],
              wrapperProps = _useMemo[2],
              ContextToUse = Object(react.useMemo)(
                function () {
                  return propsContext &&
                    propsContext.Consumer &&
                    Object(react_is.isContextConsumer)(react_default.a.createElement(propsContext.Consumer, null))
                    ? propsContext
                    : Context;
                },
                [propsContext, Context]
              ),
              contextValue = Object(react.useContext)(ContextToUse),
              didStoreComeFromProps =
                Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch),
              didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
            if (!didStoreComeFromProps && !didStoreComeFromContext)
              throw new Error(
                'Could not find "store" in the context of "' +
                  displayName +
                  '". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ' +
                  displayName +
                  ' in connect options.'
              );
            var store = didStoreComeFromProps ? props.store : contextValue.store,
              childPropsSelector = Object(react.useMemo)(
                function () {
                  return (function createChildSelector(store) {
                    return selectorFactory(store.dispatch, selectorFactoryOptions);
                  })(store);
                },
                [store]
              ),
              _useMemo2 = Object(react.useMemo)(
                function () {
                  if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
                  var subscription = new Subscription(store, didStoreComeFromProps ? null : contextValue.subscription),
                    notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
                  return [subscription, notifyNestedSubs];
                },
                [store, didStoreComeFromProps, contextValue]
              ),
              subscription = _useMemo2[0],
              notifyNestedSubs = _useMemo2[1],
              overriddenContextValue = Object(react.useMemo)(
                function () {
                  return didStoreComeFromProps
                    ? contextValue
                    : Object(esm_extends.a)({}, contextValue, { subscription });
                },
                [didStoreComeFromProps, contextValue, subscription]
              ),
              _useReducer = Object(react.useReducer)(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),
              previousStateUpdateResult = _useReducer[0][0],
              forceComponentUpdateDispatch = _useReducer[1];
            if (previousStateUpdateResult && previousStateUpdateResult.error) throw previousStateUpdateResult.error;
            var lastChildProps = Object(react.useRef)(),
              lastWrapperProps = Object(react.useRef)(wrapperProps),
              childPropsFromStoreUpdate = Object(react.useRef)(),
              renderIsScheduled = Object(react.useRef)(!1),
              actualChildProps = usePureOnlyMemo(
                function () {
                  return childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current
                    ? childPropsFromStoreUpdate.current
                    : childPropsSelector(store.getState(), wrapperProps);
                },
                [store, previousStateUpdateResult, wrapperProps]
              );
            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
              lastWrapperProps,
              lastChildProps,
              renderIsScheduled,
              wrapperProps,
              actualChildProps,
              childPropsFromStoreUpdate,
              notifyNestedSubs,
            ]),
              useIsomorphicLayoutEffectWithArgs(
                subscribeUpdates,
                [
                  shouldHandleStateChanges,
                  store,
                  subscription,
                  childPropsSelector,
                  lastWrapperProps,
                  lastChildProps,
                  renderIsScheduled,
                  childPropsFromStoreUpdate,
                  notifyNestedSubs,
                  forceComponentUpdateDispatch,
                ],
                [store, subscription, childPropsSelector]
              );
            var renderedWrappedComponent = Object(react.useMemo)(
              function () {
                return react_default.a.createElement(
                  WrappedComponent,
                  Object(esm_extends.a)({}, actualChildProps, { ref: reactReduxForwardedRef })
                );
              },
              [reactReduxForwardedRef, WrappedComponent, actualChildProps]
            );
            return Object(react.useMemo)(
              function () {
                return shouldHandleStateChanges
                  ? react_default.a.createElement(
                      ContextToUse.Provider,
                      { value: overriddenContextValue },
                      renderedWrappedComponent
                    )
                  : renderedWrappedComponent;
              },
              [ContextToUse, renderedWrappedComponent, overriddenContextValue]
            );
          }
          var Connect = pure ? react_default.a.memo(ConnectFunction) : ConnectFunction;
          if (((Connect.WrappedComponent = WrappedComponent), (Connect.displayName = displayName), forwardRef)) {
            var forwarded = react_default.a.forwardRef(function forwardConnectRef(props, ref) {
              return react_default.a.createElement(
                Connect,
                Object(esm_extends.a)({}, props, { reactReduxForwardedRef: ref })
              );
            });
            return (
              (forwarded.displayName = displayName),
              (forwarded.WrappedComponent = WrappedComponent),
              hoist_non_react_statics_cjs_default()(forwarded, WrappedComponent)
            );
          }
          return hoist_non_react_statics_cjs_default()(Connect, WrappedComponent);
        };
      }
      function is(x, y) {
        return x === y ? 0 !== x || 0 !== y || 1 / x == 1 / y : x != x && y != y;
      }
      function shallowEqual(objA, objB) {
        if (is(objA, objB)) return !0;
        if ('object' != typeof objA || null === objA || 'object' != typeof objB || null === objB) return !1;
        var keysA = Object.keys(objA),
          keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return !1;
        for (var i = 0; i < keysA.length; i++)
          if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) return !1;
        return !0;
      }
      var redux = __webpack_require__(19);
      function warning(message) {
        'undefined' != typeof console && 'function' == typeof console.error && console.error(message);
        try {
          throw new Error(message);
        } catch (e) {}
      }
      function verifyPlainObject(value, displayName, methodName) {
        (function isPlainObject(obj) {
          if ('object' != typeof obj || null === obj) return !1;
          var proto = Object.getPrototypeOf(obj);
          if (null === proto) return !0;
          for (var baseProto = proto; null !== Object.getPrototypeOf(baseProto); )
            baseProto = Object.getPrototypeOf(baseProto);
          return proto === baseProto;
        })(value) ||
          warning(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
      }
      function wrapMapToPropsConstant(getConstant) {
        return function initConstantSelector(dispatch, options) {
          var constant = getConstant(dispatch, options);
          function constantSelector() {
            return constant;
          }
          return (constantSelector.dependsOnOwnProps = !1), constantSelector;
        };
      }
      function getDependsOnOwnProps(mapToProps) {
        return null !== mapToProps.dependsOnOwnProps && void 0 !== mapToProps.dependsOnOwnProps
          ? Boolean(mapToProps.dependsOnOwnProps)
          : 1 !== mapToProps.length;
      }
      function wrapMapToPropsFunc(mapToProps, methodName) {
        return function initProxySelector(dispatch, _ref) {
          var displayName = _ref.displayName,
            proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
              return proxy.dependsOnOwnProps
                ? proxy.mapToProps(stateOrDispatch, ownProps)
                : proxy.mapToProps(stateOrDispatch);
            };
          return (
            (proxy.dependsOnOwnProps = !0),
            (proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
              (proxy.mapToProps = mapToProps), (proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps));
              var props = proxy(stateOrDispatch, ownProps);
              return (
                'function' == typeof props &&
                  ((proxy.mapToProps = props),
                  (proxy.dependsOnOwnProps = getDependsOnOwnProps(props)),
                  (props = proxy(stateOrDispatch, ownProps))),
                verifyPlainObject(props, displayName, methodName),
                props
              );
            }),
            proxy
          );
        };
      }
      var connect_mapDispatchToProps = [
        function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
          return 'function' == typeof mapDispatchToProps
            ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps')
            : void 0;
        },
        function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
          return mapDispatchToProps
            ? void 0
            : wrapMapToPropsConstant(function (dispatch) {
                return { dispatch };
              });
        },
        function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
          return mapDispatchToProps && 'object' == typeof mapDispatchToProps
            ? wrapMapToPropsConstant(function (dispatch) {
                return Object(redux.bindActionCreators)(mapDispatchToProps, dispatch);
              })
            : void 0;
        },
      ];
      var connect_mapStateToProps = [
        function whenMapStateToPropsIsFunction(mapStateToProps) {
          return 'function' == typeof mapStateToProps ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : void 0;
        },
        function whenMapStateToPropsIsMissing(mapStateToProps) {
          return mapStateToProps
            ? void 0
            : wrapMapToPropsConstant(function () {
                return {};
              });
        },
      ];
      function defaultMergeProps(stateProps, dispatchProps, ownProps) {
        return Object(esm_extends.a)({}, ownProps, {}, stateProps, {}, dispatchProps);
      }
      var connect_mergeProps = [
        function whenMergePropsIsFunction(mergeProps) {
          return 'function' == typeof mergeProps
            ? (function wrapMergePropsFunc(mergeProps) {
                return function initMergePropsProxy(dispatch, _ref) {
                  var mergedProps,
                    displayName = _ref.displayName,
                    pure = _ref.pure,
                    areMergedPropsEqual = _ref.areMergedPropsEqual,
                    hasRunOnce = !1;
                  return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
                    var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
                    return (
                      hasRunOnce
                        ? (pure && areMergedPropsEqual(nextMergedProps, mergedProps)) || (mergedProps = nextMergedProps)
                        : ((hasRunOnce = !0),
                          verifyPlainObject((mergedProps = nextMergedProps), displayName, 'mergeProps')),
                      mergedProps
                    );
                  };
                };
              })(mergeProps)
            : void 0;
        },
        function whenMergePropsIsOmitted(mergeProps) {
          return mergeProps
            ? void 0
            : function () {
                return defaultMergeProps;
              };
        },
      ];
      function verify(selector, methodName, displayName) {
        if (!selector) throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
        ('mapStateToProps' !== methodName && 'mapDispatchToProps' !== methodName) ||
          Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps') ||
          warning(
            'The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.'
          );
      }
      function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
        return function impureFinalPropsSelector(state, ownProps) {
          return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
        };
      }
      function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
        var state,
          ownProps,
          stateProps,
          dispatchProps,
          mergedProps,
          areStatesEqual = _ref.areStatesEqual,
          areOwnPropsEqual = _ref.areOwnPropsEqual,
          areStatePropsEqual = _ref.areStatePropsEqual,
          hasRunAtLeastOnce = !1;
        function handleSubsequentCalls(nextState, nextOwnProps) {
          var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps),
            stateChanged = !areStatesEqual(nextState, state);
          return (
            (state = nextState),
            (ownProps = nextOwnProps),
            propsChanged && stateChanged
              ? (function handleNewPropsAndNewState() {
                  return (
                    (stateProps = mapStateToProps(state, ownProps)),
                    mapDispatchToProps.dependsOnOwnProps && (dispatchProps = mapDispatchToProps(dispatch, ownProps)),
                    (mergedProps = mergeProps(stateProps, dispatchProps, ownProps))
                  );
                })()
              : propsChanged
              ? (function handleNewProps() {
                  return (
                    mapStateToProps.dependsOnOwnProps && (stateProps = mapStateToProps(state, ownProps)),
                    mapDispatchToProps.dependsOnOwnProps && (dispatchProps = mapDispatchToProps(dispatch, ownProps)),
                    (mergedProps = mergeProps(stateProps, dispatchProps, ownProps))
                  );
                })()
              : stateChanged
              ? (function handleNewState() {
                  var nextStateProps = mapStateToProps(state, ownProps),
                    statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
                  return (
                    (stateProps = nextStateProps),
                    statePropsChanged && (mergedProps = mergeProps(stateProps, dispatchProps, ownProps)),
                    mergedProps
                  );
                })()
              : mergedProps
          );
        }
        return function pureFinalPropsSelector(nextState, nextOwnProps) {
          return hasRunAtLeastOnce
            ? handleSubsequentCalls(nextState, nextOwnProps)
            : (function handleFirstCall(firstState, firstOwnProps) {
                return (
                  (stateProps = mapStateToProps((state = firstState), (ownProps = firstOwnProps))),
                  (dispatchProps = mapDispatchToProps(dispatch, ownProps)),
                  (mergedProps = mergeProps(stateProps, dispatchProps, ownProps)),
                  (hasRunAtLeastOnce = !0),
                  mergedProps
                );
              })(nextState, nextOwnProps);
        };
      }
      function finalPropsSelectorFactory(dispatch, _ref2) {
        var initMapStateToProps = _ref2.initMapStateToProps,
          initMapDispatchToProps = _ref2.initMapDispatchToProps,
          initMergeProps = _ref2.initMergeProps,
          options = Object(objectWithoutPropertiesLoose.a)(_ref2, [
            'initMapStateToProps',
            'initMapDispatchToProps',
            'initMergeProps',
          ]),
          mapStateToProps = initMapStateToProps(dispatch, options),
          mapDispatchToProps = initMapDispatchToProps(dispatch, options),
          mergeProps = initMergeProps(dispatch, options);
        return (
          (function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
            verify(mapStateToProps, 'mapStateToProps', displayName),
              verify(mapDispatchToProps, 'mapDispatchToProps', displayName),
              verify(mergeProps, 'mergeProps', displayName);
          })(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName),
          (options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory)(
            mapStateToProps,
            mapDispatchToProps,
            mergeProps,
            dispatch,
            options
          )
        );
      }
      function match(arg, factories, name) {
        for (var i = factories.length - 1; i >= 0; i--) {
          var result = factories[i](arg);
          if (result) return result;
        }
        return function (dispatch, options) {
          throw new Error(
            'Invalid value of type ' +
              typeof arg +
              ' for ' +
              name +
              ' argument when connecting component ' +
              options.wrappedComponentName +
              '.'
          );
        };
      }
      function strictEqual(a, b) {
        return a === b;
      }
      function createConnect(_temp) {
        var _ref = void 0 === _temp ? {} : _temp,
          _ref$connectHOC = _ref.connectHOC,
          connectHOC = void 0 === _ref$connectHOC ? connectAdvanced : _ref$connectHOC,
          _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
          mapStateToPropsFactories = void 0 === _ref$mapStateToPropsF ? connect_mapStateToProps : _ref$mapStateToPropsF,
          _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
          mapDispatchToPropsFactories =
            void 0 === _ref$mapDispatchToPro ? connect_mapDispatchToProps : _ref$mapDispatchToPro,
          _ref$mergePropsFactor = _ref.mergePropsFactories,
          mergePropsFactories = void 0 === _ref$mergePropsFactor ? connect_mergeProps : _ref$mergePropsFactor,
          _ref$selectorFactory = _ref.selectorFactory,
          selectorFactory = void 0 === _ref$selectorFactory ? finalPropsSelectorFactory : _ref$selectorFactory;
        return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
          void 0 === _ref2 && (_ref2 = {});
          var _ref3 = _ref2,
            _ref3$pure = _ref3.pure,
            pure = void 0 === _ref3$pure || _ref3$pure,
            _ref3$areStatesEqual = _ref3.areStatesEqual,
            areStatesEqual = void 0 === _ref3$areStatesEqual ? strictEqual : _ref3$areStatesEqual,
            _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
            areOwnPropsEqual = void 0 === _ref3$areOwnPropsEqua ? shallowEqual : _ref3$areOwnPropsEqua,
            _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
            areStatePropsEqual = void 0 === _ref3$areStatePropsEq ? shallowEqual : _ref3$areStatePropsEq,
            _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
            areMergedPropsEqual = void 0 === _ref3$areMergedPropsE ? shallowEqual : _ref3$areMergedPropsE,
            extraOptions = Object(objectWithoutPropertiesLoose.a)(_ref3, [
              'pure',
              'areStatesEqual',
              'areOwnPropsEqual',
              'areStatePropsEqual',
              'areMergedPropsEqual',
            ]),
            initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps'),
            initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps'),
            initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
          return connectHOC(
            selectorFactory,
            Object(esm_extends.a)(
              {
                methodName: 'connect',
                getDisplayName: function getDisplayName(name) {
                  return 'Connect(' + name + ')';
                },
                shouldHandleStateChanges: Boolean(mapStateToProps),
                initMapStateToProps,
                initMapDispatchToProps,
                initMergeProps,
                pure,
                areStatesEqual,
                areOwnPropsEqual,
                areStatePropsEqual,
                areMergedPropsEqual,
              },
              extraOptions
            )
          );
        };
      }
      var connect_connect = createConnect();
      function useReduxContext_useReduxContext() {
        var contextValue = Object(react.useContext)(ReactReduxContext);
        if (!contextValue)
          throw new Error(
            'could not find react-redux context value; please ensure the component is wrapped in a <Provider>'
          );
        return contextValue;
      }
      function createStoreHook(context) {
        void 0 === context && (context = ReactReduxContext);
        var useReduxContext =
          context === ReactReduxContext
            ? useReduxContext_useReduxContext
            : function () {
                return Object(react.useContext)(context);
              };
        return function useStore() {
          return useReduxContext().store;
        };
      }
      var useStore_useStore = createStoreHook();
      function createDispatchHook(context) {
        void 0 === context && (context = ReactReduxContext);
        var useStore = context === ReactReduxContext ? useStore_useStore : createStoreHook(context);
        return function useDispatch() {
          return useStore().dispatch;
        };
      }
      var useDispatch = createDispatchHook(),
        refEquality = function refEquality(a, b) {
          return a === b;
        };
      function createSelectorHook(context) {
        void 0 === context && (context = ReactReduxContext);
        var useReduxContext =
          context === ReactReduxContext
            ? useReduxContext_useReduxContext
            : function () {
                return Object(react.useContext)(context);
              };
        return function useSelector(selector, equalityFn) {
          if ((void 0 === equalityFn && (equalityFn = refEquality), !selector))
            throw new Error('You must pass a selector to useSelector');
          var _useReduxContext = useReduxContext(),
            selectedState = (function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
              var selectedState,
                forceRender = Object(react.useReducer)(function (s) {
                  return s + 1;
                }, 0)[1],
                subscription = Object(react.useMemo)(
                  function () {
                    return new Subscription(store, contextSub);
                  },
                  [store, contextSub]
                ),
                latestSubscriptionCallbackError = Object(react.useRef)(),
                latestSelector = Object(react.useRef)(),
                latestStoreState = Object(react.useRef)(),
                latestSelectedState = Object(react.useRef)(),
                storeState = store.getState();
              try {
                selectedState =
                  selector !== latestSelector.current ||
                  storeState !== latestStoreState.current ||
                  latestSubscriptionCallbackError.current
                    ? selector(storeState)
                    : latestSelectedState.current;
              } catch (err) {
                throw (
                  (latestSubscriptionCallbackError.current &&
                    (err.message +=
                      '\nThe error may be correlated with this previous error:\n' +
                      latestSubscriptionCallbackError.current.stack +
                      '\n\n'),
                  err)
                );
              }
              return (
                useIsomorphicLayoutEffect(function () {
                  (latestSelector.current = selector),
                    (latestStoreState.current = storeState),
                    (latestSelectedState.current = selectedState),
                    (latestSubscriptionCallbackError.current = void 0);
                }),
                useIsomorphicLayoutEffect(
                  function () {
                    function checkForUpdates() {
                      try {
                        var newSelectedState = latestSelector.current(store.getState());
                        if (equalityFn(newSelectedState, latestSelectedState.current)) return;
                        latestSelectedState.current = newSelectedState;
                      } catch (err) {
                        latestSubscriptionCallbackError.current = err;
                      }
                      forceRender();
                    }
                    return (
                      (subscription.onStateChange = checkForUpdates),
                      subscription.trySubscribe(),
                      checkForUpdates(),
                      function () {
                        return subscription.tryUnsubscribe();
                      }
                    );
                  },
                  [store, subscription]
                ),
                selectedState
              );
            })(selector, equalityFn, _useReduxContext.store, _useReduxContext.subscription);
          return Object(react.useDebugValue)(selectedState), selectedState;
        };
      }
      var useSelector_useSelector = createSelectorHook(),
        react_dom = __webpack_require__(34);
      !(function setBatch(newBatch) {
        batch_batch = newBatch;
      })(react_dom.unstable_batchedUpdates);
    },
    function (module, exports) {
      var g;
      g = (function () {
        return this;
      })();
      try {
        g = g || new Function('return this')();
      } catch (e) {
        'object' == typeof window && (g = window);
      }
      module.exports = g;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.OptionKey = exports.PayloadKeys = exports.ProcessorType = exports.EntityActionType = void 0),
        (function (EntityActionType) {
          (EntityActionType.Request = '__redux-entity__FETCH_REQUEST'),
            (EntityActionType.Success = '__redux-entity__FETCH_SUCCESS'),
            (EntityActionType.Failure = '__redux-entity__FETCH_FAILURE'),
            (EntityActionType.Reset = '__redux-entity__RESET_ENTITY'),
            (EntityActionType.Delete = '__redux-entity__DELETE_ENTITY');
        })(exports.EntityActionType || (exports.EntityActionType = {})),
        (function (ProcessorType) {
          (ProcessorType.BeforeSuccess = 'beforeSuccess'),
            (ProcessorType.AfterSuccess = 'afterSuccess'),
            (ProcessorType.BeforeFailure = 'beforeFailure'),
            (ProcessorType.AfterFailure = 'afterFailure');
        })(exports.ProcessorType || (exports.ProcessorType = {})),
        (function (PayloadKeys) {
          (PayloadKeys.Data = 'data'),
            (PayloadKeys.Error = 'error'),
            (PayloadKeys.LastUpdated = 'lastUpdated'),
            (PayloadKeys.Append = 'append');
        })(exports.PayloadKeys || (exports.PayloadKeys = {})),
        (function (OptionKey) {
          (OptionKey.Silent = 'silent'), (OptionKey.Append = 'append'), (OptionKey.Processors = 'processors');
        })(exports.OptionKey || (exports.OptionKey = {}));
    },
    function (module, exports) {
      var isArray = Array.isArray;
      module.exports = isArray;
    },
    function (module, exports) {
      module.exports = function isObjectLike(value) {
        return null != value && 'object' == typeof value;
      };
    },
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(16)(Object, 'create');
      module.exports = nativeCreate;
    },
    function (module, exports, __webpack_require__) {
      var eq = __webpack_require__(127);
      module.exports = function assocIndexOf(array, key) {
        for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
        return -1;
      };
    },
    function (module, exports, __webpack_require__) {
      var isKeyable = __webpack_require__(132);
      module.exports = function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data['string' == typeof key ? 'string' : 'hash'] : data.map;
      };
    },
    ,
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      const delay = __webpack_require__(157),
        pMinDelay = async (promise, minimumDelay, options) => {
          let promiseError;
          (options = { delayRejection: !0, ...options }).delayRejection &&
            (promise = promise.catch((error) => {
              promiseError = error;
            }));
          const value = await Promise.all([promise, delay(minimumDelay)]);
          return promiseError ? Promise.reject(promiseError) : value[0];
        };
      (module.exports = pMinDelay), (module.exports.default = pMinDelay);
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      var react = __webpack_require__(0),
        react_default = __webpack_require__.n(react),
        objectWithoutPropertiesLoose = __webpack_require__(5),
        esm_extends = __webpack_require__(2);
      function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
      }
      var inheritsLoose = __webpack_require__(7),
        react_is = __webpack_require__(10),
        hoist_non_react_statics_cjs = __webpack_require__(14),
        hoist_non_react_statics_cjs_default = __webpack_require__.n(hoist_non_react_statics_cjs);
      function invariant(condition, message) {
        if (!condition) {
          var error = new Error('loadable: ' + message);
          throw ((error.framesToPop = 1), (error.name = 'Invariant Violation'), error);
        }
      }
      var Context = react_default.a.createContext();
      var LOADABLE_SHARED = { initialChunks: {} };
      var identity = function identity(v) {
        return v;
      };
      function createLoadable(_ref) {
        var _ref$defaultResolveCo = _ref.defaultResolveComponent,
          defaultResolveComponent = void 0 === _ref$defaultResolveCo ? identity : _ref$defaultResolveCo,
          _render = _ref.render,
          onLoad = _ref.onLoad;
        function loadable(loadableConstructor, options) {
          void 0 === options && (options = {});
          var ctor = (function resolveConstructor(ctor) {
              return 'function' == typeof ctor ? { requireAsync: ctor } : ctor;
            })(loadableConstructor),
            cache = {};
          function _getCacheKey(props) {
            return options.cacheKey ? options.cacheKey(props) : ctor.resolve ? ctor.resolve(props) : null;
          }
          function resolve(module, props, Loadable) {
            var Component = options.resolveComponent
              ? options.resolveComponent(module, props)
              : defaultResolveComponent(module);
            if (options.resolveComponent && !Object(react_is.isValidElementType)(Component))
              throw new Error('resolveComponent returned something that is not a React component!');
            return hoist_non_react_statics_cjs_default()(Loadable, Component, { preload: !0 }), Component;
          }
          var EnhancedInnerLoadable = (function withChunkExtractor(Component) {
              return function (props) {
                return react_default.a.createElement(Context.Consumer, null, function (extractor) {
                  return react_default.a.createElement(
                    Component,
                    Object.assign({ __chunkExtractor: extractor }, props)
                  );
                });
              };
            })(
              (function (_React$Component) {
                function InnerLoadable(props) {
                  var _this;
                  return (
                    ((_this = _React$Component.call(this, props) || this).state = {
                      result: null,
                      error: null,
                      loading: !0,
                      cacheKey: _getCacheKey(props),
                    }),
                    (_this.promise = null),
                    invariant(
                      !props.__chunkExtractor || ctor.requireSync,
                      'SSR requires `@loadable/babel-plugin`, please install it'
                    ),
                    props.__chunkExtractor
                      ? (!1 === options.ssr ||
                          (ctor.requireAsync(props).catch(function () {}),
                          _this.loadSync(),
                          props.__chunkExtractor.addChunk(ctor.chunkName(props))),
                        _assertThisInitialized(_this))
                      : (!1 !== options.ssr &&
                          ((ctor.isReady && ctor.isReady(props)) ||
                            (ctor.chunkName && LOADABLE_SHARED.initialChunks[ctor.chunkName(props)])) &&
                          _this.loadSync(),
                        _this)
                  );
                }
                Object(inheritsLoose.a)(InnerLoadable, _React$Component),
                  (InnerLoadable.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
                    var cacheKey = _getCacheKey(props);
                    return Object(esm_extends.a)({}, state, {
                      cacheKey,
                      loading: state.loading || state.cacheKey !== cacheKey,
                    });
                  });
                var _proto = InnerLoadable.prototype;
                return (
                  (_proto.componentDidMount = function componentDidMount() {
                    (this.mounted = !0),
                      this.state.loading ? this.loadAsync() : this.state.error || this.triggerOnLoad();
                  }),
                  (_proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
                    prevState.cacheKey !== this.state.cacheKey && ((this.promise = null), this.loadAsync());
                  }),
                  (_proto.componentWillUnmount = function componentWillUnmount() {
                    this.mounted = !1;
                  }),
                  (_proto.safeSetState = function safeSetState(nextState, callback) {
                    this.mounted && this.setState(nextState, callback);
                  }),
                  (_proto.triggerOnLoad = function triggerOnLoad() {
                    var _this2 = this;
                    onLoad &&
                      setTimeout(function () {
                        onLoad(_this2.state.result, _this2.props);
                      });
                  }),
                  (_proto.loadSync = function loadSync() {
                    if (this.state.loading)
                      try {
                        var result = resolve(ctor.requireSync(this.props), this.props, Loadable);
                        (this.state.result = result), (this.state.loading = !1);
                      } catch (error) {
                        this.state.error = error;
                      }
                  }),
                  (_proto.getCacheKey = function getCacheKey() {
                    return _getCacheKey(this.props) || JSON.stringify(this.props);
                  }),
                  (_proto.getCache = function getCache() {
                    return cache[this.getCacheKey()];
                  }),
                  (_proto.setCache = function setCache(value) {
                    cache[this.getCacheKey()] = value;
                  }),
                  (_proto.loadAsync = function loadAsync() {
                    var _this3 = this;
                    if (!this.promise) {
                      var _this$props = this.props,
                        props =
                          (_this$props.__chunkExtractor,
                          _this$props.forwardedRef,
                          Object(objectWithoutPropertiesLoose.a)(_this$props, ['__chunkExtractor', 'forwardedRef']));
                      this.promise = ctor
                        .requireAsync(props)
                        .then(function (loadedModule) {
                          var result = resolve(loadedModule, _this3.props, Loadable);
                          options.suspense && _this3.setCache(result),
                            _this3.safeSetState(
                              { result: resolve(loadedModule, _this3.props, Loadable), loading: !1 },
                              function () {
                                return _this3.triggerOnLoad();
                              }
                            );
                        })
                        .catch(function (error) {
                          _this3.safeSetState({ error, loading: !1 });
                        });
                    }
                    return this.promise;
                  }),
                  (_proto.render = function render() {
                    var _this$props2 = this.props,
                      forwardedRef = _this$props2.forwardedRef,
                      propFallback = _this$props2.fallback,
                      props =
                        (_this$props2.__chunkExtractor,
                        Object(objectWithoutPropertiesLoose.a)(_this$props2, [
                          'forwardedRef',
                          'fallback',
                          '__chunkExtractor',
                        ])),
                      _this$state = this.state,
                      error = _this$state.error,
                      loading = _this$state.loading,
                      result = _this$state.result;
                    if (options.suspense) {
                      var cachedResult = this.getCache();
                      if (!cachedResult) throw this.loadAsync();
                      return _render({
                        loading: !1,
                        fallback: null,
                        result: cachedResult,
                        options,
                        props: Object(esm_extends.a)({}, props, { ref: forwardedRef }),
                      });
                    }
                    if (error) throw error;
                    var fallback = propFallback || options.fallback || null;
                    return loading
                      ? fallback
                      : _render({
                          loading,
                          fallback,
                          result,
                          options,
                          props: Object(esm_extends.a)({}, props, { ref: forwardedRef }),
                        });
                  }),
                  InnerLoadable
                );
              })(react_default.a.Component)
            ),
            Loadable = react_default.a.forwardRef(function (props, ref) {
              return react_default.a.createElement(EnhancedInnerLoadable, Object.assign({ forwardedRef: ref }, props));
            });
          return (
            (Loadable.preload = function (props) {
              ctor.requireAsync(props);
            }),
            (Loadable.load = function (props) {
              return ctor.requireAsync(props);
            }),
            Loadable
          );
        }
        return {
          loadable,
          lazy: function lazy(ctor, options) {
            return loadable(ctor, Object(esm_extends.a)({}, options, { suspense: !0 }));
          },
        };
      }
      var _createLoadable = createLoadable({
          defaultResolveComponent: function loadable_esm_defaultResolveComponent(loadedModule) {
            return loadedModule.__esModule ? loadedModule.default : loadedModule.default || loadedModule;
          },
          render: function render(_ref) {
            var Component = _ref.result,
              props = _ref.props;
            return react_default.a.createElement(Component, props);
          },
        }),
        loadable_esm_loadable = _createLoadable.loadable,
        loadable_esm_lazy = _createLoadable.lazy,
        _createLoadable$1 = createLoadable({
          onLoad: function onLoad(result, props) {
            result &&
              props.forwardedRef &&
              ('function' == typeof props.forwardedRef
                ? props.forwardedRef(result)
                : (props.forwardedRef.current = result));
          },
          render: function render(_ref) {
            var result = _ref.result,
              loading = _ref.loading,
              props = _ref.props;
            return !loading && props.children ? props.children(result) : null;
          },
        }),
        loadable$1 = _createLoadable$1.loadable,
        lazy$1 = _createLoadable$1.lazy;
      var loadable$2 = loadable_esm_loadable;
      (loadable$2.lib = loadable$1), (loadable_esm_lazy.lib = lazy$1);
      __webpack_exports__.a = loadable$2;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var printWarning = function () {},
        ReactPropTypesSecret = __webpack_require__(45),
        loggedTypeFailures = {},
        has = Function.call.bind(Object.prototype.hasOwnProperty);
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        for (var typeSpecName in typeSpecs)
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if ('function' != typeof typeSpecs[typeSpecName]) {
                var err = Error(
                  (componentName || 'React class') +
                    ': ' +
                    location +
                    ' type `' +
                    typeSpecName +
                    '` is invalid; it must be a function, usually from the `prop-types` package, but received `' +
                    typeof typeSpecs[typeSpecName] +
                    '`.'
                );
                throw ((err.name = 'Invariant Violation'), err);
              }
              error = typeSpecs[typeSpecName](
                values,
                typeSpecName,
                componentName,
                location,
                null,
                ReactPropTypesSecret
              );
            } catch (ex) {
              error = ex;
            }
            if (
              (!error ||
                error instanceof Error ||
                printWarning(
                  (componentName || 'React class') +
                    ': type specification of ' +
                    location +
                    ' `' +
                    typeSpecName +
                    '` is invalid; the type checker function must return `null` or an `Error` but returned a ' +
                    typeof error +
                    '. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).'
                ),
              error instanceof Error && !(error.message in loggedTypeFailures))
            ) {
              loggedTypeFailures[error.message] = !0;
              var stack = getStack ? getStack() : '';
              printWarning('Failed ' + location + ' type: ' + error.message + (null != stack ? stack : ''));
            }
          }
      }
      (printWarning = function (text) {
        var message = 'Warning: ' + text;
        'undefined' != typeof console && console.error(message);
        try {
          throw new Error(message);
        } catch (x) {}
      }),
        (checkPropTypes.resetWarningCache = function () {
          loggedTypeFailures = {};
        }),
        (module.exports = checkPropTypes);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = __webpack_require__(84);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var reducer_1 = __webpack_require__(94);
      Object.defineProperty(exports, 'reducer', {
        enumerable: !0,
        get: function () {
          return reducer_1.default;
        },
      });
      var thunk_1 = __webpack_require__(95);
      Object.defineProperty(exports, 'GetEntity', {
        enumerable: !0,
        get: function () {
          return thunk_1.default;
        },
      });
      var actions_1 = __webpack_require__(36);
      Object.defineProperty(exports, 'ResetEntity', {
        enumerable: !0,
        get: function () {
          return actions_1.ResetEntity;
        },
      }),
        Object.defineProperty(exports, 'DeleteEntity', {
          enumerable: !0,
          get: function () {
            return actions_1.DeleteEntity;
          },
        });
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var __assign =
        (this && this.__assign) ||
        function () {
          return (__assign =
            Object.assign ||
            function (t) {
              for (var s, i = 1, n = arguments.length; i < n; i++)
                for (var p in (s = arguments[i])) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
              return t;
            }).apply(this, arguments);
        };
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.DeleteEntity = exports.ResetEntity = exports.fetchFailureCreator = exports.fetchSuccessCreator = exports.fetchRequestCreator = exports.makeEntityActionCreator = void 0);
      var types_1 = __webpack_require__(23),
        generateAction = function (action, keys, values) {
          var generatedAction = __assign({}, action);
          if (keys && keys.length > 0) {
            var payload_1 = {};
            keys.forEach(function (arg, index) {
              payload_1[keys[index]] = values[index];
            }),
              (generatedAction.payload = payload_1);
          }
          return generatedAction;
        };
      (exports.makeEntityActionCreator = function (type, entity) {
        for (var keys = [], _i = 2; _i < arguments.length; _i++) keys[_i - 2] = arguments[_i];
        if (!type) throw new Error('Type cannot be null/undefined');
        if (!entity) throw new Error('Entity cannot be null/undefined');
        return function () {
          for (var values = [], _i = 0; _i < arguments.length; _i++) values[_i] = arguments[_i];
          return generateAction({ type, entity }, keys, values);
        };
      }),
        (exports.fetchRequestCreator = function (entity) {
          return exports.makeEntityActionCreator(types_1.EntityActionType.Request, entity);
        }),
        (exports.fetchSuccessCreator = function (entity) {
          return exports.makeEntityActionCreator(
            types_1.EntityActionType.Success,
            entity,
            types_1.PayloadKeys.Data,
            types_1.PayloadKeys.LastUpdated,
            types_1.PayloadKeys.Append
          );
        }),
        (exports.fetchFailureCreator = function (entity) {
          return exports.makeEntityActionCreator(
            types_1.EntityActionType.Failure,
            entity,
            types_1.PayloadKeys.Error,
            types_1.PayloadKeys.LastUpdated
          );
        }),
        (exports.ResetEntity = function (entity) {
          return exports.makeEntityActionCreator(
            types_1.EntityActionType.Reset,
            entity,
            types_1.PayloadKeys.LastUpdated
          )(new Date());
        }),
        (exports.DeleteEntity = function (entity) {
          return exports.makeEntityActionCreator(types_1.EntityActionType.Delete, entity)();
        });
    },
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(17),
        isObjectLike = __webpack_require__(25);
      module.exports = function isSymbol(value) {
        return 'symbol' == typeof value || (isObjectLike(value) && '[object Symbol]' == baseGetTag(value));
      };
    },
    function (module, exports, __webpack_require__) {
      var Symbol = __webpack_require__(12).Symbol;
      module.exports = Symbol;
    },
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.TabDiv = exports.MenuLink = exports.MenuLI = exports.MenuUL = exports.MenuList = exports.TabLI = exports.TabUL = exports.TabLink = exports.TabList = exports.Flex = exports.DEFAULT_THEME = void 0);
      var _glamorous = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(59));
      function _toConsumableArray(arr) {
        return (
          (function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
              for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
              return arr2;
            }
          })(arr) ||
          (function _iterableToArray(iter) {
            if (Symbol.iterator in Object(iter) || '[object Arguments]' === Object.prototype.toString.call(iter))
              return Array.from(iter);
          })(arr) ||
          (function _nonIterableSpread() {
            throw new TypeError('Invalid attempt to spread non-iterable instance');
          })()
        );
      }
      var COLOR_LINK = '#3273dc',
        COLOR_GREY_DARK = '#4a4a4a',
        COLOR_GREY_DARKER = '#363636',
        COLOR_GREY_LIGHTER = '#dbdbdb',
        DEFAULT_THEME = {
          tabs: {
            color: COLOR_GREY_DARK,
            borderBottomColor: COLOR_GREY_LIGHTER,
            active: { borderBottomColor: COLOR_LINK, color: COLOR_LINK },
            hover: { borderBottomColor: COLOR_GREY_DARKER, color: COLOR_GREY_DARKER },
          },
          menu: {
            color: COLOR_GREY_DARK,
            borderRight: COLOR_GREY_LIGHTER,
            active: { backgroundColor: COLOR_LINK, color: '#FFFFFF' },
            hover: { color: COLOR_GREY_DARKER, backgroundColor: 'whitesmoke' },
          },
        };
      exports.DEFAULT_THEME = DEFAULT_THEME;
      var ALLOWED_FLEX_PROPS = [
          'alignItems',
          'background',
          'backgroundColor',
          'border',
          'borderRadius',
          'boxShadow',
          'color',
          'cursor',
          'flex',
          'flexGrow',
          'flexShrink',
          'flexWrap',
          'fontSize',
          'height',
          'justifyContent',
          'margin',
          'maxHeight',
          'maxWidth',
          'minHeight',
          'minWidth',
          'overflow',
          'overflowX',
          'overflowY',
          'padding',
          'width',
        ],
        __getExplicitFlexStyles = function __getExplicitFlexStyles(props, propKeys) {
          if (!propKeys) throw new Error('Missing required propKeys');
          if (!Array.isArray(propKeys)) throw new Error('propKeys must be an Array');
          return propKeys
            .map(function (prop) {
              return null !== props[prop] && void 0 !== props[prop]
                ? (function _defineProperty(obj, key, value) {
                    return (
                      key in obj
                        ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 })
                        : (obj[key] = value),
                      obj
                    );
                  })({}, prop, props[prop])
                : null;
            })
            .filter(function (rule) {
              return rule;
            });
        },
        Flex = _glamorous.default.div({ display: 'flex' }, function (props) {
          return [].concat(
            _toConsumableArray(
              (function __getImplicitFlexProps(props) {
                var implicit = [];
                return (
                  props.column && implicit.push({ flexDirection: 'column ' }),
                  props.hAlignCenter &&
                    implicit.push(props.column ? { alignItems: 'center' } : { justifyContent: 'center' }),
                  props.vAlignCenter &&
                    implicit.push(props.column ? { justifyContent: 'center' } : { alignItems: 'center' }),
                  implicit
                );
              })(props)
            ),
            _toConsumableArray(__getExplicitFlexStyles(props, ALLOWED_FLEX_PROPS))
          );
        });
      exports.Flex = Flex;
      var TabList = _glamorous.default.div({
        userSelect: 'none',
        alignItems: 'stretch',
        display: 'flex',
        fontSize: '1rem',
        justifyContent: 'space-between',
        overflow: 'hidden',
        overflowX: 'auto',
        whiteSpace: 'nowrap',
        WebkitOverflowScrolling: 'touch',
      });
      exports.TabList = TabList;
      var TabLink = _glamorous.default.a(
        {
          cursor: 'pointer',
          alignItems: 'center',
          borderBottomStyle: 'solid',
          borderBottomWidth: '1px',
          display: 'flex',
          justifyContent: 'center',
          marginBottom: '-1px',
          padding: '0.5em 1em',
          verticalAlign: 'top',
        },
        function (_ref2) {
          var isActive = _ref2.isActive,
            theme = _ref2.theme,
            styles = [{ color: theme.tabs.color, borderBottomColor: theme.tabs.borderBottomColor }];
          if (isActive) {
            var active = theme.tabs.active;
            styles.push({ color: active.color, borderBottomColor: active.borderBottomColor, ':hover': active });
          } else styles.push({ ':hover': theme.tabs.hover });
          return styles;
        }
      );
      exports.TabLink = TabLink;
      var TabUL = _glamorous.default.ul(
        {
          margin: 0,
          padding: 0,
          listStyle: 'none',
          alignItems: 'center',
          borderBottomStyle: 'solid',
          borderBottomWidth: '1px',
          display: 'flex',
          flexGrow: 1,
          flexShrink: 0,
          justifyContent: 'flex-start',
        },
        function (_ref3) {
          return [{ borderBottomColor: _ref3.theme.tabs.borderBottomColor }];
        }
      );
      exports.TabUL = TabUL;
      var TabLI = _glamorous.default.li({ display: 'block' });
      exports.TabLI = TabLI;
      var MenuList = _glamorous.default.div({ fontSize: '1rem', overflowY: 'auto' }, function (_ref4) {
        var theme = _ref4.theme;
        return [{ borderRight: '1px solid '.concat(theme.menu.borderRight) }];
      });
      exports.MenuList = MenuList;
      var MenuUL = _glamorous.default.ul({ margin: 0, padding: 0, listStyle: 'none', lineHeight: 1.25 });
      exports.MenuUL = MenuUL;
      var MenuLI = _glamorous.default.li({});
      exports.MenuLI = MenuLI;
      var MenuLink = _glamorous.default.a({ cursor: 'pointer', display: 'block', padding: '0.5em 0.75em' }, function (
        _ref5
      ) {
        var isActive = _ref5.isActive,
          theme = _ref5.theme,
          styles = [{ color: theme.menu.color }];
        if (isActive) {
          var active = theme.menu.active;
          styles.push({ color: active.color, backgroundColor: active.backgroundColor, ':hover': active });
        } else styles.push({ ':hover': theme.menu.hover });
        return styles;
      });
      exports.MenuLink = MenuLink;
      var TabDiv = _glamorous.default.div({ height: '100%', width: '100%', overflow: 'auto' });
      exports.TabDiv = TabDiv;
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      (function (global, module) {
        var root,
          _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76);
        root =
          'undefined' != typeof self
            ? self
            : 'undefined' != typeof window
            ? window
            : void 0 !== global
            ? global
            : module;
        var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.a)(root);
        __webpack_exports__.a = result;
      }.call(this, __webpack_require__(22), __webpack_require__(92)(module)));
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      (function (global) {
        var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0),
          react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__),
          _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7),
          prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1),
          prop_types__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(
            prop_types__WEBPACK_IMPORTED_MODULE_2__
          ),
          tiny_warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3),
          commonjsGlobal =
            'undefined' != typeof globalThis
              ? globalThis
              : 'undefined' != typeof window
              ? window
              : void 0 !== global
              ? global
              : {};
        function createEventEmitter(value) {
          var handlers = [];
          return {
            on: function on(handler) {
              handlers.push(handler);
            },
            off: function off(handler) {
              handlers = handlers.filter(function (h) {
                return h !== handler;
              });
            },
            get: function get() {
              return value;
            },
            set: function set(newValue, changedBits) {
              (value = newValue),
                handlers.forEach(function (handler) {
                  return handler(value, changedBits);
                });
            },
          };
        }
        var index =
          react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext ||
          function createReactContext(defaultValue, calculateChangedBits) {
            var _Provider$childContex,
              _Consumer$contextType,
              contextProp =
                '__create-react-context-' +
                (function getUniqueId() {
                  var key = '__global_unique_id__';
                  return (commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1);
                })() +
                '__',
              Provider = (function (_Component) {
                function Provider() {
                  var _this;
                  return (
                    ((_this = _Component.apply(this, arguments) || this).emitter = createEventEmitter(
                      _this.props.value
                    )),
                    _this
                  );
                }
                Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__.a)(Provider, _Component);
                var _proto = Provider.prototype;
                return (
                  (_proto.getChildContext = function getChildContext() {
                    var _ref;
                    return ((_ref = {})[contextProp] = this.emitter), _ref;
                  }),
                  (_proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
                    if (this.props.value !== nextProps.value) {
                      var changedBits,
                        oldValue = this.props.value,
                        newValue = nextProps.value;
                      !(function objectIs(x, y) {
                        return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y;
                      })(oldValue, newValue)
                        ? ((changedBits =
                            'function' == typeof calculateChangedBits
                              ? calculateChangedBits(oldValue, newValue)
                              : 1073741823),
                          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__.a)(
                            (1073741823 & changedBits) === changedBits,
                            'calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: ' +
                              changedBits
                          ),
                          0 !== (changedBits |= 0) && this.emitter.set(nextProps.value, changedBits))
                        : (changedBits = 0);
                    }
                  }),
                  (_proto.render = function render() {
                    return this.props.children;
                  }),
                  Provider
                );
              })(react__WEBPACK_IMPORTED_MODULE_0__.Component);
            Provider.childContextTypes =
              (((_Provider$childContex = {})[contextProp] =
                prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired),
              _Provider$childContex);
            var Consumer = (function (_Component2) {
              function Consumer() {
                var _this2;
                return (
                  ((_this2 = _Component2.apply(this, arguments) || this).state = { value: _this2.getValue() }),
                  (_this2.onUpdate = function (newValue, changedBits) {
                    0 != ((0 | _this2.observedBits) & changedBits) && _this2.setState({ value: _this2.getValue() });
                  }),
                  _this2
                );
              }
              Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__.a)(Consumer, _Component2);
              var _proto2 = Consumer.prototype;
              return (
                (_proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
                  var observedBits = nextProps.observedBits;
                  this.observedBits = null == observedBits ? 1073741823 : observedBits;
                }),
                (_proto2.componentDidMount = function componentDidMount() {
                  this.context[contextProp] && this.context[contextProp].on(this.onUpdate);
                  var observedBits = this.props.observedBits;
                  this.observedBits = null == observedBits ? 1073741823 : observedBits;
                }),
                (_proto2.componentWillUnmount = function componentWillUnmount() {
                  this.context[contextProp] && this.context[contextProp].off(this.onUpdate);
                }),
                (_proto2.getValue = function getValue() {
                  return this.context[contextProp] ? this.context[contextProp].get() : defaultValue;
                }),
                (_proto2.render = function render() {
                  return (function onlyChild(children) {
                    return Array.isArray(children) ? children[0] : children;
                  })(this.props.children)(this.state.value);
                }),
                Consumer
              );
            })(react__WEBPACK_IMPORTED_MODULE_0__.Component);
            return (
              (Consumer.contextTypes =
                (((_Consumer$contextType = {})[contextProp] = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object),
                _Consumer$contextType)),
              { Provider, Consumer }
            );
          };
        __webpack_exports__.a = index;
      }.call(this, __webpack_require__(22)));
    },
    function (module, exports, __webpack_require__) {
      var isarray = __webpack_require__(102);
      (module.exports = pathToRegexp),
        (module.exports.parse = parse),
        (module.exports.compile = function compile(str, options) {
          return tokensToFunction(parse(str, options), options);
        }),
        (module.exports.tokensToFunction = tokensToFunction),
        (module.exports.tokensToRegExp = tokensToRegExp);
      var PATH_REGEXP = new RegExp(
        [
          '(\\\\.)',
          '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))',
        ].join('|'),
        'g'
      );
      function parse(str, options) {
        for (
          var res, tokens = [], key = 0, index = 0, path = '', defaultDelimiter = (options && options.delimiter) || '/';
          null != (res = PATH_REGEXP.exec(str));

        ) {
          var m = res[0],
            escaped = res[1],
            offset = res.index;
          if (((path += str.slice(index, offset)), (index = offset + m.length), escaped)) path += escaped[1];
          else {
            var next = str[index],
              prefix = res[2],
              name = res[3],
              capture = res[4],
              group = res[5],
              modifier = res[6],
              asterisk = res[7];
            path && (tokens.push(path), (path = ''));
            var partial = null != prefix && null != next && next !== prefix,
              repeat = '+' === modifier || '*' === modifier,
              optional = '?' === modifier || '*' === modifier,
              delimiter = res[2] || defaultDelimiter,
              pattern = capture || group;
            tokens.push({
              name: name || key++,
              prefix: prefix || '',
              delimiter,
              optional,
              repeat,
              partial,
              asterisk: !!asterisk,
              pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?',
            });
          }
        }
        return index < str.length && (path += str.substr(index)), path && tokens.push(path), tokens;
      }
      function encodeURIComponentPretty(str) {
        return encodeURI(str).replace(/[\/?#]/g, function (c) {
          return '%' + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function tokensToFunction(tokens, options) {
        for (var matches = new Array(tokens.length), i = 0; i < tokens.length; i++)
          'object' == typeof tokens[i] && (matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options)));
        return function (obj, opts) {
          for (
            var path = '',
              data = obj || {},
              encode = (opts || {}).pretty ? encodeURIComponentPretty : encodeURIComponent,
              i = 0;
            i < tokens.length;
            i++
          ) {
            var token = tokens[i];
            if ('string' != typeof token) {
              var segment,
                value = data[token.name];
              if (null == value) {
                if (token.optional) {
                  token.partial && (path += token.prefix);
                  continue;
                }
                throw new TypeError('Expected "' + token.name + '" to be defined');
              }
              if (isarray(value)) {
                if (!token.repeat)
                  throw new TypeError(
                    'Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`'
                  );
                if (0 === value.length) {
                  if (token.optional) continue;
                  throw new TypeError('Expected "' + token.name + '" to not be empty');
                }
                for (var j = 0; j < value.length; j++) {
                  if (((segment = encode(value[j])), !matches[i].test(segment)))
                    throw new TypeError(
                      'Expected all "' +
                        token.name +
                        '" to match "' +
                        token.pattern +
                        '", but received `' +
                        JSON.stringify(segment) +
                        '`'
                    );
                  path += (0 === j ? token.prefix : token.delimiter) + segment;
                }
              } else {
                if (
                  ((segment = token.asterisk
                    ? encodeURI(value).replace(/[?#]/g, function (c) {
                        return '%' + c.charCodeAt(0).toString(16).toUpperCase();
                      })
                    : encode(value)),
                  !matches[i].test(segment))
                )
                  throw new TypeError(
                    'Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"'
                  );
                path += token.prefix + segment;
              }
            } else path += token;
          }
          return path;
        };
      }
      function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
      }
      function escapeGroup(group) {
        return group.replace(/([=!:$\/()])/g, '\\$1');
      }
      function attachKeys(re, keys) {
        return (re.keys = keys), re;
      }
      function flags(options) {
        return options && options.sensitive ? '' : 'i';
      }
      function tokensToRegExp(tokens, keys, options) {
        isarray(keys) || ((options = keys || options), (keys = []));
        for (
          var strict = (options = options || {}).strict, end = !1 !== options.end, route = '', i = 0;
          i < tokens.length;
          i++
        ) {
          var token = tokens[i];
          if ('string' == typeof token) route += escapeString(token);
          else {
            var prefix = escapeString(token.prefix),
              capture = '(?:' + token.pattern + ')';
            keys.push(token),
              token.repeat && (capture += '(?:' + prefix + capture + ')*'),
              (route += capture = token.optional
                ? token.partial
                  ? prefix + '(' + capture + ')?'
                  : '(?:' + prefix + '(' + capture + '))?'
                : prefix + '(' + capture + ')');
          }
        }
        var delimiter = escapeString(options.delimiter || '/'),
          endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
        return (
          strict ||
            (route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'),
          (route += end ? '$' : strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'),
          attachKeys(new RegExp('^' + route, flags(options)), keys)
        );
      }
      function pathToRegexp(path, keys, options) {
        return (
          isarray(keys) || ((options = keys || options), (keys = [])),
          (options = options || {}),
          path instanceof RegExp
            ? (function regexpToRegexp(path, keys) {
                var groups = path.source.match(/\((?!\?)/g);
                if (groups)
                  for (var i = 0; i < groups.length; i++)
                    keys.push({
                      name: i,
                      prefix: null,
                      delimiter: null,
                      optional: !1,
                      repeat: !1,
                      partial: !1,
                      asterisk: !1,
                      pattern: null,
                    });
                return attachKeys(path, keys);
              })(path, keys)
            : isarray(path)
            ? (function arrayToRegexp(path, keys, options) {
                for (var parts = [], i = 0; i < path.length; i++)
                  parts.push(pathToRegexp(path[i], keys, options).source);
                return attachKeys(new RegExp('(?:' + parts.join('|') + ')', flags(options)), keys);
              })(path, keys, options)
            : (function stringToRegexp(path, keys, options) {
                return tokensToRegExp(parse(path, options), keys, options);
              })(path, keys, options)
        );
      }
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.compose = exports.merge = exports.$ = exports.style = exports.presets = exports.keyframes = exports.fontFace = exports.insertGlobal = exports.insertRule = exports.plugins = exports.styleSheet = void 0),
        (exports.speedy = function speedy(bool) {
          return styleSheet.speedy(bool);
        }),
        (exports.simulations = function simulations() {
          var bool = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          canSimulate = !!bool;
        }),
        (exports.simulate = function simulate() {
          for (var _len = arguments.length, pseudos = Array(_len), _key = 0; _key < _len; _key++)
            pseudos[_key] = arguments[_key];
          if (!(pseudos = (0, _clean2.default)(pseudos))) return {};
          if (!canSimulate)
            return (
              warned1 || (console.warn("can't simulate without once calling simulations(true)"), (warned1 = !0)),
              warned2 || (console.warn("don't use simulation outside dev"), (warned2 = !0)),
              {}
            );
          return pseudos.reduce(function (o, p) {
            return (o['data-simulate-' + simple(p)] = ''), o;
          }, {});
        }),
        (exports.cssLabels = function cssLabels(bool) {
          hasLabels = !!bool;
        }),
        (exports.isLikeRule = isLikeRule),
        (exports.idFor = idFor),
        (exports.css = css),
        (exports.rehydrate = function rehydrate(ids) {
          (0, _objectAssign2.default)(
            inserted,
            ids.reduce(function (o, i) {
              return (o[i] = !0), o;
            }, {})
          );
        }),
        (exports.flush = function flush() {
          (inserted = styleSheet.inserted = {}),
            (registered = styleSheet.registered = {}),
            (ruleCache = {}),
            styleSheet.flush(),
            styleSheet.inject();
        }),
        (exports.select = select),
        (exports.parent = function parent(selector) {
          for (
            var _len4 = arguments.length, styles = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1;
            _key4 < _len4;
            _key4++
          )
            styles[_key4 - 1] = arguments[_key4];
          return css(_defineProperty({}, selector + ' &', styles));
        }),
        (exports.media = function media(query) {
          for (
            var _len5 = arguments.length, rules = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1;
            _key5 < _len5;
            _key5++
          )
            rules[_key5 - 1] = arguments[_key5];
          return css(_defineProperty({}, '@media ' + query, rules));
        }),
        (exports.pseudo = pseudo),
        (exports.active = function active(x) {
          return pseudo(':active', x);
        }),
        (exports.any = function any(x) {
          return pseudo(':any', x);
        }),
        (exports.checked = function checked(x) {
          return pseudo(':checked', x);
        }),
        (exports.disabled = function disabled(x) {
          return pseudo(':disabled', x);
        }),
        (exports.empty = function empty(x) {
          return pseudo(':empty', x);
        }),
        (exports.enabled = function enabled(x) {
          return pseudo(':enabled', x);
        }),
        (exports._default = function _default(x) {
          return pseudo(':default', x);
        }),
        (exports.first = function first(x) {
          return pseudo(':first', x);
        }),
        (exports.firstChild = function firstChild(x) {
          return pseudo(':first-child', x);
        }),
        (exports.firstOfType = function firstOfType(x) {
          return pseudo(':first-of-type', x);
        }),
        (exports.fullscreen = function fullscreen(x) {
          return pseudo(':fullscreen', x);
        }),
        (exports.focus = function focus(x) {
          return pseudo(':focus', x);
        }),
        (exports.hover = function hover(x) {
          return pseudo(':hover', x);
        }),
        (exports.indeterminate = function indeterminate(x) {
          return pseudo(':indeterminate', x);
        }),
        (exports.inRange = function inRange(x) {
          return pseudo(':in-range', x);
        }),
        (exports.invalid = function invalid(x) {
          return pseudo(':invalid', x);
        }),
        (exports.lastChild = function lastChild(x) {
          return pseudo(':last-child', x);
        }),
        (exports.lastOfType = function lastOfType(x) {
          return pseudo(':last-of-type', x);
        }),
        (exports.left = function left(x) {
          return pseudo(':left', x);
        }),
        (exports.link = function link(x) {
          return pseudo(':link', x);
        }),
        (exports.onlyChild = function onlyChild(x) {
          return pseudo(':only-child', x);
        }),
        (exports.onlyOfType = function onlyOfType(x) {
          return pseudo(':only-of-type', x);
        }),
        (exports.optional = function optional(x) {
          return pseudo(':optional', x);
        }),
        (exports.outOfRange = function outOfRange(x) {
          return pseudo(':out-of-range', x);
        }),
        (exports.readOnly = function readOnly(x) {
          return pseudo(':read-only', x);
        }),
        (exports.readWrite = function readWrite(x) {
          return pseudo(':read-write', x);
        }),
        (exports.required = function required(x) {
          return pseudo(':required', x);
        }),
        (exports.right = function right(x) {
          return pseudo(':right', x);
        }),
        (exports.root = function root(x) {
          return pseudo(':root', x);
        }),
        (exports.scope = function scope(x) {
          return pseudo(':scope', x);
        }),
        (exports.target = function target(x) {
          return pseudo(':target', x);
        }),
        (exports.valid = function valid(x) {
          return pseudo(':valid', x);
        }),
        (exports.visited = function visited(x) {
          return pseudo(':visited', x);
        }),
        (exports.dir = function dir(p, x) {
          return pseudo(':dir(' + p + ')', x);
        }),
        (exports.lang = function lang(p, x) {
          return pseudo(':lang(' + p + ')', x);
        }),
        (exports.not = function not(p, x) {
          var selector = p
            .split(',')
            .map(function (x) {
              return x.trim();
            })
            .map(function (x) {
              return ':not(' + x + ')';
            });
          if (1 === selector.length) return pseudo(':not(' + p + ')', x);
          return select(selector.join(''), x);
        }),
        (exports.nthChild = function nthChild(p, x) {
          return pseudo(':nth-child(' + p + ')', x);
        }),
        (exports.nthLastChild = function nthLastChild(p, x) {
          return pseudo(':nth-last-child(' + p + ')', x);
        }),
        (exports.nthLastOfType = function nthLastOfType(p, x) {
          return pseudo(':nth-last-of-type(' + p + ')', x);
        }),
        (exports.nthOfType = function nthOfType(p, x) {
          return pseudo(':nth-of-type(' + p + ')', x);
        }),
        (exports.after = function after(x) {
          return pseudo('::after', x);
        }),
        (exports.before = function before(x) {
          return pseudo('::before', x);
        }),
        (exports.firstLetter = function firstLetter(x) {
          return pseudo('::first-letter', x);
        }),
        (exports.firstLine = function firstLine(x) {
          return pseudo('::first-line', x);
        }),
        (exports.selection = function selection(x) {
          return pseudo('::selection', x);
        }),
        (exports.backdrop = function backdrop(x) {
          return pseudo('::backdrop', x);
        }),
        (exports.placeholder = function placeholder(x) {
          return css({ '::placeholder': x });
        }),
        (exports.cssFor = function cssFor() {
          for (var _len7 = arguments.length, rules = Array(_len7), _key7 = 0; _key7 < _len7; _key7++)
            rules[_key7] = arguments[_key7];
          return (rules = (0, _clean2.default)(rules))
            ? rules
                .map(function (r) {
                  var style = { label: [] };
                  return build(style, { src: r }), deconstructedStyleToCSS(hashify(style), deconstruct(style)).join('');
                })
                .join('')
            : '';
        }),
        (exports.attribsFor = function attribsFor() {
          for (var _len8 = arguments.length, rules = Array(_len8), _key8 = 0; _key8 < _len8; _key8++)
            rules[_key8] = arguments[_key8];
          var htmlAttributes = (rules = (0, _clean2.default)(rules))
            ? rules
                .map(function (rule) {
                  idFor(rule);
                  var key = Object.keys(rule)[0];
                  return key + '="' + (rule[key] || '') + '"';
                })
                .join(' ')
            : '';
          return htmlAttributes;
        });
      var _objectAssign2 = _interopRequireDefault(__webpack_require__(15)),
        _sheet = __webpack_require__(160),
        _CSSPropertyOperations = __webpack_require__(60),
        _clean2 = _interopRequireDefault(__webpack_require__(169)),
        _plugins = __webpack_require__(170),
        _hash2 = _interopRequireDefault(__webpack_require__(187));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _defineProperty(obj, key, value) {
        return (
          key in obj
            ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 })
            : (obj[key] = value),
          obj
        );
      }
      var styleSheet = (exports.styleSheet = new _sheet.StyleSheet());
      styleSheet.inject();
      var plugins = (exports.plugins = styleSheet.plugins = new _plugins.PluginSet([
        _plugins.prefixes,
        _plugins.contentWrap,
        _plugins.fallbacks,
      ]));
      (plugins.media = new _plugins.PluginSet()),
        (plugins.fontFace = new _plugins.PluginSet()),
        (plugins.keyframes = new _plugins.PluginSet([_plugins.prefixes, _plugins.fallbacks]));
      var isBrowser = 'undefined' != typeof window,
        canSimulate = !1,
        warned1 = !1,
        warned2 = !1;
      var hasLabels = !1;
      function simple(str) {
        var char = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '';
        return str.toLowerCase().replace(/[^a-z0-9]/g, char);
      }
      function hashify(obj) {
        var str = JSON.stringify(obj),
          toRet = (0, _hash2.default)(str).toString(36);
        return obj.label && obj.label.length, toRet;
      }
      function isLikeRule(rule) {
        var keys = Object.keys(rule).filter(function (x) {
          return 'toString' !== x;
        });
        return 1 === keys.length && !!/data\-css\-([a-zA-Z0-9\-_]+)/.exec(keys[0]);
      }
      function idFor(rule) {
        var keys = Object.keys(rule).filter(function (x) {
          return 'toString' !== x;
        });
        if (1 !== keys.length) throw new Error('not a rule');
        var match = /data\-css\-([a-zA-Z0-9\-_]+)/.exec(keys[0]);
        if (!match) throw new Error('not a rule');
        return match[1];
      }
      var selectorTokenizer = /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g;
      function splitSelector(selector) {
        if (-1 === selector.indexOf(',')) return [selector];
        for (var o, indices = [], res = [], inParen = 0; (o = selectorTokenizer.exec(selector)); )
          switch (o[0]) {
            case '(':
              inParen++;
              break;
            case ')':
              inParen--;
              break;
            case ',':
              if (inParen) break;
              indices.push(o.index);
          }
        for (o = indices.length; o--; )
          res.unshift(selector.slice(indices[o] + 1)), (selector = selector.slice(0, indices[o]));
        return res.unshift(selector), res;
      }
      function selector(id, path) {
        if (!id) return path.replace(/\&/g, '');
        if (!path) return '.css-' + id + ',[data-css-' + id + ']';
        var x = splitSelector(path)
          .map(function (x) {
            return x.indexOf('&') >= 0
              ? [x.replace(/\&/gm, '.css-' + id), x.replace(/\&/gm, '[data-css-' + id + ']')].join(',')
              : '.css-' + id + x + ',[data-css-' + id + ']' + x;
          })
          .join(',');
        return (
          canSimulate &&
            /^\&\:/.exec(path) &&
            !/\s/.exec(path) &&
            (x +=
              ',.css-' +
              id +
              '[data-simulate-' +
              simple(path) +
              '],[data-css-' +
              id +
              '][data-simulate-' +
              simple(path) +
              ']'),
          x
        );
      }
      function toCSS(_ref) {
        var selector = _ref.selector,
          style = _ref.style,
          result = plugins.transform({ selector, style });
        return result.selector + '{' + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + '}';
      }
      function deconstruct(style) {
        var plain = void 0,
          selects = void 0,
          medias = void 0,
          supports = void 0;
        return (
          Object.keys(style).forEach(function (key) {
            key.indexOf('&') >= 0
              ? ((selects = selects || {})[key] = style[key])
              : 0 === key.indexOf('@media')
              ? ((medias = medias || {})[key] = deconstruct(style[key]))
              : 0 === key.indexOf('@supports')
              ? ((supports = supports || {})[key] = deconstruct(style[key]))
              : 'label' === key
              ? style.label.length > 0 && ((plain = plain || {}).label = hasLabels ? style.label.join('.') : '')
              : ((plain = plain || {})[key] = style[key]);
          }),
          { plain, selects, medias, supports }
        );
      }
      function deconstructedStyleToCSS(id, style) {
        var css = [],
          plain = style.plain,
          selects = style.selects,
          medias = style.medias,
          supports = style.supports;
        return (
          plain && css.push(toCSS({ style: plain, selector: selector(id) })),
          selects &&
            Object.keys(selects).forEach(function (key) {
              return css.push(toCSS({ style: selects[key], selector: selector(id, key) }));
            }),
          medias &&
            Object.keys(medias).forEach(function (key) {
              return css.push(key + '{' + deconstructedStyleToCSS(id, medias[key]).join('') + '}');
            }),
          supports &&
            Object.keys(supports).forEach(function (key) {
              return css.push(key + '{' + deconstructedStyleToCSS(id, supports[key]).join('') + '}');
            }),
          css
        );
      }
      var inserted = (styleSheet.inserted = {});
      var registered = (styleSheet.registered = {});
      function register(spec) {
        registered[spec.id] || (registered[spec.id] = spec);
      }
      var ruleCache = {};
      function toRule(spec) {
        if (
          (register(spec),
          (function insert(spec) {
            if (!inserted[spec.id]) {
              inserted[spec.id] = !0;
              var deconstructed = deconstruct(spec.style),
                rules = deconstructedStyleToCSS(spec.id, deconstructed);
              (inserted[spec.id] = !!isBrowser || rules),
                rules.forEach(function (cssRule) {
                  return styleSheet.insert(cssRule);
                });
            }
          })(spec),
          ruleCache[spec.id])
        )
          return ruleCache[spec.id];
        var ret = _defineProperty({}, 'data-css-' + spec.id, (hasLabels && spec.label) || '');
        return (
          Object.defineProperty(ret, 'toString', {
            enumerable: !1,
            value: function value() {
              return 'css-' + spec.id;
            },
          }),
          (ruleCache[spec.id] = ret),
          ret
        );
      }
      function joinSelectors(a, b) {
        var as = splitSelector(a).map(function (a) {
          return a.indexOf('&') >= 0 ? a : '&' + a;
        });
        return splitSelector(b)
          .map(function (b) {
            return b.indexOf('&') >= 0 ? b : '&' + b;
          })
          .reduce(function (arr, b) {
            return arr.concat(
              as.map(function (a) {
                return b.replace(/\&/g, a);
              })
            );
          }, [])
          .join(',');
      }
      function joinSupports(a, b) {
        return a ? '@supports ' + a.substring(9) + ' and ' + b.substring(9) : b;
      }
      var prefixedPseudoSelectors = {
        '::placeholder': ['::-webkit-input-placeholder', '::-moz-placeholder', '::-ms-input-placeholder'],
        ':fullscreen': [':-webkit-full-screen', ':-moz-full-screen', ':-ms-fullscreen'],
      };
      function build(dest, _ref2) {
        var _ref2$selector = _ref2.selector,
          selector = void 0 === _ref2$selector ? '' : _ref2$selector,
          _ref2$mq = _ref2.mq,
          mq = void 0 === _ref2$mq ? '' : _ref2$mq,
          _ref2$supp = _ref2.supp,
          supp = void 0 === _ref2$supp ? '' : _ref2$supp,
          _ref2$src = _ref2.src,
          src = void 0 === _ref2$src ? {} : _ref2$src;
        Array.isArray(src) || (src = [src]),
          (src = (function flatten(inArr) {
            for (var arr = [], i = 0; i < inArr.length; i++)
              arr = Array.isArray(inArr[i]) ? arr.concat(flatten(inArr[i])) : arr.concat(inArr[i]);
            return arr;
          })(src)).forEach(function (_src) {
            if (isLikeRule(_src)) {
              var reg = (function _getRegistered(rule) {
                if (isLikeRule(rule)) {
                  var ret = registered[idFor(rule)];
                  if (null == ret)
                    throw new Error(
                      '[glamor] an unexpected rule cache miss occurred. This is probably a sign of multiple glamor instances in your app. See https://github.com/threepointone/glamor/issues/79'
                    );
                  return ret;
                }
                return rule;
              })(_src);
              if ('css' !== reg.type) throw new Error('cannot merge this rule');
              _src = reg.style;
            }
            (_src = (0, _clean2.default)(_src)) &&
              _src.composes &&
              build(dest, { selector, mq, supp, src: _src.composes }),
              Object.keys(_src || {}).forEach(function (key) {
                if (
                  (function isSelector(key) {
                    for (
                      var possibles = [':', '.', '[', '>', ' '], found = !1, ch = key.charAt(0), i = 0;
                      i < possibles.length;
                      i++
                    )
                      if (ch === possibles[i]) {
                        found = !0;
                        break;
                      }
                    return found || key.indexOf('&') >= 0;
                  })(key)
                )
                  prefixedPseudoSelectors[key] &&
                    prefixedPseudoSelectors[key].forEach(function (p) {
                      return build(dest, { selector: joinSelectors(selector, p), mq, supp, src: _src[key] });
                    }),
                    build(dest, { selector: joinSelectors(selector, key), mq, supp, src: _src[key] });
                else if (
                  (function isMediaQuery(key) {
                    return 0 === key.indexOf('@media');
                  })(key)
                )
                  build(dest, {
                    selector,
                    mq: ((a = mq), (b = key), a ? '@media ' + a.substring(6) + ' and ' + b.substring(6) : b),
                    supp,
                    src: _src[key],
                  });
                else if (
                  (function isSupports(key) {
                    return 0 === key.indexOf('@supports');
                  })(key)
                )
                  build(dest, { selector, mq, supp: joinSupports(supp, key), src: _src[key] });
                else if ('composes' === key);
                else {
                  var _dest = dest;
                  supp && ((_dest[supp] = _dest[supp] || {}), (_dest = _dest[supp])),
                    mq && ((_dest[mq] = _dest[mq] || {}), (_dest = _dest[mq])),
                    selector && ((_dest[selector] = _dest[selector] || {}), (_dest = _dest[selector])),
                    'label' === key
                      ? hasLabels && (dest.label = dest.label.concat(_src.label))
                      : (_dest[key] = _src[key]);
                }
                var a, b;
              });
          });
      }
      function _css(rules) {
        var style = { label: [] };
        return (
          build(style, { src: rules }),
          toRule({ id: hashify(style), style, label: hasLabels ? style.label.join('.') : '', type: 'css' })
        );
      }
      var nullrule = {};
      Object.defineProperty(nullrule, 'toString', {
        enumerable: !1,
        value: function value() {
          return 'css-nil';
        },
      });
      var inputCaches =
        'undefined' != typeof WeakMap ? [nullrule, new WeakMap(), new WeakMap(), new WeakMap()] : [nullrule];
      var cachedCss =
        'undefined' != typeof WeakMap
          ? (function multiIndexCache(fn) {
              return function (args) {
                if (inputCaches[args.length]) {
                  for (var coi = inputCaches[args.length], ctr = 0; ctr < args.length - 1; )
                    coi.has(args[ctr]) || coi.set(args[ctr], new WeakMap()), (coi = coi.get(args[ctr])), ctr++;
                  if (coi.has(args[args.length - 1])) {
                    var ret = coi.get(args[ctr]);
                    if (registered[ret.toString().substring(4)]) return ret;
                  }
                }
                var value = fn(args);
                if (inputCaches[args.length]) {
                  for (var _ctr = 0, _coi = inputCaches[args.length]; _ctr < args.length - 1; )
                    (_coi = _coi.get(args[_ctr])), _ctr++;
                  try {
                    _coi.set(args[_ctr], value);
                  } catch (err) {}
                }
                return value;
              };
            })(_css)
          : _css;
      function css() {
        for (var _len2 = arguments.length, rules = Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
          rules[_key2] = arguments[_key2];
        if (rules[0] && rules[0].length && rules[0].raw)
          throw new Error('you forgot to include glamor/babel in your babel plugins.');
        return (rules = (0, _clean2.default)(rules)) ? cachedCss(rules) : nullrule;
      }
      css.insert = function (css) {
        var spec = { id: hashify(css), css, type: 'raw' };
        register(spec),
          inserted[spec.id] || (styleSheet.insert(spec.css), (inserted[spec.id] = !!isBrowser || [spec.css]));
      };
      exports.insertRule = css.insert;
      css.global = function (selector, style) {
        if ((style = (0, _clean2.default)(style))) return css.insert(toCSS({ selector, style }));
      };
      exports.insertGlobal = css.global;
      (css.keyframes = function (name, kfs) {
        kfs || ((kfs = name), (name = 'animation'));
        var spec = {
          id: hashify({ name, kfs: (kfs = (0, _clean2.default)(kfs) || {}) }),
          type: 'keyframes',
          name,
          keyframes: kfs,
        };
        return (
          register(spec),
          (function insertKeyframe(spec) {
            if (!inserted[spec.id]) {
              var inner = Object.keys(spec.keyframes)
                  .map(function (kf) {
                    var result = plugins.keyframes.transform({ id: spec.id, name: kf, style: spec.keyframes[kf] });
                    return result.name + '{' + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + '}';
                  })
                  .join(''),
                rules = ['-webkit-', '-moz-', '-o-', ''].map(function (prefix) {
                  return '@' + prefix + 'keyframes ' + spec.name + '_' + spec.id + '{' + inner + '}';
                });
              rules.forEach(function (rule) {
                return styleSheet.insert(rule);
              }),
                (inserted[spec.id] = !!isBrowser || rules);
            }
          })(spec),
          name + '_' + spec.id
        );
      }),
        (css.fontFace = function (font) {
          var spec = { id: hashify((font = (0, _clean2.default)(font))), type: 'font-face', font };
          return (
            register(spec),
            (function insertFontFace(spec) {
              if (!inserted[spec.id]) {
                var rule = '@font-face{' + (0, _CSSPropertyOperations.createMarkupForStyles)(spec.font) + '}';
                styleSheet.insert(rule), (inserted[spec.id] = !!isBrowser || [rule]);
              }
            })(spec),
            font.fontFamily
          );
        });
      (exports.fontFace = css.fontFace), (exports.keyframes = css.keyframes);
      exports.presets = {
        mobile: '(min-width: 400px)',
        Mobile: '@media (min-width: 400px)',
        phablet: '(min-width: 550px)',
        Phablet: '@media (min-width: 550px)',
        tablet: '(min-width: 750px)',
        Tablet: '@media (min-width: 750px)',
        desktop: '(min-width: 1000px)',
        Desktop: '@media (min-width: 1000px)',
        hd: '(min-width: 1200px)',
        Hd: '@media (min-width: 1200px)',
      };
      var style = (exports.style = css);
      function select(selector) {
        for (var _len3 = arguments.length, styles = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)
          styles[_key3 - 1] = arguments[_key3];
        return selector ? css(_defineProperty({}, selector, styles)) : style(styles);
      }
      exports.$ = select;
      (exports.merge = css), (exports.compose = css);
      function pseudo(selector) {
        for (var _len6 = arguments.length, styles = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++)
          styles[_key6 - 1] = arguments[_key6];
        return css(_defineProperty({}, selector, styles));
      }
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var React = (function _interopDefault(e) {
        return e && 'object' == typeof e && 'default' in e ? e.default : e;
      })(__webpack_require__(0));
      function AppContainer(e) {
        return (
          AppContainer.warnAboutHMRDisabled &&
            ((AppContainer.warnAboutHMRDisabled = !0),
            console.error(
              'React-Hot-Loader: misconfiguration detected, using production version in non-production environment.'
            ),
            console.error('React-Hot-Loader: Hot Module Replacement is not enabled.')),
          React.Children.only(e.children)
        );
      }
      AppContainer.warnAboutHMRDisabled = !1;
      var hot = function e() {
        return e.shouldWrapWithAppContainer
          ? function (e) {
              return function (n) {
                return React.createElement(AppContainer, null, React.createElement(e, n));
              };
            }
          : function (e) {
              return e;
            };
      };
      hot.shouldWrapWithAppContainer = !1;
      (exports.AppContainer = AppContainer),
        (exports.hot = hot),
        (exports.areComponentsEqual = function (e, n) {
          return e === n;
        }),
        (exports.setConfig = function () {}),
        (exports.cold = function (e) {
          return e;
        }),
        (exports.configureComponent = function () {});
    },
    ,
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function createThunkMiddleware(extraArgument) {
        return function (_ref) {
          var dispatch = _ref.dispatch,
            getState = _ref.getState;
          return function (next) {
            return function (action) {
              return 'function' == typeof action ? action(dispatch, getState, extraArgument) : next(action);
            };
          };
        };
      }
      __webpack_require__.r(__webpack_exports__);
      var thunk = createThunkMiddleware();
      (thunk.withExtraArgument = createThunkMiddleware), (__webpack_exports__.default = thunk);
    },
    ,
    function (module, exports, __webpack_require__) {
      (function (global) {
        !(function (e) {
          'use strict';
          function t(e, t) {
            (e.super_ = t),
              (e.prototype = Object.create(t.prototype, {
                constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 },
              }));
          }
          function r(e, t) {
            Object.defineProperty(this, 'kind', { value: e, enumerable: !0 }),
              t && t.length && Object.defineProperty(this, 'path', { value: t, enumerable: !0 });
          }
          function n(e, t, r) {
            n.super_.call(this, 'E', e),
              Object.defineProperty(this, 'lhs', { value: t, enumerable: !0 }),
              Object.defineProperty(this, 'rhs', { value: r, enumerable: !0 });
          }
          function o(e, t) {
            o.super_.call(this, 'N', e), Object.defineProperty(this, 'rhs', { value: t, enumerable: !0 });
          }
          function i(e, t) {
            i.super_.call(this, 'D', e), Object.defineProperty(this, 'lhs', { value: t, enumerable: !0 });
          }
          function a(e, t, r) {
            a.super_.call(this, 'A', e),
              Object.defineProperty(this, 'index', { value: t, enumerable: !0 }),
              Object.defineProperty(this, 'item', { value: r, enumerable: !0 });
          }
          function f(e, t, r) {
            var n = e.slice((r || t) + 1 || e.length);
            return (e.length = t < 0 ? e.length + t : t), e.push.apply(e, n), e;
          }
          function u(e) {
            var t = void 0 === e ? 'undefined' : N(e);
            return 'object' !== t
              ? t
              : e === Math
              ? 'math'
              : null === e
              ? 'null'
              : Array.isArray(e)
              ? 'array'
              : '[object Date]' === Object.prototype.toString.call(e)
              ? 'date'
              : 'function' == typeof e.toString && /^\/.*\//.test(e.toString())
              ? 'regexp'
              : 'object';
          }
          function l(e, t, r, c, s, d, p) {
            p = p || [];
            var g = (s = s || []).slice(0);
            if (void 0 !== d) {
              if (c) {
                if ('function' == typeof c && c(g, d)) return;
                if ('object' === (void 0 === c ? 'undefined' : N(c))) {
                  if (c.prefilter && c.prefilter(g, d)) return;
                  if (c.normalize) {
                    var h = c.normalize(g, d, e, t);
                    h && ((e = h[0]), (t = h[1]));
                  }
                }
              }
              g.push(d);
            }
            'regexp' === u(e) && 'regexp' === u(t) && ((e = e.toString()), (t = t.toString()));
            var y = void 0 === e ? 'undefined' : N(e),
              v = void 0 === t ? 'undefined' : N(t),
              b = 'undefined' !== y || (p && p[p.length - 1].lhs && p[p.length - 1].lhs.hasOwnProperty(d)),
              m = 'undefined' !== v || (p && p[p.length - 1].rhs && p[p.length - 1].rhs.hasOwnProperty(d));
            if (!b && m) r(new o(g, t));
            else if (!m && b) r(new i(g, e));
            else if (u(e) !== u(t)) r(new n(g, e, t));
            else if ('date' === u(e) && e - t != 0) r(new n(g, e, t));
            else if ('object' === y && null !== e && null !== t)
              if (
                p.filter(function (t) {
                  return t.lhs === e;
                }).length
              )
                e !== t && r(new n(g, e, t));
              else {
                if ((p.push({ lhs: e, rhs: t }), Array.isArray(e))) {
                  var w;
                  for (e.length, w = 0; w < e.length; w++)
                    w >= t.length ? r(new a(g, w, new i(void 0, e[w]))) : l(e[w], t[w], r, c, g, w, p);
                  for (; w < t.length; ) r(new a(g, w, new o(void 0, t[w++])));
                } else {
                  var x = Object.keys(e),
                    S = Object.keys(t);
                  x.forEach(function (n, o) {
                    var i = S.indexOf(n);
                    i >= 0 ? (l(e[n], t[n], r, c, g, n, p), (S = f(S, i))) : l(e[n], void 0, r, c, g, n, p);
                  }),
                    S.forEach(function (e) {
                      l(void 0, t[e], r, c, g, e, p);
                    });
                }
                p.length = p.length - 1;
              }
            else e !== t && (('number' === y && isNaN(e) && isNaN(t)) || r(new n(g, e, t)));
          }
          function c(e, t, r, n) {
            return (
              (n = n || []),
              l(
                e,
                t,
                function (e) {
                  e && n.push(e);
                },
                r
              ),
              n.length ? n : void 0
            );
          }
          function d(e, t, r) {
            if (e && t && r && r.kind) {
              for (var n = e, o = -1, i = r.path ? r.path.length - 1 : 0; ++o < i; )
                void 0 === n[r.path[o]] && (n[r.path[o]] = 'number' == typeof r.path[o] ? [] : {}), (n = n[r.path[o]]);
              switch (r.kind) {
                case 'A':
                  !(function s(e, t, r) {
                    if (r.path && r.path.length) {
                      var n,
                        o = e[t],
                        i = r.path.length - 1;
                      for (n = 0; n < i; n++) o = o[r.path[n]];
                      switch (r.kind) {
                        case 'A':
                          s(o[r.path[n]], r.index, r.item);
                          break;
                        case 'D':
                          delete o[r.path[n]];
                          break;
                        case 'E':
                        case 'N':
                          o[r.path[n]] = r.rhs;
                      }
                    } else
                      switch (r.kind) {
                        case 'A':
                          s(e[t], r.index, r.item);
                          break;
                        case 'D':
                          e = f(e, t);
                          break;
                        case 'E':
                        case 'N':
                          e[t] = r.rhs;
                      }
                    return e;
                  })(r.path ? n[r.path[o]] : n, r.index, r.item);
                  break;
                case 'D':
                  delete n[r.path[o]];
                  break;
                case 'E':
                case 'N':
                  n[r.path[o]] = r.rhs;
              }
            }
          }
          function y(e) {
            return 'color: ' + F[e].color + '; font-weight: bold';
          }
          function b(e, t, r, n) {
            var o = c(e, t);
            try {
              n ? r.groupCollapsed('diff') : r.group('diff');
            } catch (e) {
              r.log('diff');
            }
            o
              ? o.forEach(function (e) {
                  var t = e.kind,
                    n = (function v(e) {
                      var t = e.kind,
                        r = e.path,
                        n = e.lhs,
                        o = e.rhs,
                        i = e.index,
                        a = e.item;
                      switch (t) {
                        case 'E':
                          return [r.join('.'), n, '', o];
                        case 'N':
                          return [r.join('.'), o];
                        case 'D':
                          return [r.join('.')];
                        case 'A':
                          return [r.join('.') + '[' + i + ']', a];
                        default:
                          return [];
                      }
                    })(e);
                  r.log.apply(r, ['%c ' + F[t].text, y(t)].concat(P(n)));
                })
              : r.log(' no diff ');
            try {
              r.groupEnd();
            } catch (e) {
              r.log(' diff end  ');
            }
          }
          function m(e, t, r, n) {
            switch (void 0 === e ? 'undefined' : N(e)) {
              case 'object':
                return 'function' == typeof e[n] ? e[n].apply(e, P(r)) : e[n];
              case 'function':
                return e(t);
              default:
                return e;
            }
          }
          function x(e, t) {
            var r = t.logger,
              n = t.actionTransformer,
              o = t.titleFormatter,
              i =
                void 0 === o
                  ? (function w(e) {
                      var t = e.timestamp,
                        r = e.duration;
                      return function (e, n, o) {
                        var i = ['action'];
                        return (
                          i.push('%c' + String(e.type)),
                          t && i.push('%c@ ' + n),
                          r && i.push('%c(in ' + o.toFixed(2) + ' ms)'),
                          i.join(' ')
                        );
                      };
                    })(t)
                  : o,
              a = t.collapsed,
              f = t.colors,
              u = t.level,
              l = t.diff,
              c = void 0 === t.titleFormatter;
            e.forEach(function (o, s) {
              var d = o.started,
                p = o.startedTime,
                g = o.action,
                h = o.prevState,
                y = o.error,
                v = o.took,
                w = o.nextState,
                x = e[s + 1];
              x && ((w = x.prevState), (v = x.started - d));
              var S = n(g),
                k =
                  'function' == typeof a
                    ? a(
                        function () {
                          return w;
                        },
                        g,
                        o
                      )
                    : a,
                j = D(p),
                E = f.title ? 'color: ' + f.title(S) + ';' : '',
                A = ['color: gray; font-weight: lighter;'];
              A.push(E),
                t.timestamp && A.push('color: gray; font-weight: lighter;'),
                t.duration && A.push('color: gray; font-weight: lighter;');
              var O = i(S, j, v);
              try {
                k
                  ? f.title && c
                    ? r.groupCollapsed.apply(r, ['%c ' + O].concat(A))
                    : r.groupCollapsed(O)
                  : f.title && c
                  ? r.group.apply(r, ['%c ' + O].concat(A))
                  : r.group(O);
              } catch (e) {
                r.log(O);
              }
              var N = m(u, S, [h], 'prevState'),
                P = m(u, S, [S], 'action'),
                C = m(u, S, [y, h], 'error'),
                F = m(u, S, [w], 'nextState');
              if (N)
                if (f.prevState) {
                  var L = 'color: ' + f.prevState(h) + '; font-weight: bold';
                  r[N]('%c prev state', L, h);
                } else r[N]('prev state', h);
              if (P)
                if (f.action) {
                  var T = 'color: ' + f.action(S) + '; font-weight: bold';
                  r[P]('%c action    ', T, S);
                } else r[P]('action    ', S);
              if (y && C)
                if (f.error) {
                  var M = 'color: ' + f.error(y, h) + '; font-weight: bold;';
                  r[C]('%c error     ', M, y);
                } else r[C]('error     ', y);
              if (F)
                if (f.nextState) {
                  var _ = 'color: ' + f.nextState(w) + '; font-weight: bold';
                  r[F]('%c next state', _, w);
                } else r[F]('next state', w);
              l && b(h, w, r, k);
              try {
                r.groupEnd();
              } catch (e) {
                r.log(' log end ');
              }
            });
          }
          function S() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
              t = Object.assign({}, L, e),
              r = t.logger,
              n = t.stateTransformer,
              o = t.errorTransformer,
              i = t.predicate,
              a = t.logErrors,
              f = t.diffPredicate;
            if (void 0 === r)
              return function () {
                return function (e) {
                  return function (t) {
                    return e(t);
                  };
                };
              };
            if (e.getState && e.dispatch)
              return (
                console.error(
                  "[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n// Logger with default options\nimport { logger } from 'redux-logger'\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n// Or you can create your own logger with custom options http://bit.ly/redux-logger-options\nimport createLogger from 'redux-logger'\nconst logger = createLogger({\n  // ...options\n});\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n"
                ),
                function () {
                  return function (e) {
                    return function (t) {
                      return e(t);
                    };
                  };
                }
              );
            var u = [];
            return function (e) {
              var r = e.getState;
              return function (e) {
                return function (l) {
                  if ('function' == typeof i && !i(r, l)) return e(l);
                  var c = {};
                  u.push(c),
                    (c.started = O.now()),
                    (c.startedTime = new Date()),
                    (c.prevState = n(r())),
                    (c.action = l);
                  var s = void 0;
                  if (a)
                    try {
                      s = e(l);
                    } catch (e) {
                      c.error = o(e);
                    }
                  else s = e(l);
                  (c.took = O.now() - c.started), (c.nextState = n(r()));
                  var d = t.diff && 'function' == typeof f ? f(r, l) : t.diff;
                  if ((x(u, Object.assign({}, t, { diff: d })), (u.length = 0), c.error)) throw c.error;
                  return s;
                };
              };
            };
          }
          var k,
            j,
            A = function (e, t) {
              return (
                (function (e, t) {
                  return new Array(t + 1).join(e);
                })('0', t - e.toString().length) + e
              );
            },
            D = function (e) {
              return (
                A(e.getHours(), 2) +
                ':' +
                A(e.getMinutes(), 2) +
                ':' +
                A(e.getSeconds(), 2) +
                '.' +
                A(e.getMilliseconds(), 3)
              );
            },
            O =
              'undefined' != typeof performance && null !== performance && 'function' == typeof performance.now
                ? performance
                : Date,
            N =
              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
                ? function (e) {
                    return typeof e;
                  }
                : function (e) {
                    return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype
                      ? 'symbol'
                      : typeof e;
                  },
            P = function (e) {
              if (Array.isArray(e)) {
                for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
                return r;
              }
              return Array.from(e);
            },
            C = [];
          (k =
            'object' === (void 0 === global ? 'undefined' : N(global)) && global
              ? global
              : 'undefined' != typeof window
              ? window
              : {}),
            (j = k.DeepDiff) &&
              C.push(function () {
                void 0 !== j && k.DeepDiff === c && ((k.DeepDiff = j), (j = void 0));
              }),
            t(n, r),
            t(o, r),
            t(i, r),
            t(a, r),
            Object.defineProperties(c, {
              diff: { value: c, enumerable: !0 },
              observableDiff: { value: l, enumerable: !0 },
              applyDiff: {
                value: function h(e, t, r) {
                  e &&
                    t &&
                    l(e, t, function (n) {
                      (r && !r(e, t, n)) || d(e, t, n);
                    });
                },
                enumerable: !0,
              },
              applyChange: { value: d, enumerable: !0 },
              revertChange: {
                value: function g(e, t, r) {
                  if (e && t && r && r.kind) {
                    var n,
                      o,
                      i = e;
                    for (o = r.path.length - 1, n = 0; n < o; n++)
                      void 0 === i[r.path[n]] && (i[r.path[n]] = {}), (i = i[r.path[n]]);
                    switch (r.kind) {
                      case 'A':
                        !(function p(e, t, r) {
                          if (r.path && r.path.length) {
                            var n,
                              o = e[t],
                              i = r.path.length - 1;
                            for (n = 0; n < i; n++) o = o[r.path[n]];
                            switch (r.kind) {
                              case 'A':
                                p(o[r.path[n]], r.index, r.item);
                                break;
                              case 'D':
                              case 'E':
                                o[r.path[n]] = r.lhs;
                                break;
                              case 'N':
                                delete o[r.path[n]];
                            }
                          } else
                            switch (r.kind) {
                              case 'A':
                                p(e[t], r.index, r.item);
                                break;
                              case 'D':
                              case 'E':
                                e[t] = r.lhs;
                                break;
                              case 'N':
                                e = f(e, t);
                            }
                          return e;
                        })(i[r.path[n]], r.index, r.item);
                        break;
                      case 'D':
                      case 'E':
                        i[r.path[n]] = r.lhs;
                        break;
                      case 'N':
                        delete i[r.path[n]];
                    }
                  }
                },
                enumerable: !0,
              },
              isConflict: {
                value: function () {
                  return void 0 !== j;
                },
                enumerable: !0,
              },
              noConflict: {
                value: function () {
                  return (
                    C &&
                      (C.forEach(function (e) {
                        e();
                      }),
                      (C = null)),
                    c
                  );
                },
                enumerable: !0,
              },
            });
          var F = {
              E: { color: '#2196F3', text: 'CHANGED:' },
              N: { color: '#4CAF50', text: 'ADDED:' },
              D: { color: '#F44336', text: 'DELETED:' },
              A: { color: '#2196F3', text: 'ARRAY:' },
            },
            L = {
              level: 'log',
              logger: console,
              logErrors: !0,
              collapsed: void 0,
              predicate: void 0,
              duration: !1,
              timestamp: !0,
              stateTransformer: function (e) {
                return e;
              },
              actionTransformer: function (e) {
                return e;
              },
              errorTransformer: function (e) {
                return e;
              },
              colors: {
                title: function () {
                  return 'inherit';
                },
                prevState: function () {
                  return '#9E9E9E';
                },
                action: function () {
                  return '#03A9F4';
                },
                nextState: function () {
                  return '#4CAF50';
                },
                error: function () {
                  return '#F20404';
                },
              },
              diff: !1,
              diffPredicate: void 0,
              transformer: void 0,
            },
            T = function () {
              var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                t = e.dispatch,
                r = e.getState;
              return 'function' == typeof t || 'function' == typeof r
                ? S()({ dispatch: t, getState: r })
                : void console.error(
                    "\n[redux-logger v3] BREAKING CHANGE\n[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.\n[redux-logger v3] Change\n[redux-logger v3] import createLogger from 'redux-logger'\n[redux-logger v3] to\n[redux-logger v3] import { createLogger } from 'redux-logger'\n"
                  );
            };
          (e.defaults = L),
            (e.createLogger = S),
            (e.logger = T),
            (e.default = T),
            Object.defineProperty(e, '__esModule', { value: !0 });
        })(exports);
      }.call(this, __webpack_require__(22)));
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.r(__webpack_exports__),
        __webpack_require__.d(__webpack_exports__, 'BrowserRouter', function () {
          return BrowserRouter;
        }),
        __webpack_require__.d(__webpack_exports__, 'HashRouter', function () {
          return HashRouter;
        }),
        __webpack_require__.d(__webpack_exports__, 'Link', function () {
          return Link;
        }),
        __webpack_require__.d(__webpack_exports__, 'NavLink', function () {
          return NavLink;
        });
      var react_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
      __webpack_require__.d(__webpack_exports__, 'MemoryRouter', function () {
        return react_router__WEBPACK_IMPORTED_MODULE_0__.a;
      }),
        __webpack_require__.d(__webpack_exports__, 'Prompt', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.b;
        }),
        __webpack_require__.d(__webpack_exports__, 'Redirect', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.c;
        }),
        __webpack_require__.d(__webpack_exports__, 'Route', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.d;
        }),
        __webpack_require__.d(__webpack_exports__, 'Router', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.e;
        }),
        __webpack_require__.d(__webpack_exports__, 'StaticRouter', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.f;
        }),
        __webpack_require__.d(__webpack_exports__, 'Switch', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.g;
        }),
        __webpack_require__.d(__webpack_exports__, 'generatePath', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.i;
        }),
        __webpack_require__.d(__webpack_exports__, 'matchPath', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.j;
        }),
        __webpack_require__.d(__webpack_exports__, 'useHistory', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.k;
        }),
        __webpack_require__.d(__webpack_exports__, 'useLocation', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.l;
        }),
        __webpack_require__.d(__webpack_exports__, 'useParams', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.m;
        }),
        __webpack_require__.d(__webpack_exports__, 'useRouteMatch', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.n;
        }),
        __webpack_require__.d(__webpack_exports__, 'withRouter', function () {
          return react_router__WEBPACK_IMPORTED_MODULE_0__.o;
        });
      var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7),
        react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0),
        react__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__),
        history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9),
        prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1),
        prop_types__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(
          prop_types__WEBPACK_IMPORTED_MODULE_4__
        ),
        tiny_warning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3),
        _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2),
        _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5),
        tiny_invariant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6),
        BrowserRouter = (function (_React$Component) {
          function BrowserRouter() {
            for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
              args[_key] = arguments[_key];
            return (
              ((_this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this).history = Object(
                history__WEBPACK_IMPORTED_MODULE_3__.a
              )(_this.props)),
              _this
            );
          }
          return (
            Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__.a)(
              BrowserRouter,
              _React$Component
            ),
            (BrowserRouter.prototype.render = function render() {
              return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
                react_router__WEBPACK_IMPORTED_MODULE_0__.e,
                { history: this.history, children: this.props.children }
              );
            }),
            BrowserRouter
          );
        })(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);
      (BrowserRouter.propTypes = {
        basename: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
        children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node,
        forceRefresh: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
        getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
        keyLength: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,
      }),
        (BrowserRouter.prototype.componentDidMount = function () {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_5__.a)(
            !this.props.history,
            '<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.'
          );
        });
      var HashRouter = (function (_React$Component) {
        function HashRouter() {
          for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return (
            ((_this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this).history = Object(
              history__WEBPACK_IMPORTED_MODULE_3__.b
            )(_this.props)),
            _this
          );
        }
        return (
          Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__.a)(HashRouter, _React$Component),
          (HashRouter.prototype.render = function render() {
            return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
              react_router__WEBPACK_IMPORTED_MODULE_0__.e,
              { history: this.history, children: this.props.children }
            );
          }),
          HashRouter
        );
      })(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);
      (HashRouter.propTypes = {
        basename: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
        children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node,
        getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
        hashType: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(['hashbang', 'noslash', 'slash']),
      }),
        (HashRouter.prototype.componentDidMount = function () {
          Object(tiny_warning__WEBPACK_IMPORTED_MODULE_5__.a)(
            !this.props.history,
            '<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.'
          );
        });
      var resolveToLocation = function resolveToLocation(to, currentLocation) {
          return 'function' == typeof to ? to(currentLocation) : to;
        },
        normalizeToLocation = function normalizeToLocation(to, currentLocation) {
          return 'string' == typeof to
            ? Object(history__WEBPACK_IMPORTED_MODULE_3__.c)(to, null, null, currentLocation)
            : to;
        },
        forwardRefShim = function forwardRefShim(C) {
          return C;
        },
        forwardRef = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef;
      void 0 === forwardRef && (forwardRef = forwardRefShim);
      var LinkAnchor = forwardRef(function (_ref, forwardedRef) {
        var innerRef = _ref.innerRef,
          navigate = _ref.navigate,
          _onClick = _ref.onClick,
          rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__.a)(_ref, [
            'innerRef',
            'navigate',
            'onClick',
          ]),
          target = rest.target,
          props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__.a)({}, rest, {
            onClick: function onClick(event) {
              try {
                _onClick && _onClick(event);
              } catch (ex) {
                throw (event.preventDefault(), ex);
              }
              event.defaultPrevented ||
                0 !== event.button ||
                (target && '_self' !== target) ||
                (function isModifiedEvent(event) {
                  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
                })(event) ||
                (event.preventDefault(), navigate());
            },
          });
        return (
          (props.ref = (forwardRefShim !== forwardRef && forwardedRef) || innerRef),
          react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement('a', props)
        );
      });
      LinkAnchor.displayName = 'LinkAnchor';
      var Link = forwardRef(function (_ref2, forwardedRef) {
          var _ref2$component = _ref2.component,
            component = void 0 === _ref2$component ? LinkAnchor : _ref2$component,
            replace = _ref2.replace,
            to = _ref2.to,
            innerRef = _ref2.innerRef,
            rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__.a)(
              _ref2,
              ['component', 'replace', 'to', 'innerRef']
            );
          return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
            react_router__WEBPACK_IMPORTED_MODULE_0__.h.Consumer,
            null,
            function (context) {
              context ||
                Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_8__.a)(
                  !1,
                  'You should not use <Link> outside a <Router>'
                );
              var history = context.history,
                location = normalizeToLocation(resolveToLocation(to, context.location), context.location),
                href = location ? history.createHref(location) : '',
                props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__.a)({}, rest, {
                  href,
                  navigate: function navigate() {
                    var location = resolveToLocation(to, context.location);
                    (replace ? history.replace : history.push)(location);
                  },
                });
              return (
                forwardRefShim !== forwardRef ? (props.ref = forwardedRef || innerRef) : (props.innerRef = innerRef),
                react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(component, props)
              );
            }
          );
        }),
        toType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([
          prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
          prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
          prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
        ]),
        refType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([
          prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
          prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
          prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.shape({
            current: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.any,
          }),
        ]);
      (Link.displayName = 'Link'),
        (Link.propTypes = {
          innerRef: refType,
          onClick: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
          replace: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
          target: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
          to: toType.isRequired,
        });
      var forwardRefShim$1 = function forwardRefShim(C) {
          return C;
        },
        forwardRef$1 = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef;
      void 0 === forwardRef$1 && (forwardRef$1 = forwardRefShim$1);
      var NavLink = forwardRef$1(function (_ref, forwardedRef) {
        var _ref$ariaCurrent = _ref['aria-current'],
          ariaCurrent = void 0 === _ref$ariaCurrent ? 'page' : _ref$ariaCurrent,
          _ref$activeClassName = _ref.activeClassName,
          activeClassName = void 0 === _ref$activeClassName ? 'active' : _ref$activeClassName,
          activeStyle = _ref.activeStyle,
          classNameProp = _ref.className,
          exact = _ref.exact,
          isActiveProp = _ref.isActive,
          locationProp = _ref.location,
          sensitive = _ref.sensitive,
          strict = _ref.strict,
          styleProp = _ref.style,
          to = _ref.to,
          innerRef = _ref.innerRef,
          rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__.a)(_ref, [
            'aria-current',
            'activeClassName',
            'activeStyle',
            'className',
            'exact',
            'isActive',
            'location',
            'sensitive',
            'strict',
            'style',
            'to',
            'innerRef',
          ]);
        return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(
          react_router__WEBPACK_IMPORTED_MODULE_0__.h.Consumer,
          null,
          function (context) {
            context ||
              Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_8__.a)(
                !1,
                'You should not use <NavLink> outside a <Router>'
              );
            var currentLocation = locationProp || context.location,
              toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation),
              path = toLocation.pathname,
              escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1'),
              match = escapedPath
                ? Object(react_router__WEBPACK_IMPORTED_MODULE_0__.j)(currentLocation.pathname, {
                    path: escapedPath,
                    exact,
                    sensitive,
                    strict,
                  })
                : null,
              isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match),
              className = isActive
                ? (function joinClassnames() {
                    for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++)
                      classnames[_key] = arguments[_key];
                    return classnames
                      .filter(function (i) {
                        return i;
                      })
                      .join(' ');
                  })(classNameProp, activeClassName)
                : classNameProp,
              style = isActive
                ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__.a)(
                    {},
                    styleProp,
                    {},
                    activeStyle
                  )
                : styleProp,
              props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__.a)(
                { 'aria-current': (isActive && ariaCurrent) || null, className, style, to: toLocation },
                rest
              );
            return (
              forwardRefShim$1 !== forwardRef$1 ? (props.ref = forwardedRef || innerRef) : (props.innerRef = innerRef),
              react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Link, props)
            );
          }
        );
      });
      NavLink.displayName = 'NavLink';
      var ariaCurrentType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf([
        'page',
        'step',
        'location',
        'date',
        'time',
        'true',
      ]);
      NavLink.propTypes = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__.a)(
        {},
        Link.propTypes,
        {
          'aria-current': ariaCurrentType,
          activeClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
          activeStyle: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
          className: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
          exact: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
          isActive: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
          location: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
          sensitive: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
          strict: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
          style: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
        }
      );
    },
    ,
    function (module, exports, __webpack_require__) {
      (function (global) {
        var freeGlobal = 'object' == typeof global && global && global.Object === Object && global;
        module.exports = freeGlobal;
      }.call(this, __webpack_require__(22)));
    },
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(17),
        isObject = __webpack_require__(55);
      module.exports = function isFunction(value) {
        if (!isObject(value)) return !1;
        var tag = baseGetTag(value);
        return (
          '[object Function]' == tag ||
          '[object GeneratorFunction]' == tag ||
          '[object AsyncFunction]' == tag ||
          '[object Proxy]' == tag
        );
      };
    },
    function (module, exports) {
      module.exports = function isObject(value) {
        var type = typeof value;
        return null != value && ('object' == type || 'function' == type);
      };
    },
    function (module, exports) {
      var funcToString = Function.prototype.toString;
      module.exports = function toSource(func) {
        if (null != func) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return func + '';
          } catch (e) {}
        }
        return '';
      };
    },
    function (module, exports, __webpack_require__) {
      var Map = __webpack_require__(16)(__webpack_require__(12), 'Map');
      module.exports = Map;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        Object.defineProperty(exports, 'Tabs', {
          enumerable: !0,
          get: function get() {
            return _Tabs.default;
          },
        }),
        Object.defineProperty(exports, 'Tab', {
          enumerable: !0,
          get: function get() {
            return _Tab.default;
          },
        });
      var _Tabs = _interopRequireDefault(__webpack_require__(159)),
        _Tab = _interopRequireDefault(__webpack_require__(193));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.r(__webpack_exports__),
        __webpack_require__.d(__webpack_exports__, 'ThemeProvider', function () {
          return ThemeProvider;
        }),
        __webpack_require__.d(__webpack_exports__, 'withTheme', function () {
          return withTheme;
        }),
        __webpack_require__.d(__webpack_exports__, 'A', function () {
          return A;
        }),
        __webpack_require__.d(__webpack_exports__, 'Abbr', function () {
          return Abbr;
        }),
        __webpack_require__.d(__webpack_exports__, 'Acronym', function () {
          return Acronym;
        }),
        __webpack_require__.d(__webpack_exports__, 'Address', function () {
          return Address;
        }),
        __webpack_require__.d(__webpack_exports__, 'Applet', function () {
          return Applet;
        }),
        __webpack_require__.d(__webpack_exports__, 'Area', function () {
          return Area;
        }),
        __webpack_require__.d(__webpack_exports__, 'Article', function () {
          return Article;
        }),
        __webpack_require__.d(__webpack_exports__, 'Aside', function () {
          return Aside;
        }),
        __webpack_require__.d(__webpack_exports__, 'Audio', function () {
          return Audio;
        }),
        __webpack_require__.d(__webpack_exports__, 'B', function () {
          return B;
        }),
        __webpack_require__.d(__webpack_exports__, 'Base', function () {
          return Base;
        }),
        __webpack_require__.d(__webpack_exports__, 'Basefont', function () {
          return Basefont;
        }),
        __webpack_require__.d(__webpack_exports__, 'Bdi', function () {
          return Bdi;
        }),
        __webpack_require__.d(__webpack_exports__, 'Bdo', function () {
          return Bdo;
        }),
        __webpack_require__.d(__webpack_exports__, 'Bgsound', function () {
          return Bgsound;
        }),
        __webpack_require__.d(__webpack_exports__, 'Big', function () {
          return Big;
        }),
        __webpack_require__.d(__webpack_exports__, 'Blink', function () {
          return Blink;
        }),
        __webpack_require__.d(__webpack_exports__, 'Blockquote', function () {
          return Blockquote;
        }),
        __webpack_require__.d(__webpack_exports__, 'Body', function () {
          return Body;
        }),
        __webpack_require__.d(__webpack_exports__, 'Br', function () {
          return Br;
        }),
        __webpack_require__.d(__webpack_exports__, 'Button', function () {
          return Button;
        }),
        __webpack_require__.d(__webpack_exports__, 'Canvas', function () {
          return Canvas;
        }),
        __webpack_require__.d(__webpack_exports__, 'Caption', function () {
          return Caption;
        }),
        __webpack_require__.d(__webpack_exports__, 'Center', function () {
          return Center;
        }),
        __webpack_require__.d(__webpack_exports__, 'Cite', function () {
          return Cite;
        }),
        __webpack_require__.d(__webpack_exports__, 'Code', function () {
          return Code;
        }),
        __webpack_require__.d(__webpack_exports__, 'Col', function () {
          return Col;
        }),
        __webpack_require__.d(__webpack_exports__, 'Colgroup', function () {
          return Colgroup;
        }),
        __webpack_require__.d(__webpack_exports__, 'Command', function () {
          return Command;
        }),
        __webpack_require__.d(__webpack_exports__, 'Content', function () {
          return Content;
        }),
        __webpack_require__.d(__webpack_exports__, 'Data', function () {
          return Data;
        }),
        __webpack_require__.d(__webpack_exports__, 'Datalist', function () {
          return Datalist;
        }),
        __webpack_require__.d(__webpack_exports__, 'Dd', function () {
          return Dd;
        }),
        __webpack_require__.d(__webpack_exports__, 'Del', function () {
          return Del;
        }),
        __webpack_require__.d(__webpack_exports__, 'Details', function () {
          return Details;
        }),
        __webpack_require__.d(__webpack_exports__, 'Dfn', function () {
          return Dfn;
        }),
        __webpack_require__.d(__webpack_exports__, 'Dialog', function () {
          return Dialog;
        }),
        __webpack_require__.d(__webpack_exports__, 'Dir', function () {
          return Dir;
        }),
        __webpack_require__.d(__webpack_exports__, 'Div', function () {
          return Div;
        }),
        __webpack_require__.d(__webpack_exports__, 'Dl', function () {
          return Dl;
        }),
        __webpack_require__.d(__webpack_exports__, 'Dt', function () {
          return Dt;
        }),
        __webpack_require__.d(__webpack_exports__, 'Element', function () {
          return Element;
        }),
        __webpack_require__.d(__webpack_exports__, 'Em', function () {
          return Em;
        }),
        __webpack_require__.d(__webpack_exports__, 'Embed', function () {
          return Embed;
        }),
        __webpack_require__.d(__webpack_exports__, 'Fieldset', function () {
          return Fieldset;
        }),
        __webpack_require__.d(__webpack_exports__, 'Figcaption', function () {
          return Figcaption;
        }),
        __webpack_require__.d(__webpack_exports__, 'Figure', function () {
          return Figure;
        }),
        __webpack_require__.d(__webpack_exports__, 'Font', function () {
          return Font;
        }),
        __webpack_require__.d(__webpack_exports__, 'Footer', function () {
          return Footer;
        }),
        __webpack_require__.d(__webpack_exports__, 'Form', function () {
          return Form;
        }),
        __webpack_require__.d(__webpack_exports__, 'Frame', function () {
          return Frame;
        }),
        __webpack_require__.d(__webpack_exports__, 'Frameset', function () {
          return Frameset;
        }),
        __webpack_require__.d(__webpack_exports__, 'H1', function () {
          return H1;
        }),
        __webpack_require__.d(__webpack_exports__, 'H2', function () {
          return H2;
        }),
        __webpack_require__.d(__webpack_exports__, 'H3', function () {
          return H3;
        }),
        __webpack_require__.d(__webpack_exports__, 'H4', function () {
          return H4;
        }),
        __webpack_require__.d(__webpack_exports__, 'H5', function () {
          return H5;
        }),
        __webpack_require__.d(__webpack_exports__, 'H6', function () {
          return H6;
        }),
        __webpack_require__.d(__webpack_exports__, 'Head', function () {
          return Head;
        }),
        __webpack_require__.d(__webpack_exports__, 'Header', function () {
          return Header;
        }),
        __webpack_require__.d(__webpack_exports__, 'Hgroup', function () {
          return Hgroup;
        }),
        __webpack_require__.d(__webpack_exports__, 'Hr', function () {
          return Hr;
        }),
        __webpack_require__.d(__webpack_exports__, 'Html', function () {
          return Html;
        }),
        __webpack_require__.d(__webpack_exports__, 'I', function () {
          return I;
        }),
        __webpack_require__.d(__webpack_exports__, 'Iframe', function () {
          return Iframe;
        }),
        __webpack_require__.d(__webpack_exports__, 'Image', function () {
          return Image;
        }),
        __webpack_require__.d(__webpack_exports__, 'Img', function () {
          return Img;
        }),
        __webpack_require__.d(__webpack_exports__, 'Input', function () {
          return Input;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ins', function () {
          return Ins;
        }),
        __webpack_require__.d(__webpack_exports__, 'Isindex', function () {
          return Isindex;
        }),
        __webpack_require__.d(__webpack_exports__, 'Kbd', function () {
          return Kbd;
        }),
        __webpack_require__.d(__webpack_exports__, 'Keygen', function () {
          return Keygen;
        }),
        __webpack_require__.d(__webpack_exports__, 'Label', function () {
          return Label;
        }),
        __webpack_require__.d(__webpack_exports__, 'Legend', function () {
          return Legend;
        }),
        __webpack_require__.d(__webpack_exports__, 'Li', function () {
          return Li;
        }),
        __webpack_require__.d(__webpack_exports__, 'Link', function () {
          return Link;
        }),
        __webpack_require__.d(__webpack_exports__, 'Listing', function () {
          return Listing;
        }),
        __webpack_require__.d(__webpack_exports__, 'Main', function () {
          return Main;
        }),
        __webpack_require__.d(__webpack_exports__, 'MapTag', function () {
          return MapTag;
        }),
        __webpack_require__.d(__webpack_exports__, 'Mark', function () {
          return Mark;
        }),
        __webpack_require__.d(__webpack_exports__, 'Marquee', function () {
          return Marquee;
        }),
        __webpack_require__.d(__webpack_exports__, 'MathTag', function () {
          return MathTag;
        }),
        __webpack_require__.d(__webpack_exports__, 'Menu', function () {
          return Menu;
        }),
        __webpack_require__.d(__webpack_exports__, 'Menuitem', function () {
          return Menuitem;
        }),
        __webpack_require__.d(__webpack_exports__, 'Meta', function () {
          return Meta;
        }),
        __webpack_require__.d(__webpack_exports__, 'Meter', function () {
          return Meter;
        }),
        __webpack_require__.d(__webpack_exports__, 'Multicol', function () {
          return Multicol;
        }),
        __webpack_require__.d(__webpack_exports__, 'Nav', function () {
          return Nav;
        }),
        __webpack_require__.d(__webpack_exports__, 'Nextid', function () {
          return Nextid;
        }),
        __webpack_require__.d(__webpack_exports__, 'Nobr', function () {
          return Nobr;
        }),
        __webpack_require__.d(__webpack_exports__, 'Noembed', function () {
          return Noembed;
        }),
        __webpack_require__.d(__webpack_exports__, 'Noframes', function () {
          return Noframes;
        }),
        __webpack_require__.d(__webpack_exports__, 'Noscript', function () {
          return Noscript;
        }),
        __webpack_require__.d(__webpack_exports__, 'ObjectTag', function () {
          return ObjectTag;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ol', function () {
          return Ol;
        }),
        __webpack_require__.d(__webpack_exports__, 'Optgroup', function () {
          return Optgroup;
        }),
        __webpack_require__.d(__webpack_exports__, 'Option', function () {
          return Option;
        }),
        __webpack_require__.d(__webpack_exports__, 'Output', function () {
          return Output;
        }),
        __webpack_require__.d(__webpack_exports__, 'P', function () {
          return P;
        }),
        __webpack_require__.d(__webpack_exports__, 'Param', function () {
          return Param;
        }),
        __webpack_require__.d(__webpack_exports__, 'Picture', function () {
          return Picture;
        }),
        __webpack_require__.d(__webpack_exports__, 'Plaintext', function () {
          return Plaintext;
        }),
        __webpack_require__.d(__webpack_exports__, 'Pre', function () {
          return Pre;
        }),
        __webpack_require__.d(__webpack_exports__, 'Progress', function () {
          return Progress;
        }),
        __webpack_require__.d(__webpack_exports__, 'Q', function () {
          return Q;
        }),
        __webpack_require__.d(__webpack_exports__, 'Rb', function () {
          return Rb;
        }),
        __webpack_require__.d(__webpack_exports__, 'Rbc', function () {
          return Rbc;
        }),
        __webpack_require__.d(__webpack_exports__, 'Rp', function () {
          return Rp;
        }),
        __webpack_require__.d(__webpack_exports__, 'Rt', function () {
          return Rt;
        }),
        __webpack_require__.d(__webpack_exports__, 'Rtc', function () {
          return Rtc;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ruby', function () {
          return Ruby;
        }),
        __webpack_require__.d(__webpack_exports__, 'S', function () {
          return S;
        }),
        __webpack_require__.d(__webpack_exports__, 'Samp', function () {
          return Samp;
        }),
        __webpack_require__.d(__webpack_exports__, 'Script', function () {
          return Script;
        }),
        __webpack_require__.d(__webpack_exports__, 'Section', function () {
          return Section;
        }),
        __webpack_require__.d(__webpack_exports__, 'Select', function () {
          return Select;
        }),
        __webpack_require__.d(__webpack_exports__, 'Shadow', function () {
          return Shadow;
        }),
        __webpack_require__.d(__webpack_exports__, 'Slot', function () {
          return Slot;
        }),
        __webpack_require__.d(__webpack_exports__, 'Small', function () {
          return Small;
        }),
        __webpack_require__.d(__webpack_exports__, 'Source', function () {
          return Source;
        }),
        __webpack_require__.d(__webpack_exports__, 'Spacer', function () {
          return Spacer;
        }),
        __webpack_require__.d(__webpack_exports__, 'Span', function () {
          return Span;
        }),
        __webpack_require__.d(__webpack_exports__, 'Strike', function () {
          return Strike;
        }),
        __webpack_require__.d(__webpack_exports__, 'Strong', function () {
          return Strong;
        }),
        __webpack_require__.d(__webpack_exports__, 'Style', function () {
          return Style;
        }),
        __webpack_require__.d(__webpack_exports__, 'Sub', function () {
          return Sub;
        }),
        __webpack_require__.d(__webpack_exports__, 'Summary', function () {
          return Summary;
        }),
        __webpack_require__.d(__webpack_exports__, 'Sup', function () {
          return Sup;
        }),
        __webpack_require__.d(__webpack_exports__, 'Svg', function () {
          return Svg;
        }),
        __webpack_require__.d(__webpack_exports__, 'Table', function () {
          return Table;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tbody', function () {
          return Tbody;
        }),
        __webpack_require__.d(__webpack_exports__, 'Td', function () {
          return Td;
        }),
        __webpack_require__.d(__webpack_exports__, 'Template', function () {
          return Template;
        }),
        __webpack_require__.d(__webpack_exports__, 'Textarea', function () {
          return Textarea;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tfoot', function () {
          return Tfoot;
        }),
        __webpack_require__.d(__webpack_exports__, 'Th', function () {
          return Th;
        }),
        __webpack_require__.d(__webpack_exports__, 'Thead', function () {
          return Thead;
        }),
        __webpack_require__.d(__webpack_exports__, 'Time', function () {
          return Time;
        }),
        __webpack_require__.d(__webpack_exports__, 'Title', function () {
          return Title;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tr', function () {
          return Tr;
        }),
        __webpack_require__.d(__webpack_exports__, 'Track', function () {
          return Track;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tt', function () {
          return Tt;
        }),
        __webpack_require__.d(__webpack_exports__, 'U', function () {
          return U;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ul', function () {
          return Ul;
        }),
        __webpack_require__.d(__webpack_exports__, 'Var', function () {
          return Var;
        }),
        __webpack_require__.d(__webpack_exports__, 'Video', function () {
          return Video;
        }),
        __webpack_require__.d(__webpack_exports__, 'Wbr', function () {
          return Wbr;
        }),
        __webpack_require__.d(__webpack_exports__, 'Xmp', function () {
          return Xmp;
        }),
        __webpack_require__.d(__webpack_exports__, 'AltGlyph', function () {
          return AltGlyph;
        }),
        __webpack_require__.d(__webpack_exports__, 'AltGlyphDef', function () {
          return AltGlyphDef;
        }),
        __webpack_require__.d(__webpack_exports__, 'AltGlyphItem', function () {
          return AltGlyphItem;
        }),
        __webpack_require__.d(__webpack_exports__, 'Animate', function () {
          return Animate;
        }),
        __webpack_require__.d(__webpack_exports__, 'AnimateColor', function () {
          return AnimateColor;
        }),
        __webpack_require__.d(__webpack_exports__, 'AnimateMotion', function () {
          return AnimateMotion;
        }),
        __webpack_require__.d(__webpack_exports__, 'AnimateTransform', function () {
          return AnimateTransform;
        }),
        __webpack_require__.d(__webpack_exports__, 'Animation', function () {
          return Animation;
        }),
        __webpack_require__.d(__webpack_exports__, 'Circle', function () {
          return Circle;
        }),
        __webpack_require__.d(__webpack_exports__, 'ClipPath', function () {
          return ClipPath;
        }),
        __webpack_require__.d(__webpack_exports__, 'ColorProfile', function () {
          return ColorProfile;
        }),
        __webpack_require__.d(__webpack_exports__, 'Cursor', function () {
          return Cursor;
        }),
        __webpack_require__.d(__webpack_exports__, 'Defs', function () {
          return Defs;
        }),
        __webpack_require__.d(__webpack_exports__, 'Desc', function () {
          return Desc;
        }),
        __webpack_require__.d(__webpack_exports__, 'Discard', function () {
          return Discard;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ellipse', function () {
          return Ellipse;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeBlend', function () {
          return FeBlend;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeColorMatrix', function () {
          return FeColorMatrix;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeComponentTransfer', function () {
          return FeComponentTransfer;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeComposite', function () {
          return FeComposite;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeConvolveMatrix', function () {
          return FeConvolveMatrix;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeDiffuseLighting', function () {
          return FeDiffuseLighting;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeDisplacementMap', function () {
          return FeDisplacementMap;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeDistantLight', function () {
          return FeDistantLight;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeDropShadow', function () {
          return FeDropShadow;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeFlood', function () {
          return FeFlood;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeFuncA', function () {
          return FeFuncA;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeFuncB', function () {
          return FeFuncB;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeFuncG', function () {
          return FeFuncG;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeFuncR', function () {
          return FeFuncR;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeGaussianBlur', function () {
          return FeGaussianBlur;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeImage', function () {
          return FeImage;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeMerge', function () {
          return FeMerge;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeMergeNode', function () {
          return FeMergeNode;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeMorphology', function () {
          return FeMorphology;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeOffset', function () {
          return FeOffset;
        }),
        __webpack_require__.d(__webpack_exports__, 'FePointLight', function () {
          return FePointLight;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeSpecularLighting', function () {
          return FeSpecularLighting;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeSpotLight', function () {
          return FeSpotLight;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeTile', function () {
          return FeTile;
        }),
        __webpack_require__.d(__webpack_exports__, 'FeTurbulence', function () {
          return FeTurbulence;
        }),
        __webpack_require__.d(__webpack_exports__, 'Filter', function () {
          return Filter;
        }),
        __webpack_require__.d(__webpack_exports__, 'FontFace', function () {
          return FontFace;
        }),
        __webpack_require__.d(__webpack_exports__, 'FontFaceFormat', function () {
          return FontFaceFormat;
        }),
        __webpack_require__.d(__webpack_exports__, 'FontFaceName', function () {
          return FontFaceName;
        }),
        __webpack_require__.d(__webpack_exports__, 'FontFaceSrc', function () {
          return FontFaceSrc;
        }),
        __webpack_require__.d(__webpack_exports__, 'FontFaceUri', function () {
          return FontFaceUri;
        }),
        __webpack_require__.d(__webpack_exports__, 'ForeignObject', function () {
          return ForeignObject;
        }),
        __webpack_require__.d(__webpack_exports__, 'G', function () {
          return G;
        }),
        __webpack_require__.d(__webpack_exports__, 'Glyph', function () {
          return Glyph;
        }),
        __webpack_require__.d(__webpack_exports__, 'GlyphRef', function () {
          return GlyphRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'Handler', function () {
          return Handler;
        }),
        __webpack_require__.d(__webpack_exports__, 'Hatch', function () {
          return Hatch;
        }),
        __webpack_require__.d(__webpack_exports__, 'Hatchpath', function () {
          return Hatchpath;
        }),
        __webpack_require__.d(__webpack_exports__, 'Hkern', function () {
          return Hkern;
        }),
        __webpack_require__.d(__webpack_exports__, 'Line', function () {
          return Line;
        }),
        __webpack_require__.d(__webpack_exports__, 'LinearGradient', function () {
          return LinearGradient;
        }),
        __webpack_require__.d(__webpack_exports__, 'Listener', function () {
          return Listener;
        }),
        __webpack_require__.d(__webpack_exports__, 'Marker', function () {
          return Marker;
        }),
        __webpack_require__.d(__webpack_exports__, 'Mask', function () {
          return Mask;
        }),
        __webpack_require__.d(__webpack_exports__, 'Mesh', function () {
          return Mesh;
        }),
        __webpack_require__.d(__webpack_exports__, 'Meshgradient', function () {
          return Meshgradient;
        }),
        __webpack_require__.d(__webpack_exports__, 'Meshpatch', function () {
          return Meshpatch;
        }),
        __webpack_require__.d(__webpack_exports__, 'Meshrow', function () {
          return Meshrow;
        }),
        __webpack_require__.d(__webpack_exports__, 'Metadata', function () {
          return Metadata;
        }),
        __webpack_require__.d(__webpack_exports__, 'MissingGlyph', function () {
          return MissingGlyph;
        }),
        __webpack_require__.d(__webpack_exports__, 'Mpath', function () {
          return Mpath;
        }),
        __webpack_require__.d(__webpack_exports__, 'Path', function () {
          return Path;
        }),
        __webpack_require__.d(__webpack_exports__, 'Pattern', function () {
          return Pattern;
        }),
        __webpack_require__.d(__webpack_exports__, 'Polygon', function () {
          return Polygon;
        }),
        __webpack_require__.d(__webpack_exports__, 'Polyline', function () {
          return Polyline;
        }),
        __webpack_require__.d(__webpack_exports__, 'Prefetch', function () {
          return Prefetch;
        }),
        __webpack_require__.d(__webpack_exports__, 'RadialGradient', function () {
          return RadialGradient;
        }),
        __webpack_require__.d(__webpack_exports__, 'Rect', function () {
          return Rect;
        }),
        __webpack_require__.d(__webpack_exports__, 'SetTag', function () {
          return SetTag;
        }),
        __webpack_require__.d(__webpack_exports__, 'SolidColor', function () {
          return SolidColor;
        }),
        __webpack_require__.d(__webpack_exports__, 'Solidcolor', function () {
          return Solidcolor;
        }),
        __webpack_require__.d(__webpack_exports__, 'Stop', function () {
          return Stop;
        }),
        __webpack_require__.d(__webpack_exports__, 'Switch', function () {
          return Switch;
        }),
        __webpack_require__.d(__webpack_exports__, 'SymbolTag', function () {
          return SymbolTag;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tbreak', function () {
          return Tbreak;
        }),
        __webpack_require__.d(__webpack_exports__, 'Text', function () {
          return Text;
        }),
        __webpack_require__.d(__webpack_exports__, 'TextArea', function () {
          return TextArea;
        }),
        __webpack_require__.d(__webpack_exports__, 'TextPath', function () {
          return TextPath;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tref', function () {
          return Tref;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tspan', function () {
          return Tspan;
        }),
        __webpack_require__.d(__webpack_exports__, 'Unknown', function () {
          return Unknown;
        }),
        __webpack_require__.d(__webpack_exports__, 'Use', function () {
          return Use;
        }),
        __webpack_require__.d(__webpack_exports__, 'View', function () {
          return View;
        }),
        __webpack_require__.d(__webpack_exports__, 'Vkern', function () {
          return Vkern;
        });
      var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0),
        react__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__),
        glamor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44),
        domElements = [
          'a',
          'abbr',
          'acronym',
          'address',
          'applet',
          'area',
          'article',
          'aside',
          'audio',
          'b',
          'base',
          'basefont',
          'bdi',
          'bdo',
          'bgsound',
          'big',
          'blink',
          'blockquote',
          'body',
          'br',
          'button',
          'canvas',
          'caption',
          'center',
          'cite',
          'code',
          'col',
          'colgroup',
          'command',
          'content',
          'data',
          'datalist',
          'dd',
          'del',
          'details',
          'dfn',
          'dialog',
          'dir',
          'div',
          'dl',
          'dt',
          'element',
          'em',
          'embed',
          'fieldset',
          'figcaption',
          'figure',
          'font',
          'footer',
          'form',
          'frame',
          'frameset',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'head',
          'header',
          'hgroup',
          'hr',
          'html',
          'i',
          'iframe',
          'image',
          'img',
          'input',
          'ins',
          'isindex',
          'kbd',
          'keygen',
          'label',
          'legend',
          'li',
          'link',
          'listing',
          'main',
          'map',
          'mark',
          'marquee',
          'math',
          'menu',
          'menuitem',
          'meta',
          'meter',
          'multicol',
          'nav',
          'nextid',
          'nobr',
          'noembed',
          'noframes',
          'noscript',
          'object',
          'ol',
          'optgroup',
          'option',
          'output',
          'p',
          'param',
          'picture',
          'plaintext',
          'pre',
          'progress',
          'q',
          'rb',
          'rbc',
          'rp',
          'rt',
          'rtc',
          'ruby',
          's',
          'samp',
          'script',
          'section',
          'select',
          'shadow',
          'slot',
          'small',
          'source',
          'spacer',
          'span',
          'strike',
          'strong',
          'style',
          'sub',
          'summary',
          'sup',
          'svg',
          'table',
          'tbody',
          'td',
          'template',
          'textarea',
          'tfoot',
          'th',
          'thead',
          'time',
          'title',
          'tr',
          'track',
          'tt',
          'u',
          'ul',
          'var',
          'video',
          'wbr',
          'xmp',
        ]
          .concat([
            'a',
            'altGlyph',
            'altGlyphDef',
            'altGlyphItem',
            'animate',
            'animateColor',
            'animateMotion',
            'animateTransform',
            'animation',
            'audio',
            'canvas',
            'circle',
            'clipPath',
            'color-profile',
            'cursor',
            'defs',
            'desc',
            'discard',
            'ellipse',
            'feBlend',
            'feColorMatrix',
            'feComponentTransfer',
            'feComposite',
            'feConvolveMatrix',
            'feDiffuseLighting',
            'feDisplacementMap',
            'feDistantLight',
            'feDropShadow',
            'feFlood',
            'feFuncA',
            'feFuncB',
            'feFuncG',
            'feFuncR',
            'feGaussianBlur',
            'feImage',
            'feMerge',
            'feMergeNode',
            'feMorphology',
            'feOffset',
            'fePointLight',
            'feSpecularLighting',
            'feSpotLight',
            'feTile',
            'feTurbulence',
            'filter',
            'font',
            'font-face',
            'font-face-format',
            'font-face-name',
            'font-face-src',
            'font-face-uri',
            'foreignObject',
            'g',
            'glyph',
            'glyphRef',
            'handler',
            'hatch',
            'hatchpath',
            'hkern',
            'iframe',
            'image',
            'line',
            'linearGradient',
            'listener',
            'marker',
            'mask',
            'mesh',
            'meshgradient',
            'meshpatch',
            'meshrow',
            'metadata',
            'missing-glyph',
            'mpath',
            'path',
            'pattern',
            'polygon',
            'polyline',
            'prefetch',
            'radialGradient',
            'rect',
            'script',
            'set',
            'solidColor',
            'solidcolor',
            'stop',
            'style',
            'svg',
            'switch',
            'symbol',
            'tbreak',
            'text',
            'textArea',
            'textPath',
            'title',
            'tref',
            'tspan',
            'unknown',
            'use',
            'video',
            'view',
            'vkern',
          ])
          .filter(function (tag, index, array) {
            return array.indexOf(tag) === index;
          }),
        CHANNEL = '__glamorous__',
        _PropTypes = void 0;
      if (parseFloat(react__WEBPACK_IMPORTED_MODULE_0___default.a.version.slice(0, 4)) >= 15.5)
        try {
          _PropTypes = __webpack_require__(1);
        } catch (error) {}
      _PropTypes = _PropTypes || react__WEBPACK_IMPORTED_MODULE_0___default.a.PropTypes;
      var classCallCheck = function (instance, Constructor) {
          if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function');
        },
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
          },
        inherits = function (subClass, superClass) {
          if ('function' != typeof superClass && null !== superClass)
            throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
          (subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: { value: subClass, enumerable: !1, writable: !0, configurable: !0 },
          })),
            superClass &&
              (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass));
        },
        objectWithoutProperties = function (obj, keys) {
          var target = {};
          for (var i in obj)
            keys.indexOf(i) >= 0 || (Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]));
          return target;
        },
        possibleConstructorReturn = function (self, call) {
          if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !call || ('object' != typeof call && 'function' != typeof call) ? self : call;
        };
      function generateWarningMessage(Comp) {
        return (
          'glamorous warning: Expected component called "' +
          (Comp.displayName || Comp.name || 'FunctionComponent') +
          '" which uses withTheme to be within a ThemeProvider but none was found.'
        );
      }
      function withTheme(ComponentToTheme) {
        var _defaultContextTypes,
          _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          _ref$noWarn = _ref.noWarn,
          noWarn = void 0 !== _ref$noWarn && _ref$noWarn,
          _ref$createElement = _ref.createElement,
          createElement = void 0 === _ref$createElement || _ref$createElement,
          ThemedComponent = (function (_React$Component) {
            function ThemedComponent() {
              var _temp, _this;
              classCallCheck(this, ThemedComponent);
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return (
                (_temp = _this = possibleConstructorReturn(
                  this,
                  _React$Component.call.apply(_React$Component, [this].concat(args))
                )),
                (_this.warned = noWarn),
                (_this.state = { theme: {} }),
                (_this.setTheme = function (theme) {
                  return _this.setState({ theme });
                }),
                possibleConstructorReturn(_this, _temp)
              );
            }
            return (
              inherits(ThemedComponent, _React$Component),
              (ThemedComponent.prototype.componentWillMount = function componentWillMount() {
                this.context[CHANNEL] ||
                  this.warned ||
                  ((this.warned = !0), console.warn(generateWarningMessage(ComponentToTheme)));
                var theme = this.props.theme;
                this.context[CHANNEL]
                  ? this.setTheme(theme || this.context[CHANNEL].getState())
                  : this.setTheme(theme || {});
              }),
              (ThemedComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
                this.props.theme !== nextProps.theme && this.setTheme(nextProps.theme);
              }),
              (ThemedComponent.prototype.componentDidMount = function componentDidMount() {
                this.context[CHANNEL] &&
                  !this.props.theme &&
                  (this.subscriptionId = this.context[CHANNEL].subscribe(this.setTheme));
              }),
              (ThemedComponent.prototype.componentWillUnmount = function componentWillUnmount() {
                this.subscriptionId && this.context[CHANNEL].unsubscribe(this.subscriptionId);
              }),
              (ThemedComponent.prototype.render = function render() {
                return createElement
                  ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
                      ComponentToTheme,
                      _extends({}, this.props, this.state)
                    )
                  : ComponentToTheme.call(this, _extends({}, this.props, this.state), this.context);
              }),
              ThemedComponent
            );
          })(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);
        ThemedComponent.propTypes = { theme: _PropTypes.object };
        var defaultContextTypes = (((_defaultContextTypes = {})[CHANNEL] = _PropTypes.object), _defaultContextTypes),
          userDefinedContextTypes = null;
        return (
          Object.defineProperty(ThemedComponent, 'contextTypes', {
            enumerable: !0,
            configurable: !0,
            set: function set$$1(value) {
              userDefinedContextTypes = value;
            },
            get: function get$$1() {
              return userDefinedContextTypes
                ? _extends({}, defaultContextTypes, userDefinedContextTypes)
                : defaultContextTypes;
            },
          }),
          ThemedComponent
        );
      }
      var isFunction_1 = function isFunction(fn) {
          var string = toString.call(fn);
          return (
            '[object Function]' === string ||
            ('function' == typeof fn && '[object RegExp]' !== string) ||
            ('undefined' != typeof window &&
              (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt))
          );
        },
        toString = Object.prototype.toString;
      function isObjectObject(o) {
        return (
          !0 ===
            (function isObject(val) {
              return null != val && 'object' == typeof val && !1 === Array.isArray(val);
            })(o) && '[object Object]' === Object.prototype.toString.call(o)
        );
      }
      var _ThemeProvider$childC, _ThemeProvider$contex;
      var ThemeProvider = (function (_React$Component) {
        function ThemeProvider() {
          var _temp, _this;
          classCallCheck(this, ThemeProvider);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return (
            (_temp = _this = possibleConstructorReturn(
              this,
              _React$Component.call.apply(_React$Component, [this].concat(args))
            )),
            (_this.setOuterTheme = function (theme) {
              (_this.outerTheme = theme), void 0 !== _this.broadcast && _this.publishTheme();
            }),
            possibleConstructorReturn(_this, _temp)
          );
        }
        return (
          inherits(ThemeProvider, _React$Component),
          (ThemeProvider.prototype.getTheme = function getTheme(passedTheme) {
            var theme = passedTheme || this.props.theme;
            if (isFunction_1(theme)) {
              var mergedTheme = theme(this.outerTheme);
              if (
                !(function isPlainObject(o) {
                  var ctor, prot;
                  return (
                    !1 !== isObjectObject(o) &&
                    'function' == typeof (ctor = o.constructor) &&
                    !1 !== isObjectObject((prot = ctor.prototype)) &&
                    !1 !== prot.hasOwnProperty('isPrototypeOf')
                  );
                })(mergedTheme)
              )
                throw new Error(
                  '[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!'
                );
              return mergedTheme;
            }
            return _extends({}, this.outerTheme, theme);
          }),
          (ThemeProvider.prototype.getChildContext = function getChildContext() {
            var _ref;
            return ((_ref = {})[CHANNEL] = this.broadcast), _ref;
          }),
          (ThemeProvider.prototype.publishTheme = function publishTheme(theme) {
            this.broadcast.setState(this.getTheme(theme));
          }),
          (ThemeProvider.prototype.componentDidMount = function componentDidMount() {
            this.context[CHANNEL] && (this.subscriptionId = this.context[CHANNEL].subscribe(this.setOuterTheme));
          }),
          (ThemeProvider.prototype.componentWillMount = function componentWillMount() {
            this.context[CHANNEL] && this.setOuterTheme(this.context[CHANNEL].getState()),
              (this.broadcast = (function createBroadcast(initialState) {
                var listeners = {},
                  id = 1,
                  _state = initialState;
                return {
                  getState: function getState() {
                    return _state;
                  },
                  setState: function setState(state) {
                    _state = state;
                    for (var keys = Object.keys(listeners), i = 0, len = keys.length; i < len; i++)
                      listeners[keys[i]] && listeners[keys[i]](state);
                  },
                  subscribe: function subscribe(listener) {
                    if ('function' != typeof listener) throw new Error('listener must be a function.');
                    var currentId = id;
                    return (listeners[currentId] = listener), (id += 1), currentId;
                  },
                  unsubscribe: function unsubscribe(id) {
                    listeners[id] = void 0;
                  },
                };
              })(this.getTheme(this.props.theme)));
          }),
          (ThemeProvider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            this.props.theme !== nextProps.theme && this.publishTheme(nextProps.theme);
          }),
          (ThemeProvider.prototype.componentWillUnmount = function componentWillUnmount() {
            this.subscriptionId && this.context[CHANNEL].unsubscribe(this.subscriptionId);
          }),
          (ThemeProvider.prototype.render = function render() {
            return this.props.children
              ? react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.only(this.props.children)
              : null;
          }),
          ThemeProvider
        );
      })(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);
      function extractGlamorStyles(className) {
        var glamorlessClassName = [],
          glamorStyles = [];
        return (
          className
            .toString()
            .split(' ')
            .forEach(function (name) {
              if (void 0 === glamor__WEBPACK_IMPORTED_MODULE_1__.styleSheet.registered[name.substring(4)])
                glamorlessClassName.push(name);
              else {
                var style = (function buildGlamorSrcFromClassName(className) {
                  var _ref;
                  return ((_ref = {})['data-' + className] = ''), _ref;
                })(name);
                glamorStyles.push(style);
              }
            }),
          { glamorlessClassName, glamorStyles }
        );
      }
      function getGlamorClassName(_ref2) {
        var styles = _ref2.styles,
          props = _ref2.props,
          cssOverrides = _ref2.cssOverrides,
          cssProp = _ref2.cssProp,
          context = _ref2.context,
          _handleStyles =
            (_ref2.displayName,
            (function handleStyles(styles, props, context) {
              for (var current = void 0, mappedArgs = [], nonGlamorClassNames = [], i = 0; i < styles.length; i++) {
                for (current = styles[i]; 'function' == typeof current; ) current = current(props, context);
                if ('string' == typeof current) {
                  var _extractGlamorStyles = extractGlamorStyles(current),
                    glamorStyles = _extractGlamorStyles.glamorStyles,
                    glamorlessClassName = _extractGlamorStyles.glamorlessClassName;
                  mappedArgs.push.apply(mappedArgs, glamorStyles),
                    nonGlamorClassNames.push.apply(nonGlamorClassNames, glamorlessClassName);
                } else if (Array.isArray(current)) {
                  var recursed = handleStyles(current, props, context);
                  mappedArgs.push.apply(mappedArgs, recursed.mappedArgs),
                    nonGlamorClassNames.push.apply(nonGlamorClassNames, recursed.nonGlamorClassNames);
                } else mappedArgs.push(current);
              }
              return { mappedArgs, nonGlamorClassNames };
            })([].concat(styles, [props.className, cssOverrides, cssProp]), props, context)),
          mappedArgs = _handleStyles.mappedArgs,
          nonGlamorClassNames = _handleStyles.nonGlamorClassNames,
          devRules = null;
        return (
          glamor__WEBPACK_IMPORTED_MODULE_1__.css.apply(void 0, [devRules].concat(mappedArgs)).toString() +
          ' ' +
          nonGlamorClassNames.join(' ').trim()
        ).trim();
      }
      function getPropsToApply(propsToApply, accumulator, props, context) {
        return (
          propsToApply.forEach(function (propsToApplyItem) {
            return 'function' == typeof propsToApplyItem
              ? Object.assign(accumulator, propsToApplyItem(Object.assign({}, accumulator, props), context))
              : Array.isArray(propsToApplyItem)
              ? Object.assign(accumulator, getPropsToApply(propsToApplyItem, accumulator, props, context))
              : Object.assign(accumulator, propsToApplyItem);
          }),
          Object.assign(accumulator, props)
        );
      }
      function arrayify() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return Array.isArray(x) ? x : [x];
      }
      function when(comp, prop) {
        return comp ? comp.concat(prop) : prop;
      }
      function getRootEl(comp) {
        return comp.rootEl ? comp.rootEl : comp.comp || comp;
      }
      function getDisplayName(comp) {
        return 'string' == typeof comp ? comp : comp.displayName || comp.name || 'unknown';
      }
      function monadic(fn, cache, serializer, arg) {
        var cacheKey = (function isPrimitive(value) {
            return null == value || 'number' == typeof value || 'boolean' == typeof value;
          })(arg)
            ? arg
            : serializer(arg),
          computedValue = cache.get(cacheKey);
        return (
          void 0 === computedValue && ((computedValue = fn.call(this, arg)), cache.set(cacheKey, computedValue)),
          computedValue
        );
      }
      function variadic(fn, cache, serializer) {
        var args = Array.prototype.slice.call(arguments, 3),
          cacheKey = serializer(args),
          computedValue = cache.get(cacheKey);
        return (
          void 0 === computedValue && ((computedValue = fn.apply(this, args)), cache.set(cacheKey, computedValue)),
          computedValue
        );
      }
      function assemble(fn, context, strategy, cache, serialize) {
        return strategy.bind(context, fn, cache, serialize);
      }
      function strategyDefault(fn, options) {
        return assemble(fn, this, 1 === fn.length ? monadic : variadic, options.cache.create(), options.serializer);
      }
      function serializerDefault() {
        return JSON.stringify(arguments);
      }
      function ObjectWithoutPrototypeCache() {
        this.cache = Object.create(null);
      }
      (ThemeProvider.childContextTypes =
        (((_ThemeProvider$childC = {})[CHANNEL] = _PropTypes.object.isRequired), _ThemeProvider$childC)),
        (ThemeProvider.contextTypes =
          (((_ThemeProvider$contex = {})[CHANNEL] = _PropTypes.object), _ThemeProvider$contex)),
        (ThemeProvider.propTypes = {
          theme: _PropTypes.oneOfType([_PropTypes.object, _PropTypes.func]).isRequired,
          children: _PropTypes.node,
        }),
        (ObjectWithoutPrototypeCache.prototype.has = function (key) {
          return key in this.cache;
        }),
        (ObjectWithoutPrototypeCache.prototype.get = function (key) {
          return this.cache[key];
        }),
        (ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
          this.cache[key] = value;
        });
      var cacheDefault = {
          create: function create() {
            return new ObjectWithoutPrototypeCache();
          },
        },
        src = function memoize(fn, options) {
          var cache = options && options.cache ? options.cache : cacheDefault,
            serializer = options && options.serializer ? options.serializer : serializerDefault;
          return (options && options.strategy ? options.strategy : strategyDefault)(fn, { cache, serializer });
        },
        strategies = {
          variadic: function strategyVariadic(fn, options) {
            return assemble(fn, this, variadic, options.cache.create(), options.serializer);
          },
          monadic: function strategyMonadic(fn, options) {
            return assemble(fn, this, monadic, options.cache.create(), options.serializer);
          },
        };
      src.strategies = strategies;
      var a = ['coords', 'download', 'href', 'name', 'rel', 'shape', 'target', 'type', 'onClick'],
        abbr = ['title'],
        applet = ['alt', 'height', 'name', 'width'],
        area = ['alt', 'coords', 'download', 'href', 'rel', 'shape', 'target', 'type'],
        audio = ['controls', 'loop', 'muted', 'preload', 'src'],
        base = ['href', 'target'],
        basefont = ['size'],
        bdo = ['dir'],
        blockquote = ['cite'],
        button = ['disabled', 'form', 'name', 'type', 'value'],
        canvas = ['height', 'width'],
        col = ['span', 'width'],
        colgroup = ['span', 'width'],
        data = ['value'],
        del = ['cite'],
        details = ['open'],
        dfn = ['title'],
        dialog = ['open'],
        embed = ['height', 'src', 'type', 'width'],
        fieldset = ['disabled', 'form', 'name'],
        font = ['size'],
        form = ['accept', 'action', 'method', 'name', 'target', 'onChange', 'onInput', 'onInvalid', 'onSubmit'],
        frame = ['name', 'scrolling', 'src'],
        frameset = ['cols', 'rows'],
        head = ['profile'],
        hr = ['size', 'width'],
        html = ['manifest'],
        iframe = ['height', 'name', 'sandbox', 'scrolling', 'src', 'width'],
        img = ['alt', 'height', 'name', 'sizes', 'src', 'width'],
        input = [
          'accept',
          'alt',
          'autoCapitalize',
          'autoCorrect',
          'autoSave',
          'checked',
          'defaultChecked',
          'defaultValue',
          'disabled',
          'form',
          'height',
          'list',
          'max',
          'min',
          'multiple',
          'name',
          'onChange',
          'pattern',
          'placeholder',
          'required',
          'results',
          'size',
          'src',
          'step',
          'title',
          'type',
          'value',
          'width',
        ],
        ins = ['cite'],
        keygen = ['challenge', 'disabled', 'form', 'name'],
        label = ['form'],
        li = ['type', 'value'],
        link = ['color', 'href', 'integrity', 'media', 'nonce', 'rel', 'scope', 'sizes', 'target', 'title', 'type'],
        map = ['name'],
        meta = ['content', 'name'],
        meter = ['high', 'low', 'max', 'min', 'optimum', 'value'],
        object = ['data', 'form', 'height', 'name', 'type', 'width'],
        ol = ['reversed', 'start', 'type'],
        optgroup = ['disabled', 'label'],
        option = ['disabled', 'label', 'selected', 'value'],
        output = ['form', 'name'],
        param = ['name', 'type', 'value'],
        pre = ['width'],
        progress = ['max', 'value'],
        q = ['cite'],
        script = ['async', 'defer', 'integrity', 'nonce', 'src', 'type'],
        select = ['defaultValue', 'disabled', 'form', 'multiple', 'name', 'onChange', 'required', 'size', 'value'],
        slot = ['name'],
        source = ['media', 'sizes', 'src', 'type'],
        style = ['media', 'nonce', 'title', 'type'],
        table = ['summary', 'width'],
        td = ['headers', 'height', 'scope', 'width'],
        textarea = [
          'autoCapitalize',
          'autoCorrect',
          'cols',
          'defaultValue',
          'disabled',
          'form',
          'name',
          'onChange',
          'placeholder',
          'required',
          'rows',
          'value',
          'wrap',
        ],
        th = ['headers', 'height', 'scope', 'width'],
        track = ['default', 'kind', 'label', 'src'],
        ul = ['type'],
        video = ['controls', 'height', 'loop', 'muted', 'playsInline', 'poster', 'preload', 'src', 'width'],
        svg = [
          'accentHeight',
          'accumulate',
          'additive',
          'alignmentBaseline',
          'allowReorder',
          'alphabetic',
          'amplitude',
          'arabicForm',
          'ascent',
          'attributeName',
          'attributeType',
          'autoReverse',
          'azimuth',
          'baseFrequency',
          'baseProfile',
          'baselineShift',
          'bbox',
          'begin',
          'bias',
          'by',
          'calcMode',
          'capHeight',
          'clip',
          'clipPath',
          'clipPathUnits',
          'clipRule',
          'color',
          'colorInterpolation',
          'colorInterpolationFilters',
          'colorProfile',
          'colorRendering',
          'contentScriptType',
          'contentStyleType',
          'cursor',
          'cx',
          'cy',
          'd',
          'decelerate',
          'descent',
          'diffuseConstant',
          'direction',
          'display',
          'divisor',
          'dominantBaseline',
          'dur',
          'dx',
          'dy',
          'edgeMode',
          'elevation',
          'enableBackground',
          'end',
          'exponent',
          'externalResourcesRequired',
          'fill',
          'fillOpacity',
          'fillRule',
          'filter',
          'filterRes',
          'filterUnits',
          'floodColor',
          'floodOpacity',
          'focusable',
          'fontFamily',
          'fontSize',
          'fontSizeAdjust',
          'fontStretch',
          'fontStyle',
          'fontVariant',
          'fontWeight',
          'format',
          'from',
          'fx',
          'fy',
          'g1',
          'g2',
          'glyphName',
          'glyphOrientationHorizontal',
          'glyphOrientationVertical',
          'glyphRef',
          'gradientTransform',
          'gradientUnits',
          'hanging',
          'height',
          'horizAdvX',
          'horizOriginX',
          'ideographic',
          'imageRendering',
          'in',
          'in2',
          'intercept',
          'k',
          'k1',
          'k2',
          'k3',
          'k4',
          'kernelMatrix',
          'kernelUnitLength',
          'kerning',
          'keyPoints',
          'keySplines',
          'keyTimes',
          'lengthAdjust',
          'letterSpacing',
          'lightingColor',
          'limitingConeAngle',
          'local',
          'markerEnd',
          'markerHeight',
          'markerMid',
          'markerStart',
          'markerUnits',
          'markerWidth',
          'mask',
          'maskContentUnits',
          'maskUnits',
          'mathematical',
          'mode',
          'numOctaves',
          'offset',
          'opacity',
          'operator',
          'order',
          'orient',
          'orientation',
          'origin',
          'overflow',
          'overlinePosition',
          'overlineThickness',
          'paintOrder',
          'panose1',
          'pathLength',
          'patternContentUnits',
          'patternTransform',
          'patternUnits',
          'pointerEvents',
          'points',
          'pointsAtX',
          'pointsAtY',
          'pointsAtZ',
          'preserveAlpha',
          'preserveAspectRatio',
          'primitiveUnits',
          'r',
          'radius',
          'refX',
          'refY',
          'renderingIntent',
          'repeatCount',
          'repeatDur',
          'requiredExtensions',
          'requiredFeatures',
          'restart',
          'result',
          'rotate',
          'rx',
          'ry',
          'scale',
          'seed',
          'shapeRendering',
          'slope',
          'spacing',
          'specularConstant',
          'specularExponent',
          'speed',
          'spreadMethod',
          'startOffset',
          'stdDeviation',
          'stemh',
          'stemv',
          'stitchTiles',
          'stopColor',
          'stopOpacity',
          'strikethroughPosition',
          'strikethroughThickness',
          'string',
          'stroke',
          'strokeDasharray',
          'strokeDashoffset',
          'strokeLinecap',
          'strokeLinejoin',
          'strokeMiterlimit',
          'strokeOpacity',
          'strokeWidth',
          'surfaceScale',
          'systemLanguage',
          'tableValues',
          'targetX',
          'targetY',
          'textAnchor',
          'textDecoration',
          'textLength',
          'textRendering',
          'to',
          'transform',
          'u1',
          'u2',
          'underlinePosition',
          'underlineThickness',
          'unicode',
          'unicodeBidi',
          'unicodeRange',
          'unitsPerEm',
          'vAlphabetic',
          'vHanging',
          'vIdeographic',
          'vMathematical',
          'values',
          'vectorEffect',
          'version',
          'vertAdvY',
          'vertOriginX',
          'vertOriginY',
          'viewBox',
          'viewTarget',
          'visibility',
          'width',
          'widths',
          'wordSpacing',
          'writingMode',
          'x',
          'x1',
          'x2',
          'xChannelSelector',
          'xHeight',
          'xlinkActuate',
          'xlinkArcrole',
          'xlinkHref',
          'xlinkRole',
          'xlinkShow',
          'xlinkTitle',
          'xlinkType',
          'xmlBase',
          'xmlLang',
          'xmlSpace',
          'xmlns',
          'xmlnsXlink',
          'y',
          'y1',
          'y2',
          'yChannelSelector',
          'z',
          'zoomAndPan',
        ],
        elements = {
          html: [
            'a',
            'abbr',
            'address',
            'area',
            'article',
            'aside',
            'audio',
            'b',
            'base',
            'bdi',
            'bdo',
            'blockquote',
            'body',
            'br',
            'button',
            'canvas',
            'caption',
            'cite',
            'code',
            'col',
            'colgroup',
            'data',
            'datalist',
            'dd',
            'del',
            'details',
            'dfn',
            'dialog',
            'div',
            'dl',
            'dt',
            'em',
            'embed',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'head',
            'header',
            'hgroup',
            'hr',
            'html',
            'i',
            'iframe',
            'img',
            'input',
            'ins',
            'kbd',
            'keygen',
            'label',
            'legend',
            'li',
            'link',
            'main',
            'map',
            'mark',
            'math',
            'menu',
            'menuitem',
            'meta',
            'meter',
            'nav',
            'noscript',
            'object',
            'ol',
            'optgroup',
            'option',
            'output',
            'p',
            'param',
            'picture',
            'pre',
            'progress',
            'q',
            'rb',
            'rp',
            'rt',
            'rtc',
            'ruby',
            's',
            'samp',
            'script',
            'section',
            'select',
            'slot',
            'small',
            'source',
            'span',
            'strong',
            'style',
            'sub',
            'summary',
            'sup',
            'svg',
            'table',
            'tbody',
            'td',
            'template',
            'textarea',
            'tfoot',
            'th',
            'thead',
            'time',
            'title',
            'tr',
            'track',
            'u',
            'ul',
            'var',
            'video',
            'wbr',
          ],
          svg: [
            'a',
            'altGlyph',
            'altGlyphDef',
            'altGlyphItem',
            'animate',
            'animateColor',
            'animateMotion',
            'animateTransform',
            'circle',
            'clipPath',
            'color-profile',
            'cursor',
            'defs',
            'desc',
            'ellipse',
            'feBlend',
            'feColorMatrix',
            'feComponentTransfer',
            'feComposite',
            'feConvolveMatrix',
            'feDiffuseLighting',
            'feDisplacementMap',
            'feDistantLight',
            'feFlood',
            'feFuncA',
            'feFuncB',
            'feFuncG',
            'feFuncR',
            'feGaussianBlur',
            'feImage',
            'feMerge',
            'feMergeNode',
            'feMorphology',
            'feOffset',
            'fePointLight',
            'feSpecularLighting',
            'feSpotLight',
            'feTile',
            'feTurbulence',
            'filter',
            'font',
            'font-face',
            'font-face-format',
            'font-face-name',
            'font-face-src',
            'font-face-uri',
            'foreignObject',
            'g',
            'glyph',
            'glyphRef',
            'hkern',
            'image',
            'line',
            'linearGradient',
            'marker',
            'mask',
            'metadata',
            'missing-glyph',
            'mpath',
            'path',
            'pattern',
            'polygon',
            'polyline',
            'radialGradient',
            'rect',
            'script',
            'set',
            'stop',
            'style',
            'svg',
            'switch',
            'symbol',
            'text',
            'textPath',
            'title',
            'tref',
            'tspan',
            'use',
            'view',
            'vkern',
          ],
        },
        reactHtmlAttributes = {
          a,
          abbr,
          applet,
          area,
          audio,
          base,
          basefont,
          bdo,
          blockquote,
          button,
          canvas,
          col,
          colgroup,
          data,
          del,
          details,
          dfn,
          dialog,
          embed,
          fieldset,
          font,
          form,
          frame,
          frameset,
          head,
          hr,
          html,
          iframe,
          img,
          input,
          ins,
          keygen,
          label,
          li,
          link,
          map,
          meta,
          meter,
          object,
          ol,
          optgroup,
          option,
          output,
          param,
          pre,
          progress,
          q,
          script,
          select,
          slot,
          source,
          style,
          table,
          td,
          textarea,
          th,
          track,
          ul,
          video,
          svg,
          elements,
          '*': [
            'about',
            'acceptCharset',
            'accessKey',
            'allowFullScreen',
            'allowTransparency',
            'autoComplete',
            'autoFocus',
            'autoPlay',
            'capture',
            'cellPadding',
            'cellSpacing',
            'charSet',
            'classID',
            'className',
            'colSpan',
            'contentEditable',
            'contextMenu',
            'crossOrigin',
            'dangerouslySetInnerHTML',
            'datatype',
            'dateTime',
            'dir',
            'draggable',
            'encType',
            'formAction',
            'formEncType',
            'formMethod',
            'formNoValidate',
            'formTarget',
            'frameBorder',
            'hidden',
            'hrefLang',
            'htmlFor',
            'httpEquiv',
            'icon',
            'id',
            'inlist',
            'inputMode',
            'is',
            'itemID',
            'itemProp',
            'itemRef',
            'itemScope',
            'itemType',
            'keyParams',
            'keyType',
            'lang',
            'marginHeight',
            'marginWidth',
            'maxLength',
            'mediaGroup',
            'minLength',
            'noValidate',
            'prefix',
            'property',
            'radioGroup',
            'readOnly',
            'resource',
            'role',
            'rowSpan',
            'scoped',
            'seamless',
            'security',
            'spellCheck',
            'srcDoc',
            'srcLang',
            'srcSet',
            'style',
            'suppressContentEditableWarning',
            'tabIndex',
            'title',
            'typeof',
            'unselectable',
            'useMap',
            'vocab',
            'wmode',
          ],
        },
        reactHtmlAttributes$2 = (function getCjsExportFromNamespace(n) {
          return (n && n.default) || n;
        })(
          Object.freeze({
            a,
            abbr,
            applet,
            area,
            audio,
            base,
            basefont,
            bdo,
            blockquote,
            button,
            canvas,
            col,
            colgroup,
            data,
            del,
            details,
            dfn,
            dialog,
            embed,
            fieldset,
            font,
            form,
            frame,
            frameset,
            head,
            hr,
            html,
            iframe,
            img,
            input,
            ins,
            keygen,
            label,
            li,
            link,
            map,
            meta,
            meter,
            object,
            ol,
            optgroup,
            option,
            output,
            param,
            pre,
            progress,
            q,
            script,
            select,
            slot,
            source,
            style,
            table,
            td,
            textarea,
            th,
            track,
            ul,
            video,
            svg,
            elements,
            default: reactHtmlAttributes,
          })
        ),
        reactHTMLAttributes = (function unwrapExports(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
        })(
          (function createCommonjsModule(fn, module) {
            return fn((module = { exports: {} }), module.exports), module.exports;
          })(function (module, exports) {
            Object.defineProperty(exports, '__esModule', { value: !0 }),
              (exports.default = reactHtmlAttributes$2),
              (module.exports = reactHtmlAttributes$2);
          })
        ),
        reactProps = [
          'children',
          'dangerouslySetInnerHTML',
          'key',
          'ref',
          'autoFocus',
          'defaultValue',
          'valueLink',
          'defaultChecked',
          'checkedLink',
          'innerHTML',
          'suppressContentEditableWarning',
          'onFocusIn',
          'onFocusOut',
          'className',
          'onCopy',
          'onCut',
          'onPaste',
          'onCompositionEnd',
          'onCompositionStart',
          'onCompositionUpdate',
          'onKeyDown',
          'onKeyPress',
          'onKeyUp',
          'onFocus',
          'onBlur',
          'onChange',
          'onInput',
          'onInvalid',
          'onSubmit',
          'onClick',
          'onContextMenu',
          'onDoubleClick',
          'onDrag',
          'onDragEnd',
          'onDragEnter',
          'onDragExit',
          'onDragLeave',
          'onDragOver',
          'onDragStart',
          'onDrop',
          'onMouseDown',
          'onMouseEnter',
          'onMouseLeave',
          'onMouseMove',
          'onMouseOut',
          'onMouseOver',
          'onMouseUp',
          'onSelect',
          'onTouchCancel',
          'onTouchEnd',
          'onTouchMove',
          'onTouchStart',
          'onScroll',
          'onWheel',
          'onAbort',
          'onCanPlay',
          'onCanPlayThrough',
          'onDurationChange',
          'onEmptied',
          'onEncrypted',
          'onEnded',
          'onError',
          'onLoadedData',
          'onLoadedMetadata',
          'onLoadStart',
          'onPause',
          'onPlay',
          'onPlaying',
          'onProgress',
          'onRateChange',
          'onSeeked',
          'onSeeking',
          'onStalled',
          'onSuspend',
          'onTimeUpdate',
          'onVolumeChange',
          'onWaiting',
          'onLoad',
          'onAnimationStart',
          'onAnimationEnd',
          'onAnimationIteration',
          'onTransitionEnd',
          'onCopyCapture',
          'onCutCapture',
          'onPasteCapture',
          'onCompositionEndCapture',
          'onCompositionStartCapture',
          'onCompositionUpdateCapture',
          'onKeyDownCapture',
          'onKeyPressCapture',
          'onKeyUpCapture',
          'onFocusCapture',
          'onBlurCapture',
          'onChangeCapture',
          'onInputCapture',
          'onSubmitCapture',
          'onClickCapture',
          'onContextMenuCapture',
          'onDoubleClickCapture',
          'onDragCapture',
          'onDragEndCapture',
          'onDragEnterCapture',
          'onDragExitCapture',
          'onDragLeaveCapture',
          'onDragOverCapture',
          'onDragStartCapture',
          'onDropCapture',
          'onMouseDownCapture',
          'onMouseEnterCapture',
          'onMouseLeaveCapture',
          'onMouseMoveCapture',
          'onMouseOutCapture',
          'onMouseOverCapture',
          'onMouseUpCapture',
          'onSelectCapture',
          'onTouchCancelCapture',
          'onTouchEndCapture',
          'onTouchMoveCapture',
          'onTouchStartCapture',
          'onScrollCapture',
          'onWheelCapture',
          'onAbortCapture',
          'onCanPlayCapture',
          'onCanPlayThroughCapture',
          'onDurationChangeCapture',
          'onEmptiedCapture',
          'onEncryptedCapture',
          'onEndedCapture',
          'onErrorCapture',
          'onLoadedDataCapture',
          'onLoadedMetadataCapture',
          'onLoadStartCapture',
          'onPauseCapture',
          'onPlayCapture',
          'onPlayingCapture',
          'onProgressCapture',
          'onRateChangeCapture',
          'onSeekedCapture',
          'onSeekingCapture',
          'onStalledCapture',
          'onSuspendCapture',
          'onTimeUpdateCapture',
          'onVolumeChangeCapture',
          'onWaitingCapture',
          'onLoadCapture',
          'onAnimationStartCapture',
          'onAnimationEndCapture',
          'onAnimationIterationCapture',
          'onTransitionEndCapture',
        ];
      var globalReactHtmlProps = reactHTMLAttributes['*'],
        supportedSVGTagNames = reactHTMLAttributes.elements.svg,
        supportedHtmlTagNames = reactHTMLAttributes.elements.html,
        cssProps = ['color', 'height', 'width'],
        isCustomAttribute = RegExp.prototype.test.bind(
          new RegExp(
            '^(data|aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'
          )
        ),
        isSvgTag = function (tagName) {
          return (
            'svg' === tagName ||
            (-1 === supportedHtmlTagNames.indexOf(tagName) && -1 !== supportedSVGTagNames.indexOf(tagName))
          );
        },
        shouldForwardProperty$1 = src(function (tagName, name) {
          return (
            'string' != typeof tagName ||
            (((function (name, tagName) {
              var elementAttributes = void 0;
              return (
                (elementAttributes = isSvgTag(tagName) ? reactHTMLAttributes.svg : reactHTMLAttributes[tagName] || []),
                -1 !== globalReactHtmlProps.indexOf(name) || -1 !== elementAttributes.indexOf(name)
              );
            })(name, tagName) ||
              (function (name) {
                return -1 !== reactProps.indexOf(name);
              })(name) ||
              isCustomAttribute(name.toLowerCase())) &&
              (!(function (name) {
                return -1 !== cssProps.indexOf(name);
              })(name) ||
                isSvgTag(tagName)))
          );
        });
      var glamorous = (function createGlamorous(splitProps) {
        return function glamorous(comp) {
          var config = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            rootEl = config.rootEl,
            displayName = config.displayName,
            shouldClassNameUpdate = config.shouldClassNameUpdate,
            _config$filterProps = config.filterProps,
            filterProps = void 0 === _config$filterProps ? [] : _config$filterProps,
            _config$forwardProps = config.forwardProps,
            forwardProps = void 0 === _config$forwardProps ? [] : _config$forwardProps,
            _config$propsAreCssOv = config.propsAreCssOverrides,
            propsAreCssOverrides = void 0 === _config$propsAreCssOv ? comp.propsAreCssOverrides : _config$propsAreCssOv,
            basePropsToApply = config.withProps;
          return Object.assign(glamorousComponentFactory, { withConfig }), glamorousComponentFactory;
          function withConfig(newConfig) {
            return glamorous(comp, _extends({}, config, newConfig));
          }
          function glamorousComponentFactory() {
            for (var _len = arguments.length, styles = Array(_len), _key = 0; _key < _len; _key++)
              styles[_key] = arguments[_key];
            var GlamorousComponent = withTheme(
              function (props, context) {
                var updateClassName = shouldUpdate(
                  (props = getPropsToApply(GlamorousComponent.propsToApply, {}, props, context)),
                  context,
                  this.previous
                );
                shouldClassNameUpdate && (this.previous = { props, context });
                var _splitProps = splitProps(props, GlamorousComponent),
                  toForward = _splitProps.toForward,
                  cssOverrides = _splitProps.cssOverrides,
                  cssProp = _splitProps.cssProp;
                return (
                  (this.className = updateClassName
                    ? getGlamorClassName({
                        styles: GlamorousComponent.styles,
                        props,
                        cssOverrides,
                        cssProp,
                        context,
                        displayName: GlamorousComponent.displayName,
                      })
                    : this.className),
                  react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
                    GlamorousComponent.comp,
                    _extends({ ref: 'innerRef' in toForward ? void 0 : props.innerRef }, toForward, {
                      className: this.className,
                    })
                  )
                );
              },
              { noWarn: !0, createElement: !1 }
            );
            function shouldUpdate(props, context, previous) {
              if (!shouldClassNameUpdate) return !0;
              var update = !0;
              return (
                previous && (shouldClassNameUpdate(previous.props, props, previous.context, context) || (update = !1)),
                update
              );
            }
            return (
              (GlamorousComponent.propTypes = {
                className: _PropTypes.oneOfType([_PropTypes.string, _PropTypes.object]),
                cssOverrides: _PropTypes.object,
                innerRef: _PropTypes.oneOfType([_PropTypes.func, _PropTypes.object]),
                glam: _PropTypes.object,
              }),
              Object.assign(
                GlamorousComponent,
                getGlamorousComponentMetadata({
                  comp,
                  styles,
                  rootEl,
                  filterProps,
                  forwardProps,
                  displayName,
                  propsToApply: basePropsToApply,
                }),
                {
                  isGlamorousComponent: !0,
                  propsAreCssOverrides,
                  withComponent: function (newComp) {
                    var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      fwp = GlamorousComponent.forwardProps,
                      flp = GlamorousComponent.filterProps,
                      componentProperties = objectWithoutProperties(GlamorousComponent, [
                        'forwardProps',
                        'filterProps',
                      ]);
                    return glamorous(
                      _extends({}, componentProperties, { comp: newComp, rootEl: getRootEl(newComp) }),
                      _extends({ forwardProps: fwp, filterProps: flp }, options)
                    )();
                  },
                  withProps: function () {
                    for (var _len2 = arguments.length, propsToApply = Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
                      propsToApply[_key2] = arguments[_key2];
                    return glamorous(GlamorousComponent, { withProps: propsToApply })();
                  },
                  withConfig,
                }
              ),
              GlamorousComponent
            );
          }
        };
        function getGlamorousComponentMetadata(_ref) {
          var comp = _ref.comp,
            styles = _ref.styles,
            rootEl = _ref.rootEl,
            filterProps = _ref.filterProps,
            forwardProps = _ref.forwardProps,
            displayName = _ref.displayName,
            basePropsToApply = _ref.propsToApply,
            componentsComp = comp.comp ? comp.comp : comp,
            propsToApply = comp.propsToApply
              ? [].concat(comp.propsToApply, arrayify(basePropsToApply))
              : arrayify(basePropsToApply);
          return {
            styles: when(comp.styles, styles),
            comp: componentsComp,
            rootEl: rootEl || getRootEl(comp),
            forwardProps: when(comp.forwardProps, forwardProps),
            filterProps: when(comp.filterProps, filterProps),
            displayName: displayName || 'glamorous(' + getDisplayName(comp) + ')',
            propsToApply,
          };
        }
      })(function splitProps(_ref, _ref2) {
        var propsAreCssOverrides = _ref2.propsAreCssOverrides,
          rootEl = _ref2.rootEl,
          filterProps = _ref2.filterProps,
          forwardProps = _ref2.forwardProps,
          cssProp = _ref.css,
          innerRef = _ref.innerRef,
          rest =
            (_ref.theme,
            _ref.className,
            _ref.glam,
            objectWithoutProperties(_ref, ['css', 'innerRef', 'theme', 'className', 'glam']));
        void 0 !== innerRef && -1 !== forwardProps.indexOf('innerRef') && (rest.innerRef = innerRef);
        var returnValue = { toForward: {}, cssProp, cssOverrides: {} };
        return propsAreCssOverrides || 'string' == typeof rootEl || 0 !== filterProps.length
          ? Object.keys(rest).reduce(function (split, propName) {
              return (
                -1 !== filterProps.indexOf(propName) ||
                  (-1 !== forwardProps.indexOf(propName) || shouldForwardProperty$1(rootEl, propName)
                    ? (split.toForward[propName] = rest[propName])
                    : propsAreCssOverrides && (split.cssOverrides[propName] = rest[propName])),
                split
              );
            }, returnValue)
          : ((returnValue.toForward = rest), returnValue);
      });
      Object.assign(
        glamorous,
        domElements.reduce(function (getters, tag) {
          return (getters[tag] = glamorous(tag)), getters;
        }, {})
      ),
        Object.assign(
          glamorous,
          domElements.reduce(function (comps, tag) {
            var capitalTag = (function capitalize(s) {
              return s.slice(0, 1).toUpperCase() + s.slice(1);
            })(tag);
            return (
              (comps[capitalTag] = glamorous[tag]()),
              (comps[capitalTag].displayName = 'glamorous.' + capitalTag),
              (comps[capitalTag].propsAreCssOverrides = !0),
              comps
            );
          }, {})
        ),
        (glamorous.default = glamorous);
      var A = glamorous.A,
        Abbr = glamorous.Abbr,
        Acronym = glamorous.Acronym,
        Address = glamorous.Address,
        Applet = glamorous.Applet,
        Area = glamorous.Area,
        Article = glamorous.Article,
        Aside = glamorous.Aside,
        Audio = glamorous.Audio,
        B = glamorous.B,
        Base = glamorous.Base,
        Basefont = glamorous.Basefont,
        Bdi = glamorous.Bdi,
        Bdo = glamorous.Bdo,
        Bgsound = glamorous.Bgsound,
        Big = glamorous.Big,
        Blink = glamorous.Blink,
        Blockquote = glamorous.Blockquote,
        Body = glamorous.Body,
        Br = glamorous.Br,
        Button = glamorous.Button,
        Canvas = glamorous.Canvas,
        Caption = glamorous.Caption,
        Center = glamorous.Center,
        Cite = glamorous.Cite,
        Code = glamorous.Code,
        Col = glamorous.Col,
        Colgroup = glamorous.Colgroup,
        Command = glamorous.Command,
        Content = glamorous.Content,
        Data = glamorous.Data,
        Datalist = glamorous.Datalist,
        Dd = glamorous.Dd,
        Del = glamorous.Del,
        Details = glamorous.Details,
        Dfn = glamorous.Dfn,
        Dialog = glamorous.Dialog,
        Dir = glamorous.Dir,
        Div = glamorous.Div,
        Dl = glamorous.Dl,
        Dt = glamorous.Dt,
        Element = glamorous.Element,
        Em = glamorous.Em,
        Embed = glamorous.Embed,
        Fieldset = glamorous.Fieldset,
        Figcaption = glamorous.Figcaption,
        Figure = glamorous.Figure,
        Font = glamorous.Font,
        Footer = glamorous.Footer,
        Form = glamorous.Form,
        Frame = glamorous.Frame,
        Frameset = glamorous.Frameset,
        H1 = glamorous.H1,
        H2 = glamorous.H2,
        H3 = glamorous.H3,
        H4 = glamorous.H4,
        H5 = glamorous.H5,
        H6 = glamorous.H6,
        Head = glamorous.Head,
        Header = glamorous.Header,
        Hgroup = glamorous.Hgroup,
        Hr = glamorous.Hr,
        Html = glamorous.Html,
        I = glamorous.I,
        Iframe = glamorous.Iframe,
        Image = glamorous.Image,
        Img = glamorous.Img,
        Input = glamorous.Input,
        Ins = glamorous.Ins,
        Isindex = glamorous.Isindex,
        Kbd = glamorous.Kbd,
        Keygen = glamorous.Keygen,
        Label = glamorous.Label,
        Legend = glamorous.Legend,
        Li = glamorous.Li,
        Link = glamorous.Link,
        Listing = glamorous.Listing,
        Main = glamorous.Main,
        MapTag = glamorous.Map,
        Mark = glamorous.Mark,
        Marquee = glamorous.Marquee,
        MathTag = glamorous.Math,
        Menu = glamorous.Menu,
        Menuitem = glamorous.Menuitem,
        Meta = glamorous.Meta,
        Meter = glamorous.Meter,
        Multicol = glamorous.Multicol,
        Nav = glamorous.Nav,
        Nextid = glamorous.Nextid,
        Nobr = glamorous.Nobr,
        Noembed = glamorous.Noembed,
        Noframes = glamorous.Noframes,
        Noscript = glamorous.Noscript,
        ObjectTag = glamorous.Object,
        Ol = glamorous.Ol,
        Optgroup = glamorous.Optgroup,
        Option = glamorous.Option,
        Output = glamorous.Output,
        P = glamorous.P,
        Param = glamorous.Param,
        Picture = glamorous.Picture,
        Plaintext = glamorous.Plaintext,
        Pre = glamorous.Pre,
        Progress = glamorous.Progress,
        Q = glamorous.Q,
        Rb = glamorous.Rb,
        Rbc = glamorous.Rbc,
        Rp = glamorous.Rp,
        Rt = glamorous.Rt,
        Rtc = glamorous.Rtc,
        Ruby = glamorous.Ruby,
        S = glamorous.S,
        Samp = glamorous.Samp,
        Script = glamorous.Script,
        Section = glamorous.Section,
        Select = glamorous.Select,
        Shadow = glamorous.Shadow,
        Slot = glamorous.Slot,
        Small = glamorous.Small,
        Source = glamorous.Source,
        Spacer = glamorous.Spacer,
        Span = glamorous.Span,
        Strike = glamorous.Strike,
        Strong = glamorous.Strong,
        Style = glamorous.Style,
        Sub = glamorous.Sub,
        Summary = glamorous.Summary,
        Sup = glamorous.Sup,
        Svg = glamorous.Svg,
        Table = glamorous.Table,
        Tbody = glamorous.Tbody,
        Td = glamorous.Td,
        Template = glamorous.Template,
        Textarea = glamorous.Textarea,
        Tfoot = glamorous.Tfoot,
        Th = glamorous.Th,
        Thead = glamorous.Thead,
        Time = glamorous.Time,
        Title = glamorous.Title,
        Tr = glamorous.Tr,
        Track = glamorous.Track,
        Tt = glamorous.Tt,
        U = glamorous.U,
        Ul = glamorous.Ul,
        Var = glamorous.Var,
        Video = glamorous.Video,
        Wbr = glamorous.Wbr,
        Xmp = glamorous.Xmp,
        AltGlyph = glamorous.AltGlyph,
        AltGlyphDef = glamorous.AltGlyphDef,
        AltGlyphItem = glamorous.AltGlyphItem,
        Animate = glamorous.Animate,
        AnimateColor = glamorous.AnimateColor,
        AnimateMotion = glamorous.AnimateMotion,
        AnimateTransform = glamorous.AnimateTransform,
        Animation = glamorous.Animation,
        Circle = glamorous.Circle,
        ClipPath = glamorous.ClipPath,
        ColorProfile = glamorous['Color-profile'],
        Cursor = glamorous.Cursor,
        Defs = glamorous.Defs,
        Desc = glamorous.Desc,
        Discard = glamorous.Discard,
        Ellipse = glamorous.Ellipse,
        FeBlend = glamorous.FeBlend,
        FeColorMatrix = glamorous.FeColorMatrix,
        FeComponentTransfer = glamorous.FeComponentTransfer,
        FeComposite = glamorous.FeComposite,
        FeConvolveMatrix = glamorous.FeConvolveMatrix,
        FeDiffuseLighting = glamorous.FeDiffuseLighting,
        FeDisplacementMap = glamorous.FeDisplacementMap,
        FeDistantLight = glamorous.FeDistantLight,
        FeDropShadow = glamorous.FeDropShadow,
        FeFlood = glamorous.FeFlood,
        FeFuncA = glamorous.FeFuncA,
        FeFuncB = glamorous.FeFuncB,
        FeFuncG = glamorous.FeFuncG,
        FeFuncR = glamorous.FeFuncR,
        FeGaussianBlur = glamorous.FeGaussianBlur,
        FeImage = glamorous.FeImage,
        FeMerge = glamorous.FeMerge,
        FeMergeNode = glamorous.FeMergeNode,
        FeMorphology = glamorous.FeMorphology,
        FeOffset = glamorous.FeOffset,
        FePointLight = glamorous.FePointLight,
        FeSpecularLighting = glamorous.FeSpecularLighting,
        FeSpotLight = glamorous.FeSpotLight,
        FeTile = glamorous.FeTile,
        FeTurbulence = glamorous.FeTurbulence,
        Filter = glamorous.Filter,
        FontFace = glamorous['Font-face'],
        FontFaceFormat = glamorous['Font-face-format'],
        FontFaceName = glamorous['Font-face-name'],
        FontFaceSrc = glamorous['Font-face-src'],
        FontFaceUri = glamorous['Font-face-uri'],
        ForeignObject = glamorous.ForeignObject,
        G = glamorous.G,
        Glyph = glamorous.Glyph,
        GlyphRef = glamorous.GlyphRef,
        Handler = glamorous.Handler,
        Hatch = glamorous.Hatch,
        Hatchpath = glamorous.Hatchpath,
        Hkern = glamorous.Hkern,
        Line = glamorous.Line,
        LinearGradient = glamorous.LinearGradient,
        Listener = glamorous.Listener,
        Marker = glamorous.Marker,
        Mask = glamorous.Mask,
        Mesh = glamorous.Mesh,
        Meshgradient = glamorous.Meshgradient,
        Meshpatch = glamorous.Meshpatch,
        Meshrow = glamorous.Meshrow,
        Metadata = glamorous.Metadata,
        MissingGlyph = glamorous['Missing-glyph'],
        Mpath = glamorous.Mpath,
        Path = glamorous.Path,
        Pattern = glamorous.Pattern,
        Polygon = glamorous.Polygon,
        Polyline = glamorous.Polyline,
        Prefetch = glamorous.Prefetch,
        RadialGradient = glamorous.RadialGradient,
        Rect = glamorous.Rect,
        SetTag = glamorous.Set,
        SolidColor = glamorous.SolidColor,
        Solidcolor = glamorous.Solidcolor,
        Stop = glamorous.Stop,
        Switch = glamorous.Switch,
        SymbolTag = glamorous.Symbol,
        Tbreak = glamorous.Tbreak,
        Text = glamorous.Text,
        TextArea = glamorous.TextArea,
        TextPath = glamorous.TextPath,
        Tref = glamorous.Tref,
        Tspan = glamorous.Tspan,
        Unknown = glamorous.Unknown,
        Use = glamorous.Use,
        View = glamorous.View,
        Vkern = glamorous.Vkern;
      __webpack_exports__.default = glamorous;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.processStyleName = void 0),
        (exports.createMarkupForStyles = function createMarkupForStyles(styles, component) {
          var serialized = '';
          for (var styleName in styles) {
            var isCustomProp = 0 === styleName.indexOf('--');
            if (styles.hasOwnProperty(styleName) && 'label' !== styleName) {
              var styleValue = styles[styleName];
              isCustomProp || warnValidStyle(styleName, styleValue, component),
                null != styleValue &&
                  (isCustomProp
                    ? (serialized += styleName + ':' + styleValue + ';')
                    : ((serialized += processStyleName(styleName) + ':'),
                      (serialized += (0, _dangerousStyleValue2.default)(styleName, styleValue, component) + ';')));
            }
          }
          return serialized || null;
        });
      var _camelizeStyleName2 = _interopRequireDefault(__webpack_require__(161)),
        _dangerousStyleValue2 = _interopRequireDefault(__webpack_require__(163)),
        _hyphenateStyleName2 = _interopRequireDefault(__webpack_require__(166)),
        _memoizeStringOnly2 = _interopRequireDefault(__webpack_require__(168)),
        _warning2 = _interopRequireDefault(__webpack_require__(61));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var processStyleName = (exports.processStyleName = (0, _memoizeStringOnly2.default)(
          _hyphenateStyleName2.default
        )),
        badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
        badStyleValueWithSemicolonPattern = /;\s*$/,
        warnedStyleNames = {},
        warnedStyleValues = {},
        warnedForNaNValue = !1,
        checkRenderMessage = function checkRenderMessage(owner) {
          if (owner) {
            var name = owner.getName();
            if (name) return ' Check the render method of `' + name + '`.';
          }
          return '';
        },
        warnValidStyle = function warnValidStyle(name, value, component) {
          var owner = void 0;
          component && (owner = component._currentElement._owner),
            name.indexOf('-') > -1
              ? (function warnHyphenatedStyleName(name, owner) {
                  (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) ||
                    ((warnedStyleNames[name] = !0),
                    (0, _warning2.default)(
                      !1,
                      'Unsupported style property %s. Did you mean %s?%s',
                      name,
                      (0, _camelizeStyleName2.default)(name),
                      checkRenderMessage(owner)
                    ));
                })(name, owner)
              : badVendoredStyleNamePattern.test(name)
              ? (function warnBadVendoredStyleName(name, owner) {
                  (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) ||
                    ((warnedStyleNames[name] = !0),
                    (0, _warning2.default)(
                      !1,
                      'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',
                      name,
                      name.charAt(0).toUpperCase() + name.slice(1),
                      checkRenderMessage(owner)
                    ));
                })(name, owner)
              : badStyleValueWithSemicolonPattern.test(value) &&
                (function warnStyleValueWithSemicolon(name, value, owner) {
                  (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) ||
                    ((warnedStyleValues[value] = !0),
                    (0, _warning2.default)(
                      !1,
                      'Style property values shouldn\'t contain a semicolon.%s Try "%s: %s" instead.',
                      checkRenderMessage(owner),
                      name,
                      value.replace(badStyleValueWithSemicolonPattern, '')
                    ));
                })(name, value, owner),
            'number' == typeof value &&
              isNaN(value) &&
              (function warnStyleValueIsNaN(name, value, owner) {
                warnedForNaNValue ||
                  ((warnedForNaNValue = !0),
                  (0, _warning2.default)(
                    !1,
                    '`NaN` is an invalid value for the `%s` css style property.%s',
                    name,
                    checkRenderMessage(owner)
                  ));
              })(name, 0, owner);
        };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var warning = __webpack_require__(165),
        printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          var argIndex = 0,
            message =
              'Warning: ' +
              format.replace(/%s/g, function () {
                return args[argIndex++];
              });
          'undefined' != typeof console && console.error(message);
          try {
            throw new Error(message);
          } catch (x) {}
        };
      (warning = function warning(condition, format) {
        if (void 0 === format)
          throw new Error('`warning(condition, format, ...args)` requires a warning message argument');
        if (0 !== format.indexOf('Failed Composite propType: ') && !condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++)
            args[_key2 - 2] = arguments[_key2];
          printWarning.apply(void 0, [format].concat(args));
        }
      }),
        (module.exports = warning);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function capitalizeString(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }),
        (module.exports = exports.default);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.__getTypeMismatches = exports.__logTypeMismatches = exports.__getType = exports.__valOrDefault = exports.__isEmpty = exports.__hasValue = exports.__hasValues = void 0);
      var _react = _interopRequireDefault(__webpack_require__(0)),
        _maybeBaby = _interopRequireDefault(__webpack_require__(189)),
        _components = __webpack_require__(58);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      exports.__hasValues = function __hasValues() {
        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++)
          values[_key] = arguments[_key];
        return values.every(function (value) {
          return __hasValue(value);
        });
      };
      var __hasValue = function __hasValue(val) {
        return null != val;
      };
      exports.__hasValue = __hasValue;
      exports.__isEmpty = function __isEmpty(obj) {
        return !obj || (0 === Object.keys(obj).length && obj.constructor === Object);
      };
      exports.__valOrDefault = function __valOrDefault(accessor, defaultValue) {
        return _maybeBaby.default.of(accessor).orElse(defaultValue).join();
      };
      var __getType = function __getType(instance) {
        return instance.type ? ('function' == typeof instance.type ? instance.type.name : instance.type) : 'Unknown';
      };
      exports.__getType = __getType;
      exports.__logTypeMismatches = function __logTypeMismatches(typeMismatches) {
        typeMismatches &&
          typeMismatches.forEach(function (typeMismatch) {
            console.error(
              'Expected children of "Tabs" to be of type "Tab", but found type "'.concat(__getType(typeMismatch), '"')
            );
          });
      };
      exports.__getTypeMismatches = function __getTypeMismatches(tabs) {
        return tabs
          ? tabs.filter(function (child) {
              return child.type !== _react.default.createElement(_components.Tab, null).type;
            })
          : [];
      };
    },
    function (module, exports) {
      var objectProto = Object.prototype;
      module.exports = function isPrototype(value) {
        var Ctor = value && value.constructor;
        return value === (('function' == typeof Ctor && Ctor.prototype) || objectProto);
      };
    },
    function (module, exports) {
      module.exports = function isLength(value) {
        return 'number' == typeof value && value > -1 && value % 1 == 0 && value <= 9007199254740991;
      };
    },
    function (module, exports) {
      module.exports = function (module) {
        return (
          module.webpackPolyfill ||
            ((module.deprecate = function () {}),
            (module.paths = []),
            module.children || (module.children = []),
            Object.defineProperty(module, 'loaded', {
              enumerable: !0,
              get: function () {
                return module.l;
              },
            }),
            Object.defineProperty(module, 'id', {
              enumerable: !0,
              get: function () {
                return module.i;
              },
            }),
            (module.webpackPolyfill = 1)),
          module
        );
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          for (var args = new Array(arguments.length), i = 0; i < args.length; i++) args[i] = arguments[i];
          return fn.apply(thisArg, args);
        };
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8);
      function encode(val) {
        return encodeURIComponent(val)
          .replace(/%40/gi, '@')
          .replace(/%3A/gi, ':')
          .replace(/%24/g, '$')
          .replace(/%2C/gi, ',')
          .replace(/%20/g, '+')
          .replace(/%5B/gi, '[')
          .replace(/%5D/gi, ']');
      }
      module.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) return url;
        var serializedParams;
        if (paramsSerializer) serializedParams = paramsSerializer(params);
        else if (utils.isURLSearchParams(params)) serializedParams = params.toString();
        else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            null != val &&
              (utils.isArray(val) ? (key += '[]') : (val = [val]),
              utils.forEach(val, function parseValue(v) {
                utils.isDate(v) ? (v = v.toISOString()) : utils.isObject(v) && (v = JSON.stringify(v)),
                  parts.push(encode(key) + '=' + encode(v));
              }));
          }),
            (serializedParams = parts.join('&'));
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf('#');
          -1 !== hashmarkIndex && (url = url.slice(0, hashmarkIndex)),
            (url += (-1 === url.indexOf('?') ? '?' : '&') + serializedParams);
        }
        return url;
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = function isCancel(value) {
        return !(!value || !value.__CANCEL__);
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      (function (process) {
        var utils = __webpack_require__(8),
          normalizeHeaderName = __webpack_require__(233),
          DEFAULT_CONTENT_TYPE = { 'Content-Type': 'application/x-www-form-urlencoded' };
        function setContentTypeIfUnset(headers, value) {
          !utils.isUndefined(headers) &&
            utils.isUndefined(headers['Content-Type']) &&
            (headers['Content-Type'] = value);
        }
        var defaults = {
          adapter: (function getDefaultAdapter() {
            var adapter;
            return (
              ('undefined' != typeof XMLHttpRequest ||
                (void 0 !== process && '[object process]' === Object.prototype.toString.call(process))) &&
                (adapter = __webpack_require__(71)),
              adapter
            );
          })(),
          transformRequest: [
            function transformRequest(data, headers) {
              return (
                normalizeHeaderName(headers, 'Accept'),
                normalizeHeaderName(headers, 'Content-Type'),
                utils.isFormData(data) ||
                utils.isArrayBuffer(data) ||
                utils.isBuffer(data) ||
                utils.isStream(data) ||
                utils.isFile(data) ||
                utils.isBlob(data)
                  ? data
                  : utils.isArrayBufferView(data)
                  ? data.buffer
                  : utils.isURLSearchParams(data)
                  ? (setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8'), data.toString())
                  : utils.isObject(data)
                  ? (setContentTypeIfUnset(headers, 'application/json;charset=utf-8'), JSON.stringify(data))
                  : data
              );
            },
          ],
          transformResponse: [
            function transformResponse(data) {
              if ('string' == typeof data)
                try {
                  data = JSON.parse(data);
                } catch (e) {}
              return data;
            },
          ],
          timeout: 0,
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          maxContentLength: -1,
          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          },
          headers: { common: { Accept: 'application/json, text/plain, */*' } },
        };
        utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
          defaults.headers[method] = {};
        }),
          utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
            defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
          }),
          (module.exports = defaults);
      }.call(this, __webpack_require__(232)));
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8),
        settle = __webpack_require__(234),
        buildURL = __webpack_require__(68),
        buildFullPath = __webpack_require__(236),
        parseHeaders = __webpack_require__(239),
        isURLSameOrigin = __webpack_require__(240),
        createError = __webpack_require__(72);
      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data,
            requestHeaders = config.headers;
          utils.isFormData(requestData) && delete requestHeaders['Content-Type'];
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || '',
              password = config.auth.password || '';
            requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          if (
            (request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), !0),
            (request.timeout = config.timeout),
            (request.onreadystatechange = function handleLoad() {
              if (
                request &&
                4 === request.readyState &&
                (0 !== request.status || (request.responseURL && 0 === request.responseURL.indexOf('file:')))
              ) {
                var responseHeaders =
                    'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null,
                  response = {
                    data:
                      config.responseType && 'text' !== config.responseType ? request.response : request.responseText,
                    status: request.status,
                    statusText: request.statusText,
                    headers: responseHeaders,
                    config,
                    request,
                  };
                settle(resolve, reject, response), (request = null);
              }
            }),
            (request.onabort = function handleAbort() {
              request && (reject(createError('Request aborted', config, 'ECONNABORTED', request)), (request = null));
            }),
            (request.onerror = function handleError() {
              reject(createError('Network Error', config, null, request)), (request = null);
            }),
            (request.ontimeout = function handleTimeout() {
              var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
              config.timeoutErrorMessage && (timeoutErrorMessage = config.timeoutErrorMessage),
                reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)),
                (request = null);
            }),
            utils.isStandardBrowserEnv())
          ) {
            var cookies = __webpack_require__(241),
              xsrfValue =
                (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName
                  ? cookies.read(config.xsrfCookieName)
                  : void 0;
            xsrfValue && (requestHeaders[config.xsrfHeaderName] = xsrfValue);
          }
          if (
            ('setRequestHeader' in request &&
              utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                void 0 === requestData && 'content-type' === key.toLowerCase()
                  ? delete requestHeaders[key]
                  : request.setRequestHeader(key, val);
              }),
            utils.isUndefined(config.withCredentials) || (request.withCredentials = !!config.withCredentials),
            config.responseType)
          )
            try {
              request.responseType = config.responseType;
            } catch (e) {
              if ('json' !== config.responseType) throw e;
            }
          'function' == typeof config.onDownloadProgress &&
            request.addEventListener('progress', config.onDownloadProgress),
            'function' == typeof config.onUploadProgress &&
              request.upload &&
              request.upload.addEventListener('progress', config.onUploadProgress),
            config.cancelToken &&
              config.cancelToken.promise.then(function onCanceled(cancel) {
                request && (request.abort(), reject(cancel), (request = null));
              }),
            void 0 === requestData && (requestData = null),
            request.send(requestData);
        });
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var enhanceError = __webpack_require__(235);
      module.exports = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8);
      module.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config = {},
          valueFromConfig2Keys = ['url', 'method', 'params', 'data'],
          mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'],
          defaultToConfig2Keys = [
            'baseURL',
            'url',
            'transformRequest',
            'transformResponse',
            'paramsSerializer',
            'timeout',
            'withCredentials',
            'adapter',
            'responseType',
            'xsrfCookieName',
            'xsrfHeaderName',
            'onUploadProgress',
            'onDownloadProgress',
            'maxContentLength',
            'validateStatus',
            'maxRedirects',
            'httpAgent',
            'httpsAgent',
            'cancelToken',
            'socketPath',
          ];
        utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
          void 0 !== config2[prop] && (config[prop] = config2[prop]);
        }),
          utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
            utils.isObject(config2[prop])
              ? (config[prop] = utils.deepMerge(config1[prop], config2[prop]))
              : void 0 !== config2[prop]
              ? (config[prop] = config2[prop])
              : utils.isObject(config1[prop])
              ? (config[prop] = utils.deepMerge(config1[prop]))
              : void 0 !== config1[prop] && (config[prop] = config1[prop]);
          }),
          utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
            void 0 !== config2[prop]
              ? (config[prop] = config2[prop])
              : void 0 !== config1[prop] && (config[prop] = config1[prop]);
          });
        var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys),
          otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key) {
            return -1 === axiosKeys.indexOf(key);
          });
        return (
          utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
            void 0 !== config2[prop]
              ? (config[prop] = config2[prop])
              : void 0 !== config1[prop] && (config[prop] = config1[prop]);
          }),
          config
        );
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      function Cancel(message) {
        this.message = message;
      }
      (Cancel.prototype.toString = function toString() {
        return 'Cancel' + (this.message ? ': ' + this.message : '');
      }),
        (Cancel.prototype.__CANCEL__ = !0),
        (module.exports = Cancel);
    },
    ,
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function symbolObservablePonyfill(root) {
        var result,
          Symbol = root.Symbol;
        return (
          'function' == typeof Symbol
            ? Symbol.observable
              ? (result = Symbol.observable)
              : ((result = Symbol('observable')), (Symbol.observable = result))
            : (result = '@@observable'),
          result
        );
      }
      __webpack_require__.d(__webpack_exports__, 'a', function () {
        return symbolObservablePonyfill;
      });
    },
    ,
    ,
    ,
    ,
    ,
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      (function () {
        var _assign = __webpack_require__(15),
          checkPropTypes = __webpack_require__(33),
          hasSymbol = 'function' == typeof Symbol && Symbol.for,
          REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 60103,
          REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 60106,
          REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 60107,
          REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 60108,
          REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 60114,
          REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 60109,
          REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 60110,
          REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 60111,
          REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 60112,
          REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 60113,
          REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 60120,
          REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 60115,
          REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 60116,
          REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 60121,
          REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 60117,
          REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 60118,
          REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 60119,
          MAYBE_ITERATOR_SYMBOL = 'function' == typeof Symbol && Symbol.iterator;
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || 'object' != typeof maybeIterable) return null;
          var maybeIterator =
            (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) || maybeIterable['@@iterator'];
          return 'function' == typeof maybeIterator ? maybeIterator : null;
        }
        var ReactCurrentDispatcher = { current: null },
          ReactCurrentOwner = { current: null },
          BEFORE_SLASH_RE = /^(.*)[\\\/]/;
        function getComponentName(type) {
          if (null == type) return null;
          if (
            ('number' == typeof type.tag &&
              error(
                'Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.'
              ),
            'function' == typeof type)
          )
            return type.displayName || type.name || null;
          if ('string' == typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return 'Fragment';
            case REACT_PORTAL_TYPE:
              return 'Portal';
            case REACT_PROFILER_TYPE:
              return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
              return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
              return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
              return 'SuspenseList';
          }
          if ('object' == typeof type)
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return 'Context.Consumer';
              case REACT_PROVIDER_TYPE:
                return 'Context.Provider';
              case REACT_FORWARD_REF_TYPE:
                return (function getWrappedName(outerType, innerType, wrapperName) {
                  var functionName = innerType.displayName || innerType.name || '';
                  return (
                    outerType.displayName ||
                    ('' !== functionName ? wrapperName + '(' + functionName + ')' : wrapperName)
                  );
                })(type, type.render, 'ForwardRef');
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type.render);
              case REACT_LAZY_TYPE:
                var resolvedThenable = (function refineResolvedLazyComponent(lazyComponent) {
                  return 1 === lazyComponent._status ? lazyComponent._result : null;
                })(type);
                if (resolvedThenable) return getComponentName(resolvedThenable);
            }
          return null;
        }
        var ReactDebugCurrentFrame = {},
          currentlyValidatingElement = null;
        function setCurrentlyValidatingElement(element) {
          currentlyValidatingElement = element;
        }
        (ReactDebugCurrentFrame.getCurrentStack = null),
          (ReactDebugCurrentFrame.getStackAddendum = function () {
            var stack = '';
            if (currentlyValidatingElement) {
              var name = getComponentName(currentlyValidatingElement.type),
                owner = currentlyValidatingElement._owner;
              stack += (function describeComponentFrame(name, source, ownerName) {
                var sourceInfo = '';
                if (source) {
                  var path = source.fileName,
                    fileName = path.replace(BEFORE_SLASH_RE, '');
                  if (/^index\./.test(fileName)) {
                    var match = path.match(BEFORE_SLASH_RE);
                    if (match) {
                      var pathBeforeSlash = match[1];
                      if (pathBeforeSlash) fileName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '') + '/' + fileName;
                    }
                  }
                  sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
                } else ownerName && (sourceInfo = ' (created by ' + ownerName + ')');
                return '\n    in ' + (name || 'Unknown') + sourceInfo;
              })(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            return impl && (stack += impl() || ''), stack;
          });
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig: { suspense: null },
          ReactCurrentOwner,
          IsSomeRendererActing: { current: !1 },
          assign: _assign,
        };
        function warn(format) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning('warn', format, args);
        }
        function error(format) {
          for (
            var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;
            _key2 < _len2;
            _key2++
          )
            args[_key2 - 1] = arguments[_key2];
          printWarning('error', format, args);
        }
        function printWarning(level, format, args) {
          if (
            !(
              args.length > 0 &&
              'string' == typeof args[args.length - 1] &&
              0 === args[args.length - 1].indexOf('\n    in')
            )
          ) {
            var stack = ReactSharedInternals.ReactDebugCurrentFrame.getStackAddendum();
            '' !== stack && ((format += '%s'), (args = args.concat([stack])));
          }
          var argsWithFormat = args.map(function (item) {
            return '' + item;
          });
          argsWithFormat.unshift('Warning: ' + format),
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          try {
            var argIndex = 0,
              message =
                'Warning: ' +
                format.replace(/%s/g, function () {
                  return args[argIndex++];
                });
            throw new Error(message);
          } catch (x) {}
        }
        _assign(ReactSharedInternals, { ReactDebugCurrentFrame, ReactComponentTreeHook: {} });
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          var _constructor = publicInstance.constructor,
            componentName = (_constructor && (_constructor.displayName || _constructor.name)) || 'ReactClass',
            warningKey = componentName + '.' + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] ||
            (error(
              "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
              callerName,
              componentName
            ),
            (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));
        }
        var ReactNoopUpdateQueue = {
            isMounted: function (publicInstance) {
              return !1;
            },
            enqueueForceUpdate: function (publicInstance, callback, callerName) {
              warnNoop(publicInstance, 'forceUpdate');
            },
            enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, 'replaceState');
            },
            enqueueSetState: function (publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, 'setState');
            },
          },
          emptyObject = {};
        function Component(props, context, updater) {
          (this.props = props),
            (this.context = context),
            (this.refs = emptyObject),
            (this.updater = updater || ReactNoopUpdateQueue);
        }
        Object.freeze(emptyObject),
          (Component.prototype.isReactComponent = {}),
          (Component.prototype.setState = function (partialState, callback) {
            if ('object' != typeof partialState && 'function' != typeof partialState && null != partialState)
              throw Error(
                'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
              );
            this.updater.enqueueSetState(this, partialState, callback, 'setState');
          }),
          (Component.prototype.forceUpdate = function (callback) {
            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
          });
        var deprecatedAPIs = {
            isMounted: [
              'isMounted',
              'Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.',
            ],
            replaceState: [
              'replaceState',
              'Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).',
            ],
          },
          defineDeprecationWarning = function (methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function () {
                warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
              },
            });
          };
        for (var fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        function ComponentDummy() {}
        function PureComponent(props, context, updater) {
          (this.props = props),
            (this.context = context),
            (this.refs = emptyObject),
            (this.updater = updater || ReactNoopUpdateQueue);
        }
        ComponentDummy.prototype = Component.prototype;
        var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
        (pureComponentPrototype.constructor = PureComponent),
          _assign(pureComponentPrototype, Component.prototype),
          (pureComponentPrototype.isPureReactComponent = !0);
        var specialPropKeyWarningShown,
          specialPropRefWarningShown,
          didWarnAboutStringRefs,
          hasOwnProperty = Object.prototype.hasOwnProperty,
          RESERVED_PROPS = { key: !0, ref: !0, __self: !0, __source: !0 };
        function hasValidRef(config) {
          if (hasOwnProperty.call(config, 'ref')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
            if (getter && getter.isReactWarning) return !1;
          }
          return void 0 !== config.ref;
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, 'key')) {
            var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
            if (getter && getter.isReactWarning) return !1;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function () {
            specialPropKeyWarningShown ||
              ((specialPropKeyWarningShown = !0),
              error(
                '%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)',
                displayName
              ));
          };
          (warnAboutAccessingKey.isReactWarning = !0),
            Object.defineProperty(props, 'key', { get: warnAboutAccessingKey, configurable: !0 });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function () {
            specialPropRefWarningShown ||
              ((specialPropRefWarningShown = !0),
              error(
                '%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)',
                displayName
              ));
          };
          (warnAboutAccessingRef.isReactWarning = !0),
            Object.defineProperty(props, 'ref', { get: warnAboutAccessingRef, configurable: !0 });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          if (
            'string' == typeof config.ref &&
            ReactCurrentOwner.current &&
            config.__self &&
            ReactCurrentOwner.current.stateNode !== config.__self
          ) {
            var componentName = getComponentName(ReactCurrentOwner.current.type);
            didWarnAboutStringRefs[componentName] ||
              (error(
                'Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref',
                getComponentName(ReactCurrentOwner.current.type),
                config.ref
              ),
              (didWarnAboutStringRefs[componentName] = !0));
          }
        }
        didWarnAboutStringRefs = {};
        var ReactElement = function (type, key, ref, self, source, owner, props) {
          var element = { $$typeof: REACT_ELEMENT_TYPE, type, key, ref, props, _owner: owner, _store: {} };
          return (
            Object.defineProperty(element._store, 'validated', {
              configurable: !1,
              enumerable: !1,
              writable: !0,
              value: !1,
            }),
            Object.defineProperty(element, '_self', { configurable: !1, enumerable: !1, writable: !1, value: self }),
            Object.defineProperty(element, '_source', {
              configurable: !1,
              enumerable: !1,
              writable: !1,
              value: source,
            }),
            Object.freeze && (Object.freeze(element.props), Object.freeze(element)),
            element
          );
        };
        function createElement(type, config, children) {
          var propName,
            props = {},
            key = null,
            ref = null,
            self = null,
            source = null;
          if (null != config)
            for (propName in (hasValidRef(config) && ((ref = config.ref), warnIfStringRefCannotBeAutoConverted(config)),
            hasValidKey(config) && (key = '' + config.key),
            (self = void 0 === config.__self ? null : config.__self),
            (source = void 0 === config.__source ? null : config.__source),
            config))
              hasOwnProperty.call(config, propName) &&
                !RESERVED_PROPS.hasOwnProperty(propName) &&
                (props[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) props.children = children;
          else if (childrenLength > 1) {
            for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
              childArray[i] = arguments[i + 2];
            Object.freeze && Object.freeze(childArray), (props.children = childArray);
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) void 0 === props[propName] && (props[propName] = defaultProps[propName]);
          }
          if (key || ref) {
            var displayName = 'function' == typeof type ? type.displayName || type.name || 'Unknown' : type;
            key && defineKeyPropWarningGetter(props, displayName),
              ref && defineRefPropWarningGetter(props, displayName);
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneElement(element, config, children) {
          if (null == element)
            throw Error(
              'React.cloneElement(...): The argument must be a React element, but you passed ' + element + '.'
            );
          var propName,
            defaultProps,
            props = _assign({}, element.props),
            key = element.key,
            ref = element.ref,
            self = element._self,
            source = element._source,
            owner = element._owner;
          if (null != config)
            for (propName in (hasValidRef(config) && ((ref = config.ref), (owner = ReactCurrentOwner.current)),
            hasValidKey(config) && (key = '' + config.key),
            element.type && element.type.defaultProps && (defaultProps = element.type.defaultProps),
            config))
              hasOwnProperty.call(config, propName) &&
                !RESERVED_PROPS.hasOwnProperty(propName) &&
                (void 0 === config[propName] && void 0 !== defaultProps
                  ? (props[propName] = defaultProps[propName])
                  : (props[propName] = config[propName]));
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) props.children = children;
          else if (childrenLength > 1) {
            for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
              childArray[i] = arguments[i + 2];
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
          return 'object' == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var didWarnAboutMaps = !1,
          userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
        }
        var propTypesMisspellWarningShown,
          traverseContextPool = [];
        function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
          if (traverseContextPool.length) {
            var traverseContext = traverseContextPool.pop();
            return (
              (traverseContext.result = mapResult),
              (traverseContext.keyPrefix = keyPrefix),
              (traverseContext.func = mapFunction),
              (traverseContext.context = mapContext),
              (traverseContext.count = 0),
              traverseContext
            );
          }
          return { result: mapResult, keyPrefix, func: mapFunction, context: mapContext, count: 0 };
        }
        function releaseTraverseContext(traverseContext) {
          (traverseContext.result = null),
            (traverseContext.keyPrefix = null),
            (traverseContext.func = null),
            (traverseContext.context = null),
            (traverseContext.count = 0),
            traverseContextPool.length < 10 && traverseContextPool.push(traverseContext);
        }
        function traverseAllChildren(children, callback, traverseContext) {
          return null == children
            ? 0
            : (function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
                var type = typeof children;
                ('undefined' !== type && 'boolean' !== type) || (children = null);
                var child,
                  invokeCallback = !1;
                if (null === children) invokeCallback = !0;
                else
                  switch (type) {
                    case 'string':
                    case 'number':
                      invokeCallback = !0;
                      break;
                    case 'object':
                      switch (children.$$typeof) {
                        case REACT_ELEMENT_TYPE:
                        case REACT_PORTAL_TYPE:
                          invokeCallback = !0;
                      }
                  }
                if (invokeCallback)
                  return (
                    callback(
                      traverseContext,
                      children,
                      '' === nameSoFar ? '.' + getComponentKey(children, 0) : nameSoFar
                    ),
                    1
                  );
                var subtreeCount = 0,
                  nextNamePrefix = '' === nameSoFar ? '.' : nameSoFar + ':';
                if (Array.isArray(children))
                  for (var i = 0; i < children.length; i++)
                    subtreeCount += traverseAllChildrenImpl(
                      (child = children[i]),
                      nextNamePrefix + getComponentKey(child, i),
                      callback,
                      traverseContext
                    );
                else {
                  var iteratorFn = getIteratorFn(children);
                  if ('function' == typeof iteratorFn) {
                    iteratorFn === children.entries &&
                      (didWarnAboutMaps ||
                        warn(
                          'Using Maps as children is deprecated and will be removed in a future major release. Consider converting children to an array of keyed ReactElements instead.'
                        ),
                      (didWarnAboutMaps = !0));
                    for (var step, iterator = iteratorFn.call(children), ii = 0; !(step = iterator.next()).done; )
                      subtreeCount += traverseAllChildrenImpl(
                        (child = step.value),
                        nextNamePrefix + getComponentKey(child, ii++),
                        callback,
                        traverseContext
                      );
                  } else if ('object' === type) {
                    var addendum;
                    addendum =
                      ' If you meant to render a collection of children, use an array instead.' +
                      ReactDebugCurrentFrame.getStackAddendum();
                    var childrenString = '' + children;
                    throw Error(
                      'Objects are not valid as a React child (found: ' +
                        ('[object Object]' === childrenString
                          ? 'object with keys {' + Object.keys(children).join(', ') + '}'
                          : childrenString) +
                        ').' +
                        addendum
                    );
                  }
                }
                return subtreeCount;
              })(children, '', callback, traverseContext);
        }
        function getComponentKey(component, index) {
          return 'object' == typeof component && null !== component && null != component.key
            ? (function escape(key) {
                var escaperLookup = { '=': '=0', ':': '=2' };
                return (
                  '$' +
                  ('' + key).replace(/[=:]/g, function (match) {
                    return escaperLookup[match];
                  })
                );
              })(component.key)
            : index.toString(36);
        }
        function forEachSingleChild(bookKeeping, child, name) {
          var func = bookKeeping.func,
            context = bookKeeping.context;
          func.call(context, child, bookKeeping.count++);
        }
        function mapSingleChildIntoContext(bookKeeping, child, childKey) {
          var result = bookKeeping.result,
            keyPrefix = bookKeeping.keyPrefix,
            func = bookKeeping.func,
            context = bookKeeping.context,
            mappedChild = func.call(context, child, bookKeeping.count++);
          Array.isArray(mappedChild)
            ? mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
                return c;
              })
            : null != mappedChild &&
              (isValidElement(mappedChild) &&
                (mappedChild = (function cloneAndReplaceKey(oldElement, newKey) {
                  return ReactElement(
                    oldElement.type,
                    newKey,
                    oldElement.ref,
                    oldElement._self,
                    oldElement._source,
                    oldElement._owner,
                    oldElement.props
                  );
                })(
                  mappedChild,
                  keyPrefix +
                    (!mappedChild.key || (child && child.key === mappedChild.key)
                      ? ''
                      : escapeUserProvidedKey(mappedChild.key) + '/') +
                    childKey
                )),
              result.push(mappedChild));
        }
        function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
          var escapedPrefix = '';
          null != prefix && (escapedPrefix = escapeUserProvidedKey(prefix) + '/');
          var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
          traverseAllChildren(children, mapSingleChildIntoContext, traverseContext),
            releaseTraverseContext(traverseContext);
        }
        function isValidElementType(type) {
          return (
            'string' == typeof type ||
            'function' == typeof type ||
            type === REACT_FRAGMENT_TYPE ||
            type === REACT_CONCURRENT_MODE_TYPE ||
            type === REACT_PROFILER_TYPE ||
            type === REACT_STRICT_MODE_TYPE ||
            type === REACT_SUSPENSE_TYPE ||
            type === REACT_SUSPENSE_LIST_TYPE ||
            ('object' == typeof type &&
              null !== type &&
              (type.$$typeof === REACT_LAZY_TYPE ||
                type.$$typeof === REACT_MEMO_TYPE ||
                type.$$typeof === REACT_PROVIDER_TYPE ||
                type.$$typeof === REACT_CONTEXT_TYPE ||
                type.$$typeof === REACT_FORWARD_REF_TYPE ||
                type.$$typeof === REACT_FUNDAMENTAL_TYPE ||
                type.$$typeof === REACT_RESPONDER_TYPE ||
                type.$$typeof === REACT_SCOPE_TYPE ||
                type.$$typeof === REACT_BLOCK_TYPE))
          );
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (null === dispatcher)
            throw Error(
              'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.'
            );
          return dispatcher;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) return '\n\nCheck the render method of `' + name + '`.';
          }
          return '';
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          return null != elementProps
            ? (function getSourceInfoErrorAddendum(source) {
                return void 0 !== source
                  ? '\n\nCheck your code at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + '.'
                  : '';
              })(elementProps.__source)
            : '';
        }
        propTypesMisspellWarningShown = !1;
        var ownerHasKeyUseWarning = {};
        function validateExplicitKey(element, parentType) {
          if (element._store && !element._store.validated && null == element.key) {
            element._store.validated = !0;
            var currentComponentErrorInfo = (function getCurrentComponentErrorInfo(parentType) {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = 'string' == typeof parentType ? parentType : parentType.displayName || parentType.name;
                parentName && (info = '\n\nCheck the top-level render call using <' + parentName + '>.');
              }
              return info;
            })(parentType);
            if (!ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
              var childOwner = '';
              element &&
                element._owner &&
                element._owner !== ReactCurrentOwner.current &&
                (childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.'),
                setCurrentlyValidatingElement(element),
                error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://fb.me/react-warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwner
                ),
                setCurrentlyValidatingElement(null);
            }
          }
        }
        function validateChildKeys(node, parentType) {
          if ('object' == typeof node)
            if (Array.isArray(node))
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                isValidElement(child) && validateExplicitKey(child, parentType);
              }
            else if (isValidElement(node)) node._store && (node._store.validated = !0);
            else if (node) {
              var iteratorFn = getIteratorFn(node);
              if ('function' == typeof iteratorFn && iteratorFn !== node.entries)
                for (var step, iterator = iteratorFn.call(node); !(step = iterator.next()).done; )
                  isValidElement(step.value) && validateExplicitKey(step.value, parentType);
            }
        }
        function validatePropTypes(element) {
          var type = element.type;
          if (null != type && 'string' != typeof type) {
            var propTypes,
              name = getComponentName(type);
            if ('function' == typeof type) propTypes = type.propTypes;
            else {
              if (
                'object' != typeof type ||
                (type.$$typeof !== REACT_FORWARD_REF_TYPE && type.$$typeof !== REACT_MEMO_TYPE)
              )
                return;
              propTypes = type.propTypes;
            }
            propTypes
              ? (setCurrentlyValidatingElement(element),
                checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum),
                setCurrentlyValidatingElement(null))
              : void 0 === type.PropTypes ||
                propTypesMisspellWarningShown ||
                ((propTypesMisspellWarningShown = !0),
                error(
                  'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
                  name || 'Unknown'
                )),
              'function' != typeof type.getDefaultProps ||
                type.getDefaultProps.isReactClassApproved ||
                error(
                  'getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.'
                );
          }
        }
        function validateFragmentProps(fragment) {
          setCurrentlyValidatingElement(fragment);
          for (var keys = Object.keys(fragment.props), i = 0; i < keys.length; i++) {
            var key = keys[i];
            if ('children' !== key && 'key' !== key) {
              error(
                'Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.',
                key
              );
              break;
            }
          }
          null !== fragment.ref && error('Invalid attribute `ref` supplied to `React.Fragment`.'),
            setCurrentlyValidatingElement(null);
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = '';
            (void 0 === type || ('object' == typeof type && null !== type && 0 === Object.keys(type).length)) &&
              (info +=
                " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var typeString,
              sourceInfo = getSourceInfoErrorAddendumForProps(props);
            (info += sourceInfo || getDeclarationErrorAddendum()),
              null === type
                ? (typeString = 'null')
                : Array.isArray(type)
                ? (typeString = 'array')
                : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE
                ? ((typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />'),
                  (info = ' Did you accidentally export a JSX literal instead of a component?'))
                : (typeString = typeof type),
              error(
                'React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
                typeString,
                info
              );
          }
          var element = createElement.apply(this, arguments);
          if (null == element) return element;
          if (validType) for (var i = 2; i < arguments.length; i++) validateChildKeys(arguments[i], type);
          return type === REACT_FRAGMENT_TYPE ? validateFragmentProps(element) : validatePropTypes(element), element;
        }
        var didWarnAboutDeprecatedCreateFactory = !1;
        try {
          var frozenObject = Object.freeze({}),
            testMap = new Map([[frozenObject, null]]),
            testSet = new Set([frozenObject]);
          testMap.set(0, 0), testSet.add(0);
        } catch (e) {}
        var createElement$1 = createElementWithValidation,
          cloneElement$1 = function cloneElementWithValidation(element, props, children) {
            for (var newElement = cloneElement.apply(this, arguments), i = 2; i < arguments.length; i++)
              validateChildKeys(arguments[i], newElement.type);
            return validatePropTypes(newElement), newElement;
          },
          createFactory = function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            return (
              (validatedFactory.type = type),
              didWarnAboutDeprecatedCreateFactory ||
                ((didWarnAboutDeprecatedCreateFactory = !0),
                warn(
                  'React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.'
                )),
              Object.defineProperty(validatedFactory, 'type', {
                enumerable: !1,
                get: function () {
                  return (
                    warn('Factory.type is deprecated. Access the class directly before passing it to createFactory.'),
                    Object.defineProperty(this, 'type', { value: type }),
                    type
                  );
                },
              }),
              validatedFactory
            );
          },
          Children = {
            map: function mapChildren(children, func, context) {
              if (null == children) return children;
              var result = [];
              return mapIntoWithKeyPrefixInternal(children, result, null, func, context), result;
            },
            forEach: function forEachChildren(children, forEachFunc, forEachContext) {
              if (null == children) return children;
              var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
              traverseAllChildren(children, forEachSingleChild, traverseContext),
                releaseTraverseContext(traverseContext);
            },
            count: function countChildren(children) {
              return traverseAllChildren(
                children,
                function () {
                  return null;
                },
                null
              );
            },
            toArray: function toArray(children) {
              var result = [];
              return (
                mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
                  return child;
                }),
                result
              );
            },
            only: function onlyChild(children) {
              if (!isValidElement(children))
                throw Error('React.Children.only expected to receive a single React element child.');
              return children;
            },
          };
        (exports.Children = Children),
          (exports.Component = Component),
          (exports.Fragment = REACT_FRAGMENT_TYPE),
          (exports.Profiler = REACT_PROFILER_TYPE),
          (exports.PureComponent = PureComponent),
          (exports.StrictMode = REACT_STRICT_MODE_TYPE),
          (exports.Suspense = REACT_SUSPENSE_TYPE),
          (exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals),
          (exports.cloneElement = cloneElement$1),
          (exports.createContext = function createContext(defaultValue, calculateChangedBits) {
            void 0 === calculateChangedBits
              ? (calculateChangedBits = null)
              : null !== calculateChangedBits &&
                'function' != typeof calculateChangedBits &&
                error(
                  'createContext: Expected the optional second argument to be a function. Instead received: %s',
                  calculateChangedBits
                );
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              _calculateChangedBits: calculateChangedBits,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
            };
            context.Provider = { $$typeof: REACT_PROVIDER_TYPE, _context: context };
            var hasWarnedAboutUsingNestedContextConsumers = !1,
              hasWarnedAboutUsingConsumerProvider = !1,
              Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context,
                _calculateChangedBits: context._calculateChangedBits,
              };
            return (
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function () {
                    return (
                      hasWarnedAboutUsingConsumerProvider ||
                        ((hasWarnedAboutUsingConsumerProvider = !0),
                        error(
                          'Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?'
                        )),
                      context.Provider
                    );
                  },
                  set: function (_Provider) {
                    context.Provider = _Provider;
                  },
                },
                _currentValue: {
                  get: function () {
                    return context._currentValue;
                  },
                  set: function (_currentValue) {
                    context._currentValue = _currentValue;
                  },
                },
                _currentValue2: {
                  get: function () {
                    return context._currentValue2;
                  },
                  set: function (_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  },
                },
                _threadCount: {
                  get: function () {
                    return context._threadCount;
                  },
                  set: function (_threadCount) {
                    context._threadCount = _threadCount;
                  },
                },
                Consumer: {
                  get: function () {
                    return (
                      hasWarnedAboutUsingNestedContextConsumers ||
                        ((hasWarnedAboutUsingNestedContextConsumers = !0),
                        error(
                          'Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
                        )),
                      context.Consumer
                    );
                  },
                },
              }),
              (context.Consumer = Consumer),
              (context._currentRenderer = null),
              (context._currentRenderer2 = null),
              context
            );
          }),
          (exports.createElement = createElement$1),
          (exports.createFactory = createFactory),
          (exports.createRef = function createRef() {
            var refObject = { current: null };
            return Object.seal(refObject), refObject;
          }),
          (exports.forwardRef = function forwardRef(render) {
            return (
              null != render && render.$$typeof === REACT_MEMO_TYPE
                ? error(
                    'forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).'
                  )
                : 'function' != typeof render
                ? error(
                    'forwardRef requires a render function but was given %s.',
                    null === render ? 'null' : typeof render
                  )
                : 0 !== render.length &&
                  2 !== render.length &&
                  error(
                    'forwardRef render functions accept exactly two parameters: props and ref. %s',
                    1 === render.length
                      ? 'Did you forget to use the ref parameter?'
                      : 'Any additional parameter will be undefined.'
                  ),
              null != render &&
                ((null == render.defaultProps && null == render.propTypes) ||
                  error(
                    'forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?'
                  )),
              { $$typeof: REACT_FORWARD_REF_TYPE, render }
            );
          }),
          (exports.isValidElement = isValidElement),
          (exports.lazy = function lazy(ctor) {
            var defaultProps,
              propTypes,
              lazyType = { $$typeof: REACT_LAZY_TYPE, _ctor: ctor, _status: -1, _result: null };
            return (
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: !0,
                  get: function () {
                    return defaultProps;
                  },
                  set: function (newDefaultProps) {
                    error(
                      'React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
                    ),
                      (defaultProps = newDefaultProps),
                      Object.defineProperty(lazyType, 'defaultProps', { enumerable: !0 });
                  },
                },
                propTypes: {
                  configurable: !0,
                  get: function () {
                    return propTypes;
                  },
                  set: function (newPropTypes) {
                    error(
                      'React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.'
                    ),
                      (propTypes = newPropTypes),
                      Object.defineProperty(lazyType, 'propTypes', { enumerable: !0 });
                  },
                },
              }),
              lazyType
            );
          }),
          (exports.memo = function memo(type, compare) {
            return (
              isValidElementType(type) ||
                error(
                  'memo: The first argument must be a component. Instead received: %s',
                  null === type ? 'null' : typeof type
                ),
              { $$typeof: REACT_MEMO_TYPE, type, compare: void 0 === compare ? null : compare }
            );
          }),
          (exports.useCallback = function useCallback(callback, deps) {
            return resolveDispatcher().useCallback(callback, deps);
          }),
          (exports.useContext = function useContext(Context, unstable_observedBits) {
            var dispatcher = resolveDispatcher();
            if (
              (void 0 !== unstable_observedBits &&
                error(
                  'useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s',
                  unstable_observedBits,
                  'number' == typeof unstable_observedBits && Array.isArray(arguments[2])
                    ? '\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://fb.me/rules-of-hooks'
                    : ''
                ),
              void 0 !== Context._context)
            ) {
              var realContext = Context._context;
              realContext.Consumer === Context
                ? error(
                    'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?'
                  )
                : realContext.Provider === Context &&
                  error(
                    'Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?'
                  );
            }
            return dispatcher.useContext(Context, unstable_observedBits);
          }),
          (exports.useDebugValue = function useDebugValue(value, formatterFn) {
            return resolveDispatcher().useDebugValue(value, formatterFn);
          }),
          (exports.useEffect = function useEffect(create, deps) {
            return resolveDispatcher().useEffect(create, deps);
          }),
          (exports.useImperativeHandle = function useImperativeHandle(ref, create, deps) {
            return resolveDispatcher().useImperativeHandle(ref, create, deps);
          }),
          (exports.useLayoutEffect = function useLayoutEffect(create, deps) {
            return resolveDispatcher().useLayoutEffect(create, deps);
          }),
          (exports.useMemo = function useMemo(create, deps) {
            return resolveDispatcher().useMemo(create, deps);
          }),
          (exports.useReducer = function useReducer(reducer, initialArg, init) {
            return resolveDispatcher().useReducer(reducer, initialArg, init);
          }),
          (exports.useRef = function useRef(initialValue) {
            return resolveDispatcher().useRef(initialValue);
          }),
          (exports.useState = function useState(initialState) {
            return resolveDispatcher().useState(initialState);
          }),
          (exports.version = '16.13.1');
      })();
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      (function () {
        var React = __webpack_require__(0),
          _assign = __webpack_require__(15),
          Scheduler = __webpack_require__(85),
          checkPropTypes = __webpack_require__(33),
          tracing = __webpack_require__(87),
          ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning('warn', format, args);
        }
        function error(format) {
          for (
            var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;
            _key2 < _len2;
            _key2++
          )
            args[_key2 - 1] = arguments[_key2];
          printWarning('error', format, args);
        }
        function printWarning(level, format, args) {
          if (
            !(
              args.length > 0 &&
              'string' == typeof args[args.length - 1] &&
              0 === args[args.length - 1].indexOf('\n    in')
            )
          ) {
            var stack = ReactSharedInternals.ReactDebugCurrentFrame.getStackAddendum();
            '' !== stack && ((format += '%s'), (args = args.concat([stack])));
          }
          var argsWithFormat = args.map(function (item) {
            return '' + item;
          });
          argsWithFormat.unshift('Warning: ' + format),
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          try {
            var argIndex = 0,
              message =
                'Warning: ' +
                format.replace(/%s/g, function () {
                  return args[argIndex++];
                });
            throw new Error(message);
          } catch (x) {}
        }
        if (
          (ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher') ||
            (ReactSharedInternals.ReactCurrentDispatcher = { current: null }),
          ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig') ||
            (ReactSharedInternals.ReactCurrentBatchConfig = { suspense: null }),
          !React)
        )
          throw Error(
            'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'
          );
        var invokeGuardedCallbackImpl = function (name, func, context, a, b, c, d, e, f) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context, funcArgs);
          } catch (error) {
            this.onError(error);
          }
        };
        if (
          'undefined' != typeof window &&
          'function' == typeof window.dispatchEvent &&
          'undefined' != typeof document &&
          'function' == typeof document.createEvent
        ) {
          var fakeNode = document.createElement('react');
          invokeGuardedCallbackImpl = function (name, func, context, a, b, c, d, e, f) {
            if ('undefined' == typeof document)
              throw Error(
                'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.'
              );
            var error,
              evt = document.createEvent('Event'),
              didError = !0,
              windowEvent = window.event,
              windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event'),
              funcArgs = Array.prototype.slice.call(arguments, 3);
            function callCallback() {
              fakeNode.removeEventListener(evtType, callCallback, !1),
                void 0 !== window.event && window.hasOwnProperty('event') && (window.event = windowEvent),
                func.apply(context, funcArgs),
                (didError = !1);
            }
            var didSetError = !1,
              isCrossOriginError = !1;
            function handleWindowError(event) {
              if (
                ((error = event.error),
                (didSetError = !0),
                null === error && 0 === event.colno && 0 === event.lineno && (isCrossOriginError = !0),
                event.defaultPrevented && null != error && 'object' == typeof error)
              )
                try {
                  error._suppressLogging = !0;
                } catch (inner) {}
            }
            var evtType = 'react-' + (name || 'invokeguardedcallback');
            window.addEventListener('error', handleWindowError),
              fakeNode.addEventListener(evtType, callCallback, !1),
              evt.initEvent(evtType, !1, !1),
              fakeNode.dispatchEvent(evt),
              windowEventDescriptor && Object.defineProperty(window, 'event', windowEventDescriptor),
              didError &&
                (didSetError
                  ? isCrossOriginError &&
                    (error = new Error(
                      "A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://fb.me/react-crossorigin-error for more information."
                    ))
                  : (error = new Error(
                      "An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the \"Pause on exceptions\" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue."
                    )),
                this.onError(error)),
              window.removeEventListener('error', handleWindowError);
          };
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl,
          hasError = !1,
          caughtError = null,
          hasRethrowError = !1,
          rethrowError = null,
          reporter = {
            onError: function (error) {
              (hasError = !0), (caughtError = error);
            },
          };
        function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
          (hasError = !1), (caughtError = null), invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error = caughtError;
            return (hasError = !1), (caughtError = null), error;
          }
          throw Error(
            'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.'
          );
        }
        var validateEventDispatches,
          getFiberCurrentPropsFromNode = null,
          getInstanceFromNode = null,
          getNodeFromInstance = null;
        function executeDispatch(event, listener, inst) {
          var type = event.type || 'unknown-event';
          (event.currentTarget = getNodeFromInstance(inst)),
            (function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
              if ((invokeGuardedCallback.apply(this, arguments), hasError)) {
                var error = clearCaughtError();
                hasRethrowError || ((hasRethrowError = !0), (rethrowError = error));
              }
            })(type, listener, void 0, event),
            (event.currentTarget = null);
        }
        validateEventDispatches = function (event) {
          var dispatchListeners = event._dispatchListeners,
            dispatchInstances = event._dispatchInstances,
            listenersIsArr = Array.isArray(dispatchListeners),
            listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0,
            instancesIsArr = Array.isArray(dispatchInstances),
            instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
          (instancesIsArr === listenersIsArr && instancesLen === listenersLen) ||
            error('EventPluginUtils: Invalid `event`.');
        };
        var eventPluginOrder = null,
          namesToPlugins = {};
        function recomputePluginOrdering() {
          if (eventPluginOrder)
            for (var pluginName in namesToPlugins) {
              var pluginModule = namesToPlugins[pluginName],
                pluginIndex = eventPluginOrder.indexOf(pluginName);
              if (!(pluginIndex > -1))
                throw Error(
                  'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `' +
                    pluginName +
                    '`.'
                );
              if (!plugins[pluginIndex]) {
                if (!pluginModule.extractEvents)
                  throw Error(
                    'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `' +
                      pluginName +
                      '` does not.'
                  );
                plugins[pluginIndex] = pluginModule;
                var publishedEvents = pluginModule.eventTypes;
                for (var eventName in publishedEvents)
                  if (!publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName))
                    throw Error(
                      'EventPluginRegistry: Failed to publish event `' +
                        eventName +
                        '` for plugin `' +
                        pluginName +
                        '`.'
                    );
              }
            }
        }
        function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName))
            throw Error(
              'EventPluginRegistry: More than one plugin attempted to publish the same event name, `' + eventName + '`.'
            );
          eventNameDispatchConfigs[eventName] = dispatchConfig;
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
          if (phasedRegistrationNames) {
            for (var phaseName in phasedRegistrationNames) {
              if (phasedRegistrationNames.hasOwnProperty(phaseName))
                publishRegistrationName(phasedRegistrationNames[phaseName], pluginModule, eventName);
            }
            return !0;
          }
          return (
            !!dispatchConfig.registrationName &&
            (publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName), !0)
          );
        }
        function publishRegistrationName(registrationName, pluginModule, eventName) {
          if (registrationNameModules[registrationName])
            throw Error(
              'EventPluginRegistry: More than one plugin attempted to publish the same registration name, `' +
                registrationName +
                '`.'
            );
          (registrationNameModules[registrationName] = pluginModule),
            (registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies);
          var lowerCasedName = registrationName.toLowerCase();
          (possibleRegistrationNames[lowerCasedName] = registrationName),
            'onDoubleClick' === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
        }
        var plugins = [],
          eventNameDispatchConfigs = {},
          registrationNameModules = {},
          registrationNameDependencies = {},
          possibleRegistrationNames = {};
        function injectEventPluginsByName(injectedNamesToPlugins) {
          var isOrderingDirty = !1;
          for (var pluginName in injectedNamesToPlugins)
            if (injectedNamesToPlugins.hasOwnProperty(pluginName)) {
              var pluginModule = injectedNamesToPlugins[pluginName];
              if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
                if (namesToPlugins[pluginName])
                  throw Error(
                    'EventPluginRegistry: Cannot inject two different event plugins using the same name, `' +
                      pluginName +
                      '`.'
                  );
                (namesToPlugins[pluginName] = pluginModule), (isOrderingDirty = !0);
              }
            }
          isOrderingDirty && recomputePluginOrdering();
        }
        var canUseDOM = !(
            'undefined' == typeof window ||
            void 0 === window.document ||
            void 0 === window.document.createElement
          ),
          restoreImpl = null,
          restoreTarget = null,
          restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance) {
            if ('function' != typeof restoreImpl)
              throw Error(
                'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.'
              );
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
        }
        function enqueueStateRestore(target) {
          restoreTarget
            ? restoreQueue
              ? restoreQueue.push(target)
              : (restoreQueue = [target])
            : (restoreTarget = target);
        }
        function restoreStateIfNeeded() {
          if (restoreTarget) {
            var target = restoreTarget,
              queuedTargets = restoreQueue;
            if (((restoreTarget = null), (restoreQueue = null), restoreStateOfTarget(target), queuedTargets))
              for (var i = 0; i < queuedTargets.length; i++) restoreStateOfTarget(queuedTargets[i]);
          }
        }
        var batchedUpdatesImpl = function (fn, bookkeeping) {
            return fn(bookkeeping);
          },
          discreteUpdatesImpl = function (fn, a, b, c, d) {
            return fn(a, b, c, d);
          },
          flushDiscreteUpdatesImpl = function () {},
          batchedEventUpdatesImpl = batchedUpdatesImpl,
          isInsideEventHandler = !1,
          isBatchingEventUpdates = !1;
        function finishEventHandler() {
          (function needsStateRestore() {
            return null !== restoreTarget || null !== restoreQueue;
          })() && (flushDiscreteUpdatesImpl(), restoreStateIfNeeded());
        }
        var ATTRIBUTE_NAME_START_CHAR =
            ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
          ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
          VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
            '^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$'
          ),
          hasOwnProperty = Object.prototype.hasOwnProperty,
          illegalAttributeNameCache = {},
          validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          return (
            !!hasOwnProperty.call(validatedAttributeNameCache, attributeName) ||
            (!hasOwnProperty.call(illegalAttributeNameCache, attributeName) &&
              (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)
                ? ((validatedAttributeNameCache[attributeName] = !0), !0)
                : ((illegalAttributeNameCache[attributeName] = !0),
                  error('Invalid attribute name: `%s`', attributeName),
                  !1)))
          );
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          return null !== propertyInfo
            ? 0 === propertyInfo.type
            : !isCustomComponentTag &&
                name.length > 2 &&
                ('o' === name[0] || 'O' === name[0]) &&
                ('n' === name[1] || 'N' === name[1]);
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (null !== propertyInfo && 0 === propertyInfo.type) return !1;
          switch (typeof value) {
            case 'function':
            case 'symbol':
              return !0;
            case 'boolean':
              if (isCustomComponentTag) return !1;
              if (null !== propertyInfo) return !propertyInfo.acceptsBooleans;
              var prefix = name.toLowerCase().slice(0, 5);
              return 'data-' !== prefix && 'aria-' !== prefix;
            default:
              return !1;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (null == value) return !0;
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) return !0;
          if (isCustomComponentTag) return !1;
          if (null !== propertyInfo)
            switch (propertyInfo.type) {
              case 3:
                return !value;
              case 4:
                return !1 === value;
              case 5:
                return isNaN(value);
              case 6:
                return isNaN(value) || value < 1;
            }
          return !1;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL) {
          (this.acceptsBooleans = 2 === type || 3 === type || 4 === type),
            (this.attributeName = attributeName),
            (this.attributeNamespace = attributeNamespace),
            (this.mustUseProperty = mustUseProperty),
            (this.propertyName = name),
            (this.type = type),
            (this.sanitizeURL = sanitizeURL);
        }
        var properties = {};
        [
          'children',
          'dangerouslySetInnerHTML',
          'defaultValue',
          'defaultChecked',
          'innerHTML',
          'suppressContentEditableWarning',
          'suppressHydrationWarning',
          'style',
        ].forEach(function (name) {
          properties[name] = new PropertyInfoRecord(name, 0, !1, name, null, !1);
        }),
          [
            ['acceptCharset', 'accept-charset'],
            ['className', 'class'],
            ['htmlFor', 'for'],
            ['httpEquiv', 'http-equiv'],
          ].forEach(function (_ref) {
            var name = _ref[0],
              attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(name, 1, !1, attributeName, null, !1);
          }),
          ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, 2, !1, name.toLowerCase(), null, !1);
          }),
          ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, 2, !1, name, null, !1);
          }),
          [
            'allowFullScreen',
            'async',
            'autoFocus',
            'autoPlay',
            'controls',
            'default',
            'defer',
            'disabled',
            'disablePictureInPicture',
            'formNoValidate',
            'hidden',
            'loop',
            'noModule',
            'noValidate',
            'open',
            'playsInline',
            'readOnly',
            'required',
            'reversed',
            'scoped',
            'seamless',
            'itemScope',
          ].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, 3, !1, name.toLowerCase(), null, !1);
          }),
          ['checked', 'multiple', 'muted', 'selected'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, 3, !0, name, null, !1);
          }),
          ['capture', 'download'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, 4, !1, name, null, !1);
          }),
          ['cols', 'rows', 'size', 'span'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, 6, !1, name, null, !1);
          }),
          ['rowSpan', 'start'].forEach(function (name) {
            properties[name] = new PropertyInfoRecord(name, 5, !1, name.toLowerCase(), null, !1);
          });
        var CAMELIZE = /[\-\:]([a-z])/g,
          capitalize = function (token) {
            return token[1].toUpperCase();
          };
        [
          'accent-height',
          'alignment-baseline',
          'arabic-form',
          'baseline-shift',
          'cap-height',
          'clip-path',
          'clip-rule',
          'color-interpolation',
          'color-interpolation-filters',
          'color-profile',
          'color-rendering',
          'dominant-baseline',
          'enable-background',
          'fill-opacity',
          'fill-rule',
          'flood-color',
          'flood-opacity',
          'font-family',
          'font-size',
          'font-size-adjust',
          'font-stretch',
          'font-style',
          'font-variant',
          'font-weight',
          'glyph-name',
          'glyph-orientation-horizontal',
          'glyph-orientation-vertical',
          'horiz-adv-x',
          'horiz-origin-x',
          'image-rendering',
          'letter-spacing',
          'lighting-color',
          'marker-end',
          'marker-mid',
          'marker-start',
          'overline-position',
          'overline-thickness',
          'paint-order',
          'panose-1',
          'pointer-events',
          'rendering-intent',
          'shape-rendering',
          'stop-color',
          'stop-opacity',
          'strikethrough-position',
          'strikethrough-thickness',
          'stroke-dasharray',
          'stroke-dashoffset',
          'stroke-linecap',
          'stroke-linejoin',
          'stroke-miterlimit',
          'stroke-opacity',
          'stroke-width',
          'text-anchor',
          'text-decoration',
          'text-rendering',
          'underline-position',
          'underline-thickness',
          'unicode-bidi',
          'unicode-range',
          'units-per-em',
          'v-alphabetic',
          'v-hanging',
          'v-ideographic',
          'v-mathematical',
          'vector-effect',
          'vert-adv-y',
          'vert-origin-x',
          'vert-origin-y',
          'word-spacing',
          'writing-mode',
          'xmlns:xlink',
          'x-height',
        ].forEach(function (attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, 1, !1, attributeName, null, !1);
        }),
          ['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (
            attributeName
          ) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(name, 1, !1, attributeName, 'http://www.w3.org/1999/xlink', !1);
          }),
          ['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              1,
              !1,
              attributeName,
              'http://www.w3.org/XML/1998/namespace',
              !1
            );
          }),
          ['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              1,
              !1,
              attributeName.toLowerCase(),
              null,
              !1
            );
          });
        (properties.xlinkHref = new PropertyInfoRecord(
          'xlinkHref',
          1,
          !1,
          'xlink:href',
          'http://www.w3.org/1999/xlink',
          !0
        )),
          ['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              1,
              !1,
              attributeName.toLowerCase(),
              null,
              !0
            );
          });
        ReactSharedInternals.ReactDebugCurrentFrame;
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i,
          didWarn = !1;
        function sanitizeURL(url) {
          !didWarn &&
            isJavaScriptProtocol.test(url) &&
            ((didWarn = !0),
            error(
              'A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.',
              JSON.stringify(url)
            ));
        }
        function getValueForProperty(node, name, expected, propertyInfo) {
          if (propertyInfo.mustUseProperty) return node[propertyInfo.propertyName];
          propertyInfo.sanitizeURL && sanitizeURL('' + expected);
          var attributeName = propertyInfo.attributeName,
            stringValue = null;
          if (4 === propertyInfo.type) {
            if (node.hasAttribute(attributeName)) {
              var value = node.getAttribute(attributeName);
              return (
                '' === value ||
                (shouldRemoveAttribute(name, expected, propertyInfo, !1)
                  ? value
                  : value === '' + expected
                  ? expected
                  : value)
              );
            }
          } else if (node.hasAttribute(attributeName)) {
            if (shouldRemoveAttribute(name, expected, propertyInfo, !1)) return node.getAttribute(attributeName);
            if (3 === propertyInfo.type) return expected;
            stringValue = node.getAttribute(attributeName);
          }
          return shouldRemoveAttribute(name, expected, propertyInfo, !1)
            ? null === stringValue
              ? expected
              : stringValue
            : stringValue === '' + expected
            ? expected
            : stringValue;
        }
        function getValueForAttribute(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) return void 0 === expected ? void 0 : null;
            var value = node.getAttribute(name);
            return value === '' + expected ? expected : value;
          }
        }
        function setValueForProperty(node, name, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name);
          if (!shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag))
            if (
              (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) && (value = null),
              isCustomComponentTag || null === propertyInfo)
            ) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                null === value ? node.removeAttribute(_attributeName) : node.setAttribute(_attributeName, '' + value);
              }
            } else if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (null === value) {
                var type = propertyInfo.type;
                node[propertyName] = 3 !== type && '';
              } else node[propertyName] = value;
            } else {
              var attributeName = propertyInfo.attributeName,
                attributeNamespace = propertyInfo.attributeNamespace;
              if (null === value) node.removeAttribute(attributeName);
              else {
                var attributeValue,
                  _type = propertyInfo.type;
                3 === _type || (4 === _type && !0 === value)
                  ? (attributeValue = '')
                  : ((attributeValue = '' + value), propertyInfo.sanitizeURL && sanitizeURL(attributeValue.toString())),
                  attributeNamespace
                    ? node.setAttributeNS(attributeNamespace, attributeName, attributeValue)
                    : node.setAttribute(attributeName, attributeValue);
              }
            }
        }
        var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
        var hasSymbol = 'function' == typeof Symbol && Symbol.for,
          REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 60103,
          REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 60106,
          REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 60107,
          REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 60108,
          REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 60114,
          REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 60109,
          REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 60110,
          REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 60111,
          REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 60112,
          REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 60113,
          REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 60120,
          REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 60115,
          REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 60116,
          REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 60121,
          MAYBE_ITERATOR_SYMBOL = 'function' == typeof Symbol && Symbol.iterator;
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || 'object' != typeof maybeIterable) return null;
          var maybeIterator =
            (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) || maybeIterable['@@iterator'];
          return 'function' == typeof maybeIterator ? maybeIterator : null;
        }
        function refineResolvedLazyComponent(lazyComponent) {
          return 1 === lazyComponent._status ? lazyComponent._result : null;
        }
        function getComponentName(type) {
          if (null == type) return null;
          if (
            ('number' == typeof type.tag &&
              error(
                'Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.'
              ),
            'function' == typeof type)
          )
            return type.displayName || type.name || null;
          if ('string' == typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return 'Fragment';
            case REACT_PORTAL_TYPE:
              return 'Portal';
            case REACT_PROFILER_TYPE:
              return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
              return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
              return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
              return 'SuspenseList';
          }
          if ('object' == typeof type)
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return 'Context.Consumer';
              case REACT_PROVIDER_TYPE:
                return 'Context.Provider';
              case REACT_FORWARD_REF_TYPE:
                return (function getWrappedName(outerType, innerType, wrapperName) {
                  var functionName = innerType.displayName || innerType.name || '';
                  return (
                    outerType.displayName ||
                    ('' !== functionName ? wrapperName + '(' + functionName + ')' : wrapperName)
                  );
                })(type, type.render, 'ForwardRef');
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type.render);
              case REACT_LAZY_TYPE:
                var resolvedThenable = refineResolvedLazyComponent(type);
                if (resolvedThenable) return getComponentName(resolvedThenable);
            }
          return null;
        }
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function describeFiber(fiber) {
          switch (fiber.tag) {
            case 3:
            case 4:
            case 6:
            case 7:
            case 10:
            case 9:
              return '';
            default:
              var owner = fiber._debugOwner,
                source = fiber._debugSource,
                name = getComponentName(fiber.type),
                ownerName = null;
              return (
                owner && (ownerName = getComponentName(owner.type)),
                (function describeComponentFrame(name, source, ownerName) {
                  var sourceInfo = '';
                  if (source) {
                    var path = source.fileName,
                      fileName = path.replace(BEFORE_SLASH_RE, '');
                    if (/^index\./.test(fileName)) {
                      var match = path.match(BEFORE_SLASH_RE);
                      if (match) {
                        var pathBeforeSlash = match[1];
                        if (pathBeforeSlash) fileName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '') + '/' + fileName;
                      }
                    }
                    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
                  } else ownerName && (sourceInfo = ' (created by ' + ownerName + ')');
                  return '\n    in ' + (name || 'Unknown') + sourceInfo;
                })(name, source, ownerName)
              );
          }
        }
        function getStackByFiberInDevAndProd(workInProgress) {
          var info = '',
            node = workInProgress;
          do {
            (info += describeFiber(node)), (node = node.return);
          } while (node);
          return info;
        }
        var current = null,
          isRendering = !1;
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentName(owner.type) : null;
        }
        function getCurrentFiberStackInDev() {
          return null === current ? '' : getStackByFiberInDevAndProd(current);
        }
        function resetCurrentFiber() {
          (ReactDebugCurrentFrame$1.getCurrentStack = null), (current = null), (isRendering = !1);
        }
        function setCurrentFiber(fiber) {
          (ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev), (current = fiber), (isRendering = !1);
        }
        function setIsRendering(rendering) {
          isRendering = rendering;
        }
        function toString(value) {
          return '' + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case 'boolean':
            case 'number':
            case 'object':
            case 'string':
            case 'undefined':
              return value;
            default:
              return '';
          }
        }
        var ReactDebugCurrentFrame$2,
          ReactControlledValuePropTypes = { checkPropTypes: null };
        ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;
        var hasReadOnlyValue = { button: !0, checkbox: !0, image: !0, hidden: !0, radio: !0, reset: !0, submit: !0 },
          propTypes = {
            value: function (props, propName, componentName) {
              return hasReadOnlyValue[props.type] ||
                props.onChange ||
                props.readOnly ||
                props.disabled ||
                null == props[propName]
                ? null
                : new Error(
                    'You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.'
                  );
            },
            checked: function (props, propName, componentName) {
              return props.onChange || props.readOnly || props.disabled || null == props[propName]
                ? null
                : new Error(
                    'You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.'
                  );
            },
          };
        function isCheckable(elem) {
          var type = elem.type,
            nodeName = elem.nodeName;
          return nodeName && 'input' === nodeName.toLowerCase() && ('checkbox' === type || 'radio' === type);
        }
        function getTracker(node) {
          return node._valueTracker;
        }
        function track(node) {
          getTracker(node) ||
            (node._valueTracker = (function trackValueOnNode(node) {
              var valueField = isCheckable(node) ? 'checked' : 'value',
                descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField),
                currentValue = '' + node[valueField];
              if (
                !node.hasOwnProperty(valueField) &&
                void 0 !== descriptor &&
                'function' == typeof descriptor.get &&
                'function' == typeof descriptor.set
              ) {
                var get = descriptor.get,
                  set = descriptor.set;
                return (
                  Object.defineProperty(node, valueField, {
                    configurable: !0,
                    get: function () {
                      return get.call(this);
                    },
                    set: function (value) {
                      (currentValue = '' + value), set.call(this, value);
                    },
                  }),
                  Object.defineProperty(node, valueField, { enumerable: descriptor.enumerable }),
                  {
                    getValue: function () {
                      return currentValue;
                    },
                    setValue: function (value) {
                      currentValue = '' + value;
                    },
                    stopTracking: function () {
                      !(function detachTracker(node) {
                        node._valueTracker = null;
                      })(node),
                        delete node[valueField];
                    },
                  }
                );
              }
            })(node));
        }
        function updateValueIfChanged(node) {
          if (!node) return !1;
          var tracker = getTracker(node);
          if (!tracker) return !0;
          var lastValue = tracker.getValue(),
            nextValue = (function getValueFromNode(node) {
              var value = '';
              return node ? (value = isCheckable(node) ? (node.checked ? 'true' : 'false') : node.value) : value;
            })(node);
          return nextValue !== lastValue && (tracker.setValue(nextValue), !0);
        }
        ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {
          checkPropTypes(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame$2.getStackAddendum);
        };
        var didWarnValueDefaultValue = !1,
          didWarnCheckedDefaultChecked = !1,
          didWarnControlledToUncontrolled = !1,
          didWarnUncontrolledToControlled = !1;
        function isControlled(props) {
          return 'checkbox' === props.type || 'radio' === props.type ? null != props.checked : null != props.value;
        }
        function getHostProps(element, props) {
          var node = element,
            checked = props.checked;
          return _assign({}, props, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != checked ? checked : node._wrapperState.initialChecked,
          });
        }
        function initWrapperState(element, props) {
          ReactControlledValuePropTypes.checkPropTypes('input', props),
            void 0 === props.checked ||
              void 0 === props.defaultChecked ||
              didWarnCheckedDefaultChecked ||
              (error(
                '%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://fb.me/react-controlled-components',
                getCurrentFiberOwnerNameInDevOrNull() || 'A component',
                props.type
              ),
              (didWarnCheckedDefaultChecked = !0)),
            void 0 === props.value ||
              void 0 === props.defaultValue ||
              didWarnValueDefaultValue ||
              (error(
                '%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://fb.me/react-controlled-components',
                getCurrentFiberOwnerNameInDevOrNull() || 'A component',
                props.type
              ),
              (didWarnValueDefaultValue = !0));
          var node = element,
            defaultValue = null == props.defaultValue ? '' : props.defaultValue;
          node._wrapperState = {
            initialChecked: null != props.checked ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(null != props.value ? props.value : defaultValue),
            controlled: isControlled(props),
          };
        }
        function updateChecked(element, props) {
          var node = element,
            checked = props.checked;
          null != checked && setValueForProperty(node, 'checked', checked, !1);
        }
        function updateWrapper(element, props) {
          var node = element,
            controlled = isControlled(props);
          node._wrapperState.controlled ||
            !controlled ||
            didWarnUncontrolledToControlled ||
            (error(
              'A component is changing an uncontrolled input of type %s to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components',
              props.type
            ),
            (didWarnUncontrolledToControlled = !0)),
            !node._wrapperState.controlled ||
              controlled ||
              didWarnControlledToUncontrolled ||
              (error(
                'A component is changing a controlled input of type %s to be uncontrolled. Input elements should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components',
                props.type
              ),
              (didWarnControlledToUncontrolled = !0)),
            updateChecked(element, props);
          var value = getToStringValue(props.value),
            type = props.type;
          if (null != value)
            'number' === type
              ? ((0 === value && '' === node.value) || node.value != value) && (node.value = toString(value))
              : node.value !== toString(value) && (node.value = toString(value));
          else if ('submit' === type || 'reset' === type) return void node.removeAttribute('value');
          props.hasOwnProperty('value')
            ? setDefaultValue(node, props.type, value)
            : props.hasOwnProperty('defaultValue') &&
              setDefaultValue(node, props.type, getToStringValue(props.defaultValue)),
            null == props.checked && null != props.defaultChecked && (node.defaultChecked = !!props.defaultChecked);
        }
        function postMountWrapper(element, props, isHydrating) {
          var node = element;
          if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
            var type = props.type;
            if (('submit' === type || 'reset' === type) && (void 0 === props.value || null === props.value)) return;
            var initialValue = toString(node._wrapperState.initialValue);
            isHydrating || (initialValue !== node.value && (node.value = initialValue)),
              (node.defaultValue = initialValue);
          }
          var name = node.name;
          '' !== name && (node.name = ''),
            (node.defaultChecked = !node.defaultChecked),
            (node.defaultChecked = !!node._wrapperState.initialChecked),
            '' !== name && (node.name = name);
        }
        function restoreControlledState(element, props) {
          var node = element;
          updateWrapper(node, props),
            (function updateNamedCousins(rootNode, props) {
              var name = props.name;
              if ('radio' === props.type && null != name) {
                for (var queryRoot = rootNode; queryRoot.parentNode; ) queryRoot = queryRoot.parentNode;
                for (
                  var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]'),
                    i = 0;
                  i < group.length;
                  i++
                ) {
                  var otherNode = group[i];
                  if (otherNode !== rootNode && otherNode.form === rootNode.form) {
                    var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
                    if (!otherProps)
                      throw Error(
                        'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'
                      );
                    updateValueIfChanged(otherNode), updateWrapper(otherNode, otherProps);
                  }
                }
              }
            })(node, props);
        }
        function setDefaultValue(node, type, value) {
          ('number' === type && node.ownerDocument.activeElement === node) ||
            (null == value
              ? (node.defaultValue = toString(node._wrapperState.initialValue))
              : node.defaultValue !== toString(value) && (node.defaultValue = toString(value)));
        }
        var didWarnValueDefaultValue$1,
          didWarnSelectedSetOnOption = !1,
          didWarnInvalidChild = !1;
        function validateProps(element, props) {
          'object' == typeof props.children &&
            null !== props.children &&
            React.Children.forEach(props.children, function (child) {
              null != child &&
                'string' != typeof child &&
                'number' != typeof child &&
                'string' == typeof child.type &&
                (didWarnInvalidChild ||
                  ((didWarnInvalidChild = !0), error('Only strings and numbers are supported as <option> children.')));
            }),
            null == props.selected ||
              didWarnSelectedSetOnOption ||
              (error('Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.'),
              (didWarnSelectedSetOnOption = !0));
        }
        function getHostProps$1(element, props) {
          var hostProps = _assign({ children: void 0 }, props),
            content = (function flattenChildren(children) {
              var content = '';
              return (
                React.Children.forEach(children, function (child) {
                  null != child && (content += child);
                }),
                content
              );
            })(props.children);
          return content && (hostProps.children = content), hostProps;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? '\n\nCheck the render method of `' + ownerName + '`.' : '';
        }
        didWarnValueDefaultValue$1 = !1;
        var valuePropNames = ['value', 'defaultValue'];
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          var options = node.options;
          if (multiple) {
            for (var selectedValues = propValue, selectedValue = {}, i = 0; i < selectedValues.length; i++)
              selectedValue['$' + selectedValues[i]] = !0;
            for (var _i = 0; _i < options.length; _i++) {
              var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
              options[_i].selected !== selected && (options[_i].selected = selected),
                selected && setDefaultSelected && (options[_i].defaultSelected = !0);
            }
          } else {
            for (
              var _selectedValue = toString(getToStringValue(propValue)), defaultSelected = null, _i2 = 0;
              _i2 < options.length;
              _i2++
            ) {
              if (options[_i2].value === _selectedValue)
                return (options[_i2].selected = !0), void (setDefaultSelected && (options[_i2].defaultSelected = !0));
              null !== defaultSelected || options[_i2].disabled || (defaultSelected = options[_i2]);
            }
            null !== defaultSelected && (defaultSelected.selected = !0);
          }
        }
        function getHostProps$2(element, props) {
          return _assign({}, props, { value: void 0 });
        }
        function initWrapperState$1(element, props) {
          var node = element;
          !(function checkSelectPropTypes(props) {
            ReactControlledValuePropTypes.checkPropTypes('select', props);
            for (var i = 0; i < valuePropNames.length; i++) {
              var propName = valuePropNames[i];
              if (null != props[propName]) {
                var isArray = Array.isArray(props[propName]);
                props.multiple && !isArray
                  ? error(
                      'The `%s` prop supplied to <select> must be an array if `multiple` is true.%s',
                      propName,
                      getDeclarationErrorAddendum()
                    )
                  : !props.multiple &&
                    isArray &&
                    error(
                      'The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s',
                      propName,
                      getDeclarationErrorAddendum()
                    );
              }
            }
          })(props),
            (node._wrapperState = { wasMultiple: !!props.multiple }),
            void 0 === props.value ||
              void 0 === props.defaultValue ||
              didWarnValueDefaultValue$1 ||
              (error(
                'Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://fb.me/react-controlled-components'
              ),
              (didWarnValueDefaultValue$1 = !0));
        }
        var didWarnValDefaultVal = !1;
        function getHostProps$3(element, props) {
          var node = element;
          if (null != props.dangerouslySetInnerHTML)
            throw Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');
          return _assign({}, props, {
            value: void 0,
            defaultValue: void 0,
            children: toString(node._wrapperState.initialValue),
          });
        }
        function initWrapperState$2(element, props) {
          var node = element;
          ReactControlledValuePropTypes.checkPropTypes('textarea', props),
            void 0 === props.value ||
              void 0 === props.defaultValue ||
              didWarnValDefaultVal ||
              (error(
                '%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://fb.me/react-controlled-components',
                getCurrentFiberOwnerNameInDevOrNull() || 'A component'
              ),
              (didWarnValDefaultVal = !0));
          var initialValue = props.value;
          if (null == initialValue) {
            var children = props.children,
              defaultValue = props.defaultValue;
            if (null != children) {
              if (
                (error('Use the `defaultValue` or `value` props instead of setting children on <textarea>.'),
                null != defaultValue)
              )
                throw Error('If you supply `defaultValue` on a <textarea>, do not pass children.');
              if (Array.isArray(children)) {
                if (!(children.length <= 1)) throw Error('<textarea> can only have at most one child.');
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = ''), (initialValue = defaultValue);
          }
          node._wrapperState = { initialValue: getToStringValue(initialValue) };
        }
        function updateWrapper$1(element, props) {
          var node = element,
            value = getToStringValue(props.value),
            defaultValue = getToStringValue(props.defaultValue);
          if (null != value) {
            var newValue = toString(value);
            newValue !== node.value && (node.value = newValue),
              null == props.defaultValue && node.defaultValue !== newValue && (node.defaultValue = newValue);
          }
          null != defaultValue && (node.defaultValue = toString(defaultValue));
        }
        function postMountWrapper$3(element, props) {
          var node = element,
            textContent = node.textContent;
          textContent === node._wrapperState.initialValue &&
            '' !== textContent &&
            null !== textContent &&
            (node.value = textContent);
        }
        var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml',
          SVG_NAMESPACE = 'http://www.w3.org/2000/svg',
          Namespaces_html = HTML_NAMESPACE,
          Namespaces_svg = SVG_NAMESPACE;
        function getIntrinsicNamespace(type) {
          switch (type) {
            case 'svg':
              return SVG_NAMESPACE;
            case 'math':
              return 'http://www.w3.org/1998/Math/MathML';
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          return null == parentNamespace || parentNamespace === HTML_NAMESPACE
            ? getIntrinsicNamespace(type)
            : parentNamespace === SVG_NAMESPACE && 'foreignObject' === type
            ? HTML_NAMESPACE
            : parentNamespace;
        }
        var reusableSVGContainer,
          func,
          setInnerHTML =
            ((func = function (node, html) {
              if (node.namespaceURI !== Namespaces_svg || 'innerHTML' in node) node.innerHTML = html;
              else {
                (reusableSVGContainer = reusableSVGContainer || document.createElement('div')).innerHTML =
                  '<svg>' + html.valueOf().toString() + '</svg>';
                for (var svgNode = reusableSVGContainer.firstChild; node.firstChild; )
                  node.removeChild(node.firstChild);
                for (; svgNode.firstChild; ) node.appendChild(svgNode.firstChild);
              }
            }),
            'undefined' != typeof MSApp && MSApp.execUnsafeLocalFunction
              ? function (arg0, arg1, arg2, arg3) {
                  MSApp.execUnsafeLocalFunction(function () {
                    return func(arg0, arg1, arg2, arg3);
                  });
                }
              : func),
          setTextContent = function (node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType)
                return void (firstChild.nodeValue = text);
            }
            node.textContent = text;
          };
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          return (
            (prefixes[styleProp.toLowerCase()] = eventName.toLowerCase()),
            (prefixes['Webkit' + styleProp] = 'webkit' + eventName),
            (prefixes['Moz' + styleProp] = 'moz' + eventName),
            prefixes
          );
        }
        var vendorPrefixes = {
            animationend: makePrefixMap('Animation', 'AnimationEnd'),
            animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
            animationstart: makePrefixMap('Animation', 'AnimationStart'),
            transitionend: makePrefixMap('Transition', 'TransitionEnd'),
          },
          prefixedEventNames = {},
          style = {};
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return (prefixedEventNames[eventName] = prefixMap[styleProp]);
          return eventName;
        }
        canUseDOM &&
          ((style = document.createElement('div').style),
          'AnimationEvent' in window ||
            (delete vendorPrefixes.animationend.animation,
            delete vendorPrefixes.animationiteration.animation,
            delete vendorPrefixes.animationstart.animation),
          'TransitionEvent' in window || delete vendorPrefixes.transitionend.transition);
        var TOP_ANIMATION_END = getVendorPrefixedEventName('animationend'),
          TOP_ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration'),
          TOP_ANIMATION_START = getVendorPrefixedEventName('animationstart'),
          TOP_TRANSITION_END = getVendorPrefixedEventName('transitionend'),
          mediaEventTypes = [
            'abort',
            'canplay',
            'canplaythrough',
            'durationchange',
            'emptied',
            'encrypted',
            'ended',
            'error',
            'loadeddata',
            'loadedmetadata',
            'loadstart',
            'pause',
            'play',
            'playing',
            'progress',
            'ratechange',
            'seeked',
            'seeking',
            'stalled',
            'suspend',
            'timeupdate',
            'volumechange',
            'waiting',
          ];
        var elementListenerMap = new ('function' == typeof WeakMap ? WeakMap : Map)();
        function getListenerMapForElement(element) {
          var listenerMap = elementListenerMap.get(element);
          return (
            void 0 === listenerMap && ((listenerMap = new Map()), elementListenerMap.set(element, listenerMap)),
            listenerMap
          );
        }
        function get(key) {
          return key._reactInternalFiber;
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber,
            nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            var nextNode = node;
            do {
              0 != (1026 & (node = nextNode).effectTag) && (nearestMounted = node.return), (nextNode = node.return);
            } while (nextNode);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            if (null === suspenseState) {
              var current = fiber.alternate;
              null !== current && (suspenseState = current.memoizedState);
            }
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return 3 === fiber.tag ? fiber.stateNode.containerInfo : null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) throw Error('Unable to find node on an unmounted component.');
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (null === nearestMounted) throw Error('Unable to find node on an unmounted component.');
            return nearestMounted !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              var nextParent = parentA.return;
              if (null !== nextParent) {
                a = b = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (var child = parentA.child; child; ) {
                if (child === a) return assertIsMounted(parentA), fiber;
                if (child === b) return assertIsMounted(parentA), alternate;
                child = child.sibling;
              }
              throw Error('Unable to find node on an unmounted component.');
            }
            if (a.return !== b.return) (a = parentA), (b = parentB);
            else {
              for (var didFindChild = !1, _child = parentA.child; _child; ) {
                if (_child === a) {
                  (didFindChild = !0), (a = parentA), (b = parentB);
                  break;
                }
                if (_child === b) {
                  (didFindChild = !0), (b = parentA), (a = parentB);
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    (didFindChild = !0), (a = parentB), (b = parentA);
                    break;
                  }
                  if (_child === b) {
                    (didFindChild = !0), (b = parentB), (a = parentA);
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag) throw Error('Unable to find node on an unmounted component.');
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          if (!currentParent) return null;
          for (var node = currentParent; ; ) {
            if (5 === node.tag || 6 === node.tag) return node;
            if (node.child) (node.child.return = node), (node = node.child);
            else {
              if (node === currentParent) return null;
              for (; !node.sibling; ) {
                if (!node.return || node.return === currentParent) return null;
                node = node.return;
              }
              (node.sibling.return = node.return), (node = node.sibling);
            }
          }
          return null;
        }
        function accumulateInto(current, next) {
          if (null == next) throw Error('accumulateInto(...): Accumulated items must not be null or undefined.');
          return null == current
            ? next
            : Array.isArray(current)
            ? Array.isArray(next)
              ? (current.push.apply(current, next), current)
              : (current.push(next), current)
            : Array.isArray(next)
            ? [current].concat(next)
            : [current, next];
        }
        function forEachAccumulated(arr, cb, scope) {
          Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
        }
        var eventQueue = null,
          executeDispatchesAndRelease = function (event) {
            event &&
              (!(function executeDispatchesInOrder(event) {
                var dispatchListeners = event._dispatchListeners,
                  dispatchInstances = event._dispatchInstances;
                if ((validateEventDispatches(event), Array.isArray(dispatchListeners)))
                  for (var i = 0; i < dispatchListeners.length && !event.isPropagationStopped(); i++)
                    executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);
                else dispatchListeners && executeDispatch(event, dispatchListeners, dispatchInstances);
                (event._dispatchListeners = null), (event._dispatchInstances = null);
              })(event),
              event.isPersistent() || event.constructor.release(event));
          },
          executeDispatchesAndReleaseTopLevel = function (e) {
            return executeDispatchesAndRelease(e);
          };
        function runEventsInBatch(events) {
          null !== events && (eventQueue = accumulateInto(eventQueue, events));
          var processingEventQueue = eventQueue;
          if (((eventQueue = null), processingEventQueue)) {
            if ((forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel), eventQueue))
              throw Error(
                'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'
              );
            !(function rethrowCaughtError() {
              if (hasRethrowError) {
                var error = rethrowError;
                throw ((hasRethrowError = !1), (rethrowError = null), error);
              }
            })();
          }
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          return (
            target.correspondingUseElement && (target = target.correspondingUseElement),
            3 === target.nodeType ? target.parentNode : target
          );
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return !1;
          var eventName = 'on' + eventNameSuffix,
            isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement('div');
            element.setAttribute(eventName, 'return;'), (isSupported = 'function' == typeof element[eventName]);
          }
          return isSupported;
        }
        var attemptUserBlockingHydration,
          attemptContinuousHydration,
          attemptHydrationAtCurrentPriority,
          callbackBookkeepingPool = [];
        function findRootContainerNode(inst) {
          if (3 === inst.tag) return inst.stateNode.containerInfo;
          for (; inst.return; ) inst = inst.return;
          return 3 !== inst.tag ? null : inst.stateNode.containerInfo;
        }
        function runExtractedPluginEventsInBatch(
          topLevelType,
          targetInst,
          nativeEvent,
          nativeEventTarget,
          eventSystemFlags
        ) {
          runEventsInBatch(
            (function extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              for (var events = null, i = 0; i < plugins.length; i++) {
                var possiblePlugin = plugins[i];
                if (possiblePlugin) {
                  var extractedEvents = possiblePlugin.extractEvents(
                    topLevelType,
                    targetInst,
                    nativeEvent,
                    nativeEventTarget,
                    eventSystemFlags
                  );
                  extractedEvents && (events = accumulateInto(events, extractedEvents));
                }
              }
              return events;
            })(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags)
          );
        }
        function handleTopLevel(bookKeeping) {
          var targetInst = bookKeeping.targetInst,
            ancestor = targetInst;
          do {
            if (!ancestor) {
              bookKeeping.ancestors.push(ancestor);
              break;
            }
            var root = findRootContainerNode(ancestor);
            if (!root) break;
            var tag = ancestor.tag;
            (5 !== tag && 6 !== tag) || bookKeeping.ancestors.push(ancestor),
              (ancestor = getClosestInstanceFromNode(root));
          } while (ancestor);
          for (var i = 0; i < bookKeeping.ancestors.length; i++) {
            targetInst = bookKeeping.ancestors[i];
            var eventTarget = getEventTarget(bookKeeping.nativeEvent),
              topLevelType = bookKeeping.topLevelType,
              nativeEvent = bookKeeping.nativeEvent,
              eventSystemFlags = bookKeeping.eventSystemFlags;
            0 === i && (eventSystemFlags |= 64),
              runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget, eventSystemFlags);
          }
        }
        function dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst) {
          var bookKeeping = (function getTopLevelCallbackBookKeeping(
            topLevelType,
            nativeEvent,
            targetInst,
            eventSystemFlags
          ) {
            if (callbackBookkeepingPool.length) {
              var instance = callbackBookkeepingPool.pop();
              return (
                (instance.topLevelType = topLevelType),
                (instance.eventSystemFlags = eventSystemFlags),
                (instance.nativeEvent = nativeEvent),
                (instance.targetInst = targetInst),
                instance
              );
            }
            return { topLevelType, eventSystemFlags, nativeEvent, targetInst, ancestors: [] };
          })(topLevelType, nativeEvent, targetInst, eventSystemFlags);
          try {
            !(function batchedEventUpdates(fn, a, b) {
              if (isBatchingEventUpdates) return fn(a, b);
              isBatchingEventUpdates = !0;
              try {
                return batchedEventUpdatesImpl(fn, a, b);
              } finally {
                (isBatchingEventUpdates = !1), finishEventHandler();
              }
            })(handleTopLevel, bookKeeping);
          } finally {
            !(function releaseTopLevelCallbackBookKeeping(instance) {
              (instance.topLevelType = null),
                (instance.nativeEvent = null),
                (instance.targetInst = null),
                (instance.ancestors.length = 0),
                callbackBookkeepingPool.length < 10 && callbackBookkeepingPool.push(instance);
            })(bookKeeping);
          }
        }
        function legacyListenToTopLevelEvent(topLevelType, mountAt, listenerMap) {
          if (!listenerMap.has(topLevelType)) {
            switch (topLevelType) {
              case 'scroll':
                trapCapturedEvent('scroll', mountAt);
                break;
              case 'focus':
              case 'blur':
                trapCapturedEvent('focus', mountAt),
                  trapCapturedEvent('blur', mountAt),
                  listenerMap.set('blur', null),
                  listenerMap.set('focus', null);
                break;
              case 'cancel':
              case 'close':
                isEventSupported(topLevelType) && trapCapturedEvent(topLevelType, mountAt);
                break;
              case 'invalid':
              case 'submit':
              case 'reset':
                break;
              default:
                -1 !== mediaEventTypes.indexOf(topLevelType) || trapBubbledEvent(topLevelType, mountAt);
            }
            listenerMap.set(topLevelType, null);
          }
        }
        var hasScheduledReplayAttempt = !1,
          queuedDiscreteEvents = [],
          queuedFocus = null,
          queuedDrag = null,
          queuedMouse = null,
          queuedPointers = new Map(),
          queuedPointerCaptures = new Map(),
          queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
            'mousedown',
            'mouseup',
            'touchcancel',
            'touchend',
            'touchstart',
            'auxclick',
            'dblclick',
            'pointercancel',
            'pointerdown',
            'pointerup',
            'dragend',
            'dragstart',
            'drop',
            'compositionend',
            'compositionstart',
            'keydown',
            'keypress',
            'keyup',
            'input',
            'textInput',
            'close',
            'cancel',
            'copy',
            'cut',
            'paste',
            'click',
            'change',
            'contextmenu',
            'reset',
            'submit',
          ],
          continuousReplayableEvents = [
            'focus',
            'blur',
            'dragenter',
            'dragleave',
            'mouseover',
            'mouseout',
            'pointerover',
            'pointerout',
            'gotpointercapture',
            'lostpointercapture',
          ];
        function isReplayableDiscreteEvent(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function trapReplayableEventForDocument(topLevelType, document, listenerMap) {
          legacyListenToTopLevelEvent(topLevelType, document, listenerMap);
        }
        function createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {
          return { blockedOn, topLevelType, eventSystemFlags: 32 | eventSystemFlags, nativeEvent, container };
        }
        function queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {
          var queuedEvent = createQueuedReplayableEvent(
            blockedOn,
            topLevelType,
            eventSystemFlags,
            container,
            nativeEvent
          );
          queuedDiscreteEvents.push(queuedEvent);
        }
        function clearIfContinuousEvent(topLevelType, nativeEvent) {
          switch (topLevelType) {
            case 'focus':
            case 'blur':
              queuedFocus = null;
              break;
            case 'dragenter':
            case 'dragleave':
              queuedDrag = null;
              break;
            case 'mouseover':
            case 'mouseout':
              queuedMouse = null;
              break;
            case 'pointerover':
            case 'pointerout':
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            case 'gotpointercapture':
            case 'lostpointercapture':
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(
          existingQueuedEvent,
          blockedOn,
          topLevelType,
          eventSystemFlags,
          container,
          nativeEvent
        ) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(
              blockedOn,
              topLevelType,
              eventSystemFlags,
              container,
              nativeEvent
            );
            if (null !== blockedOn) {
              var _fiber2 = getInstanceFromNode$1(blockedOn);
              null !== _fiber2 && attemptContinuousHydration(_fiber2);
            }
            return queuedEvent;
          }
          return (existingQueuedEvent.eventSystemFlags |= eventSystemFlags), existingQueuedEvent;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== instance)
                  return (
                    (queuedTarget.blockedOn = instance),
                    void Scheduler.unstable_runWithPriority(queuedTarget.priority, function () {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    })
                  );
              } else if (3 === tag) {
                if (nearestMounted.stateNode.hydrate)
                  return void (queuedTarget.blockedOn = getContainerFromFiber(nearestMounted));
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return !1;
          var nextBlockedOn = attemptToDispatchEvent(
            queuedEvent.topLevelType,
            queuedEvent.eventSystemFlags,
            queuedEvent.container,
            queuedEvent.nativeEvent
          );
          if (null !== nextBlockedOn) {
            var _fiber3 = getInstanceFromNode$1(nextBlockedOn);
            return null !== _fiber3 && attemptContinuousHydration(_fiber3), (queuedEvent.blockedOn = nextBlockedOn), !1;
          }
          return !0;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
          for (hasScheduledReplayAttempt = !1; queuedDiscreteEvents.length > 0; ) {
            var nextDiscreteEvent = queuedDiscreteEvents[0];
            if (null !== nextDiscreteEvent.blockedOn) {
              var _fiber4 = getInstanceFromNode$1(nextDiscreteEvent.blockedOn);
              null !== _fiber4 && attemptUserBlockingHydration(_fiber4);
              break;
            }
            var nextBlockedOn = attemptToDispatchEvent(
              nextDiscreteEvent.topLevelType,
              nextDiscreteEvent.eventSystemFlags,
              nextDiscreteEvent.container,
              nextDiscreteEvent.nativeEvent
            );
            null !== nextBlockedOn ? (nextDiscreteEvent.blockedOn = nextBlockedOn) : queuedDiscreteEvents.shift();
          }
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null),
            null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null),
            null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null),
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap),
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked &&
            ((queuedEvent.blockedOn = null),
            hasScheduledReplayAttempt ||
              ((hasScheduledReplayAttempt = !0),
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i = 1; i < queuedDiscreteEvents.length; i++) {
              var queuedEvent = queuedDiscreteEvents[i];
              queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null);
            }
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked),
            null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked),
            null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          var unblock = function (queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          };
          queuedPointers.forEach(unblock), queuedPointerCaptures.forEach(unblock);
          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; queuedExplicitHydrationTargets.length > 0; ) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (null !== nextExplicitTarget.blockedOn) break;
            attemptExplicitHydrationTarget(nextExplicitTarget),
              null === nextExplicitTarget.blockedOn && queuedExplicitHydrationTargets.shift();
          }
        }
        var simpleEventPluginEventTypes = {},
          topLevelEventsToDispatchConfig = new Map(),
          eventPriorities = new Map(),
          otherDiscreteEvents = [
            'change',
            'selectionchange',
            'textInput',
            'compositionstart',
            'compositionend',
            'compositionupdate',
          ],
          userBlockingPairsForSimpleEventPlugin = [
            'drag',
            'drag',
            'dragenter',
            'dragEnter',
            'dragexit',
            'dragExit',
            'dragleave',
            'dragLeave',
            'dragover',
            'dragOver',
            'mousemove',
            'mouseMove',
            'mouseout',
            'mouseOut',
            'mouseover',
            'mouseOver',
            'pointermove',
            'pointerMove',
            'pointerout',
            'pointerOut',
            'pointerover',
            'pointerOver',
            'scroll',
            'scroll',
            'toggle',
            'toggle',
            'touchmove',
            'touchMove',
            'wheel',
            'wheel',
          ],
          continuousPairsForSimpleEventPlugin = [
            'abort',
            'abort',
            TOP_ANIMATION_END,
            'animationEnd',
            TOP_ANIMATION_ITERATION,
            'animationIteration',
            TOP_ANIMATION_START,
            'animationStart',
            'canplay',
            'canPlay',
            'canplaythrough',
            'canPlayThrough',
            'durationchange',
            'durationChange',
            'emptied',
            'emptied',
            'encrypted',
            'encrypted',
            'ended',
            'ended',
            'error',
            'error',
            'gotpointercapture',
            'gotPointerCapture',
            'load',
            'load',
            'loadeddata',
            'loadedData',
            'loadedmetadata',
            'loadedMetadata',
            'loadstart',
            'loadStart',
            'lostpointercapture',
            'lostPointerCapture',
            'playing',
            'playing',
            'progress',
            'progress',
            'seeking',
            'seeking',
            'stalled',
            'stalled',
            'suspend',
            'suspend',
            'timeupdate',
            'timeUpdate',
            TOP_TRANSITION_END,
            'transitionEnd',
            'waiting',
            'waiting',
          ];
        function processSimpleEventPluginPairsByPriority(eventTypes, priority) {
          for (var i = 0; i < eventTypes.length; i += 2) {
            var topEvent = eventTypes[i],
              event = eventTypes[i + 1],
              onEvent = 'on' + (event[0].toUpperCase() + event.slice(1)),
              config = {
                phasedRegistrationNames: { bubbled: onEvent, captured: onEvent + 'Capture' },
                dependencies: [topEvent],
                eventPriority: priority,
              };
            eventPriorities.set(topEvent, priority),
              topLevelEventsToDispatchConfig.set(topEvent, config),
              (simpleEventPluginEventTypes[event] = config);
          }
        }
        processSimpleEventPluginPairsByPriority(
          [
            'blur',
            'blur',
            'cancel',
            'cancel',
            'click',
            'click',
            'close',
            'close',
            'contextmenu',
            'contextMenu',
            'copy',
            'copy',
            'cut',
            'cut',
            'auxclick',
            'auxClick',
            'dblclick',
            'doubleClick',
            'dragend',
            'dragEnd',
            'dragstart',
            'dragStart',
            'drop',
            'drop',
            'focus',
            'focus',
            'input',
            'input',
            'invalid',
            'invalid',
            'keydown',
            'keyDown',
            'keypress',
            'keyPress',
            'keyup',
            'keyUp',
            'mousedown',
            'mouseDown',
            'mouseup',
            'mouseUp',
            'paste',
            'paste',
            'pause',
            'pause',
            'play',
            'play',
            'pointercancel',
            'pointerCancel',
            'pointerdown',
            'pointerDown',
            'pointerup',
            'pointerUp',
            'ratechange',
            'rateChange',
            'reset',
            'reset',
            'seeked',
            'seeked',
            'submit',
            'submit',
            'touchcancel',
            'touchCancel',
            'touchend',
            'touchEnd',
            'touchstart',
            'touchStart',
            'volumechange',
            'volumeChange',
          ],
          0
        ),
          processSimpleEventPluginPairsByPriority(userBlockingPairsForSimpleEventPlugin, 1),
          processSimpleEventPluginPairsByPriority(continuousPairsForSimpleEventPlugin, 2),
          (function processTopEventPairsByPriority(eventTypes, priority) {
            for (var i = 0; i < eventTypes.length; i++) eventPriorities.set(eventTypes[i], priority);
          })(otherDiscreteEvents, 0);
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
          runWithPriority = Scheduler.unstable_runWithPriority,
          _enabled = !0;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function trapBubbledEvent(topLevelType, element) {
          trapEventForPluginEventSystem(element, topLevelType, !1);
        }
        function trapCapturedEvent(topLevelType, element) {
          trapEventForPluginEventSystem(element, topLevelType, !0);
        }
        function trapEventForPluginEventSystem(container, topLevelType, capture) {
          var listener;
          switch (
            (function getEventPriorityForPluginSystem(topLevelType) {
              var priority = eventPriorities.get(topLevelType);
              return void 0 === priority ? 2 : priority;
            })(topLevelType)
          ) {
            case 0:
              listener = dispatchDiscreteEvent.bind(null, topLevelType, 1, container);
              break;
            case 1:
              listener = dispatchUserBlockingUpdate.bind(null, topLevelType, 1, container);
              break;
            case 2:
            default:
              listener = dispatchEvent.bind(null, topLevelType, 1, container);
          }
          var rawEventName = topLevelType;
          capture
            ? (function addEventCaptureListener(element, eventType, listener) {
                element.addEventListener(eventType, listener, !0);
              })(container, rawEventName, listener)
            : (function addEventBubbleListener(element, eventType, listener) {
                element.addEventListener(eventType, listener, !1);
              })(container, rawEventName, listener);
        }
        function dispatchDiscreteEvent(topLevelType, eventSystemFlags, container, nativeEvent) {
          !(function flushDiscreteUpdatesIfNeeded(timeStamp) {
            isInsideEventHandler || flushDiscreteUpdatesImpl();
          })(nativeEvent.timeStamp),
            (function discreteUpdates(fn, a, b, c, d) {
              var prevIsInsideEventHandler = isInsideEventHandler;
              isInsideEventHandler = !0;
              try {
                return discreteUpdatesImpl(fn, a, b, c, d);
              } finally {
                (isInsideEventHandler = prevIsInsideEventHandler) || finishEventHandler();
              }
            })(dispatchEvent, topLevelType, eventSystemFlags, container, nativeEvent);
        }
        function dispatchUserBlockingUpdate(topLevelType, eventSystemFlags, container, nativeEvent) {
          runWithPriority(
            UserBlockingPriority,
            dispatchEvent.bind(null, topLevelType, eventSystemFlags, container, nativeEvent)
          );
        }
        function dispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {
          if (_enabled)
            if (
              (function hasQueuedDiscreteEvents() {
                return queuedDiscreteEvents.length > 0;
              })() &&
              isReplayableDiscreteEvent(topLevelType)
            )
              queueDiscreteEvent(null, topLevelType, eventSystemFlags, container, nativeEvent);
            else {
              var blockedOn = attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent);
              null !== blockedOn
                ? isReplayableDiscreteEvent(topLevelType)
                  ? queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent)
                  : (function queueIfContinuousEvent(
                      blockedOn,
                      topLevelType,
                      eventSystemFlags,
                      container,
                      nativeEvent
                    ) {
                      switch (topLevelType) {
                        case 'focus':
                          return (
                            (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                              queuedFocus,
                              blockedOn,
                              topLevelType,
                              eventSystemFlags,
                              container,
                              nativeEvent
                            )),
                            !0
                          );
                        case 'dragenter':
                          return (
                            (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                              queuedDrag,
                              blockedOn,
                              topLevelType,
                              eventSystemFlags,
                              container,
                              nativeEvent
                            )),
                            !0
                          );
                        case 'mouseover':
                          return (
                            (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                              queuedMouse,
                              blockedOn,
                              topLevelType,
                              eventSystemFlags,
                              container,
                              nativeEvent
                            )),
                            !0
                          );
                        case 'pointerover':
                          var pointerEvent = nativeEvent,
                            pointerId = pointerEvent.pointerId;
                          return (
                            queuedPointers.set(
                              pointerId,
                              accumulateOrCreateContinuousQueuedReplayableEvent(
                                queuedPointers.get(pointerId) || null,
                                blockedOn,
                                topLevelType,
                                eventSystemFlags,
                                container,
                                pointerEvent
                              )
                            ),
                            !0
                          );
                        case 'gotpointercapture':
                          var _pointerEvent = nativeEvent,
                            _pointerId2 = _pointerEvent.pointerId;
                          return (
                            queuedPointerCaptures.set(
                              _pointerId2,
                              accumulateOrCreateContinuousQueuedReplayableEvent(
                                queuedPointerCaptures.get(_pointerId2) || null,
                                blockedOn,
                                topLevelType,
                                eventSystemFlags,
                                container,
                                _pointerEvent
                              )
                            ),
                            !0
                          );
                      }
                      return !1;
                    })(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) ||
                    (clearIfContinuousEvent(topLevelType, nativeEvent),
                    dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, null))
                : clearIfContinuousEvent(topLevelType, nativeEvent);
            }
        }
        function attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {
          var targetInst = getClosestInstanceFromNode(getEventTarget(nativeEvent));
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null === nearestMounted) targetInst = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== instance) return instance;
                targetInst = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.hydrate) return getContainerFromFiber(nearestMounted);
                targetInst = null;
              } else nearestMounted !== targetInst && (targetInst = null);
            }
          }
          return dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst), null;
        }
        var shorthandToLonghand = {
            animation: [
              'animationDelay',
              'animationDirection',
              'animationDuration',
              'animationFillMode',
              'animationIterationCount',
              'animationName',
              'animationPlayState',
              'animationTimingFunction',
            ],
            background: [
              'backgroundAttachment',
              'backgroundClip',
              'backgroundColor',
              'backgroundImage',
              'backgroundOrigin',
              'backgroundPositionX',
              'backgroundPositionY',
              'backgroundRepeat',
              'backgroundSize',
            ],
            backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
            border: [
              'borderBottomColor',
              'borderBottomStyle',
              'borderBottomWidth',
              'borderImageOutset',
              'borderImageRepeat',
              'borderImageSlice',
              'borderImageSource',
              'borderImageWidth',
              'borderLeftColor',
              'borderLeftStyle',
              'borderLeftWidth',
              'borderRightColor',
              'borderRightStyle',
              'borderRightWidth',
              'borderTopColor',
              'borderTopStyle',
              'borderTopWidth',
            ],
            borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
            borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
            borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
            borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
            borderImage: [
              'borderImageOutset',
              'borderImageRepeat',
              'borderImageSlice',
              'borderImageSource',
              'borderImageWidth',
            ],
            borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
            borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
            borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
            borderRadius: [
              'borderBottomLeftRadius',
              'borderBottomRightRadius',
              'borderTopLeftRadius',
              'borderTopRightRadius',
            ],
            borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
            borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
            borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
            borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
            columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
            columns: ['columnCount', 'columnWidth'],
            flex: ['flexBasis', 'flexGrow', 'flexShrink'],
            flexFlow: ['flexDirection', 'flexWrap'],
            font: [
              'fontFamily',
              'fontFeatureSettings',
              'fontKerning',
              'fontLanguageOverride',
              'fontSize',
              'fontSizeAdjust',
              'fontStretch',
              'fontStyle',
              'fontVariant',
              'fontVariantAlternates',
              'fontVariantCaps',
              'fontVariantEastAsian',
              'fontVariantLigatures',
              'fontVariantNumeric',
              'fontVariantPosition',
              'fontWeight',
              'lineHeight',
            ],
            fontVariant: [
              'fontVariantAlternates',
              'fontVariantCaps',
              'fontVariantEastAsian',
              'fontVariantLigatures',
              'fontVariantNumeric',
              'fontVariantPosition',
            ],
            gap: ['columnGap', 'rowGap'],
            grid: [
              'gridAutoColumns',
              'gridAutoFlow',
              'gridAutoRows',
              'gridTemplateAreas',
              'gridTemplateColumns',
              'gridTemplateRows',
            ],
            gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
            gridColumn: ['gridColumnEnd', 'gridColumnStart'],
            gridColumnGap: ['columnGap'],
            gridGap: ['columnGap', 'rowGap'],
            gridRow: ['gridRowEnd', 'gridRowStart'],
            gridRowGap: ['rowGap'],
            gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
            listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
            margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
            marker: ['markerEnd', 'markerMid', 'markerStart'],
            mask: [
              'maskClip',
              'maskComposite',
              'maskImage',
              'maskMode',
              'maskOrigin',
              'maskPositionX',
              'maskPositionY',
              'maskRepeat',
              'maskSize',
            ],
            maskPosition: ['maskPositionX', 'maskPositionY'],
            outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
            overflow: ['overflowX', 'overflowY'],
            padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
            placeContent: ['alignContent', 'justifyContent'],
            placeItems: ['alignItems', 'justifyItems'],
            placeSelf: ['alignSelf', 'justifySelf'],
            textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
            textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
            transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
            wordWrap: ['overflowWrap'],
          },
          isUnitlessNumber = {
            animationIterationCount: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0,
          };
        var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
        function dangerousStyleValue(name, value, isCustomProperty) {
          return null == value || 'boolean' == typeof value || '' === value
            ? ''
            : isCustomProperty ||
              'number' != typeof value ||
              0 === value ||
              (isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])
            ? ('' + value).trim()
            : value + 'px';
        }
        Object.keys(isUnitlessNumber).forEach(function (prop) {
          prefixes.forEach(function (prefix) {
            isUnitlessNumber[
              (function prefixKey(prefix, key) {
                return prefix + key.charAt(0).toUpperCase() + key.substring(1);
              })(prefix, prop)
            ] = isUnitlessNumber[prop];
          });
        });
        var uppercasePattern = /([A-Z])/g,
          msPattern = /^ms-/;
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
          msPattern$1 = /^-ms-/,
          hyphenPattern = /-(.)/g,
          badStyleValueWithSemicolonPattern = /;\s*$/,
          warnedStyleNames = {},
          warnedStyleValues = {},
          warnedForNaNValue = !1,
          warnedForInfinityValue = !1,
          warnHyphenatedStyleName = function (name) {
            (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) ||
              ((warnedStyleNames[name] = !0),
              error(
                'Unsupported style property %s. Did you mean %s?',
                name,
                name.replace(msPattern$1, 'ms-').replace(hyphenPattern, function (_, character) {
                  return character.toUpperCase();
                })
              ));
          },
          warnValidStyle$1 = function (name, value) {
            name.indexOf('-') > -1
              ? warnHyphenatedStyleName(name)
              : badVendoredStyleNamePattern.test(name)
              ? (function (name) {
                  (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) ||
                    ((warnedStyleNames[name] = !0),
                    error(
                      'Unsupported vendor-prefixed style property %s. Did you mean %s?',
                      name,
                      name.charAt(0).toUpperCase() + name.slice(1)
                    ));
                })(name)
              : badStyleValueWithSemicolonPattern.test(value) &&
                (function (name, value) {
                  (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) ||
                    ((warnedStyleValues[value] = !0),
                    error(
                      'Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.',
                      name,
                      value.replace(badStyleValueWithSemicolonPattern, '')
                    ));
                })(name, value),
              'number' == typeof value &&
                (isNaN(value)
                  ? (function (name, value) {
                      warnedForNaNValue ||
                        ((warnedForNaNValue = !0),
                        error('`NaN` is an invalid value for the `%s` css style property.', name));
                    })(name)
                  : isFinite(value) ||
                    (function (name, value) {
                      warnedForInfinityValue ||
                        ((warnedForInfinityValue = !0),
                        error('`Infinity` is an invalid value for the `%s` css style property.', name));
                    })(name));
          };
        function createDangerousStringForStyles(styles) {
          var serialized = '',
            delimiter = '';
          for (var styleName in styles)
            if (styles.hasOwnProperty(styleName)) {
              var styleValue = styles[styleName];
              if (null != styleValue) {
                var isCustomProperty = 0 === styleName.indexOf('--');
                (serialized +=
                  delimiter +
                  (isCustomProperty
                    ? styleName
                    : styleName.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-')) +
                  ':'),
                  (serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty)),
                  (delimiter = ';');
              }
            }
          return serialized || null;
        }
        function setValueForStyles(node, styles) {
          var style = node.style;
          for (var styleName in styles)
            if (styles.hasOwnProperty(styleName)) {
              var isCustomProperty = 0 === styleName.indexOf('--');
              isCustomProperty || warnValidStyle$1(styleName, styles[styleName]);
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              'float' === styleName && (styleName = 'cssFloat'),
                isCustomProperty ? style.setProperty(styleName, styleValue) : (style[styleName] = styleValue);
            }
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key in styles)
            for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
              expanded[longhands[i]] = key;
          return expanded;
        }
        var voidElementTags = _assign(
            { menuitem: !0 },
            {
              area: !0,
              base: !0,
              br: !0,
              col: !0,
              embed: !0,
              hr: !0,
              img: !0,
              input: !0,
              keygen: !0,
              link: !0,
              meta: !0,
              param: !0,
              source: !0,
              track: !0,
              wbr: !0,
            }
          ),
          ReactDebugCurrentFrame$3 = null;
        function assertValidProps(tag, props) {
          if (props) {
            if (voidElementTags[tag] && (null != props.children || null != props.dangerouslySetInnerHTML))
              throw Error(
                tag +
                  ' is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.' +
                  ReactDebugCurrentFrame$3.getStackAddendum()
              );
            if (null != props.dangerouslySetInnerHTML) {
              if (null != props.children)
                throw Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
              if ('object' != typeof props.dangerouslySetInnerHTML || !('__html' in props.dangerouslySetInnerHTML))
                throw Error(
                  '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'
                );
            }
            if (
              (!props.suppressContentEditableWarning &&
                props.contentEditable &&
                null != props.children &&
                error(
                  'A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.'
                ),
              null != props.style && 'object' != typeof props.style)
            )
              throw Error(
                "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." +
                  ReactDebugCurrentFrame$3.getStackAddendum()
              );
          }
        }
        function isCustomComponent(tagName, props) {
          if (-1 === tagName.indexOf('-')) return 'string' == typeof props.is;
          switch (tagName) {
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
              return !1;
            default:
              return !0;
          }
        }
        ReactDebugCurrentFrame$3 = ReactSharedInternals.ReactDebugCurrentFrame;
        var possibleStandardNames = {
            accept: 'accept',
            acceptcharset: 'acceptCharset',
            'accept-charset': 'acceptCharset',
            accesskey: 'accessKey',
            action: 'action',
            allowfullscreen: 'allowFullScreen',
            alt: 'alt',
            as: 'as',
            async: 'async',
            autocapitalize: 'autoCapitalize',
            autocomplete: 'autoComplete',
            autocorrect: 'autoCorrect',
            autofocus: 'autoFocus',
            autoplay: 'autoPlay',
            autosave: 'autoSave',
            capture: 'capture',
            cellpadding: 'cellPadding',
            cellspacing: 'cellSpacing',
            challenge: 'challenge',
            charset: 'charSet',
            checked: 'checked',
            children: 'children',
            cite: 'cite',
            class: 'className',
            classid: 'classID',
            classname: 'className',
            cols: 'cols',
            colspan: 'colSpan',
            content: 'content',
            contenteditable: 'contentEditable',
            contextmenu: 'contextMenu',
            controls: 'controls',
            controlslist: 'controlsList',
            coords: 'coords',
            crossorigin: 'crossOrigin',
            dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
            data: 'data',
            datetime: 'dateTime',
            default: 'default',
            defaultchecked: 'defaultChecked',
            defaultvalue: 'defaultValue',
            defer: 'defer',
            dir: 'dir',
            disabled: 'disabled',
            disablepictureinpicture: 'disablePictureInPicture',
            download: 'download',
            draggable: 'draggable',
            enctype: 'encType',
            for: 'htmlFor',
            form: 'form',
            formmethod: 'formMethod',
            formaction: 'formAction',
            formenctype: 'formEncType',
            formnovalidate: 'formNoValidate',
            formtarget: 'formTarget',
            frameborder: 'frameBorder',
            headers: 'headers',
            height: 'height',
            hidden: 'hidden',
            high: 'high',
            href: 'href',
            hreflang: 'hrefLang',
            htmlfor: 'htmlFor',
            httpequiv: 'httpEquiv',
            'http-equiv': 'httpEquiv',
            icon: 'icon',
            id: 'id',
            innerhtml: 'innerHTML',
            inputmode: 'inputMode',
            integrity: 'integrity',
            is: 'is',
            itemid: 'itemID',
            itemprop: 'itemProp',
            itemref: 'itemRef',
            itemscope: 'itemScope',
            itemtype: 'itemType',
            keyparams: 'keyParams',
            keytype: 'keyType',
            kind: 'kind',
            label: 'label',
            lang: 'lang',
            list: 'list',
            loop: 'loop',
            low: 'low',
            manifest: 'manifest',
            marginwidth: 'marginWidth',
            marginheight: 'marginHeight',
            max: 'max',
            maxlength: 'maxLength',
            media: 'media',
            mediagroup: 'mediaGroup',
            method: 'method',
            min: 'min',
            minlength: 'minLength',
            multiple: 'multiple',
            muted: 'muted',
            name: 'name',
            nomodule: 'noModule',
            nonce: 'nonce',
            novalidate: 'noValidate',
            open: 'open',
            optimum: 'optimum',
            pattern: 'pattern',
            placeholder: 'placeholder',
            playsinline: 'playsInline',
            poster: 'poster',
            preload: 'preload',
            profile: 'profile',
            radiogroup: 'radioGroup',
            readonly: 'readOnly',
            referrerpolicy: 'referrerPolicy',
            rel: 'rel',
            required: 'required',
            reversed: 'reversed',
            role: 'role',
            rows: 'rows',
            rowspan: 'rowSpan',
            sandbox: 'sandbox',
            scope: 'scope',
            scoped: 'scoped',
            scrolling: 'scrolling',
            seamless: 'seamless',
            selected: 'selected',
            shape: 'shape',
            size: 'size',
            sizes: 'sizes',
            span: 'span',
            spellcheck: 'spellCheck',
            src: 'src',
            srcdoc: 'srcDoc',
            srclang: 'srcLang',
            srcset: 'srcSet',
            start: 'start',
            step: 'step',
            style: 'style',
            summary: 'summary',
            tabindex: 'tabIndex',
            target: 'target',
            title: 'title',
            type: 'type',
            usemap: 'useMap',
            value: 'value',
            width: 'width',
            wmode: 'wmode',
            wrap: 'wrap',
            about: 'about',
            accentheight: 'accentHeight',
            'accent-height': 'accentHeight',
            accumulate: 'accumulate',
            additive: 'additive',
            alignmentbaseline: 'alignmentBaseline',
            'alignment-baseline': 'alignmentBaseline',
            allowreorder: 'allowReorder',
            alphabetic: 'alphabetic',
            amplitude: 'amplitude',
            arabicform: 'arabicForm',
            'arabic-form': 'arabicForm',
            ascent: 'ascent',
            attributename: 'attributeName',
            attributetype: 'attributeType',
            autoreverse: 'autoReverse',
            azimuth: 'azimuth',
            basefrequency: 'baseFrequency',
            baselineshift: 'baselineShift',
            'baseline-shift': 'baselineShift',
            baseprofile: 'baseProfile',
            bbox: 'bbox',
            begin: 'begin',
            bias: 'bias',
            by: 'by',
            calcmode: 'calcMode',
            capheight: 'capHeight',
            'cap-height': 'capHeight',
            clip: 'clip',
            clippath: 'clipPath',
            'clip-path': 'clipPath',
            clippathunits: 'clipPathUnits',
            cliprule: 'clipRule',
            'clip-rule': 'clipRule',
            color: 'color',
            colorinterpolation: 'colorInterpolation',
            'color-interpolation': 'colorInterpolation',
            colorinterpolationfilters: 'colorInterpolationFilters',
            'color-interpolation-filters': 'colorInterpolationFilters',
            colorprofile: 'colorProfile',
            'color-profile': 'colorProfile',
            colorrendering: 'colorRendering',
            'color-rendering': 'colorRendering',
            contentscripttype: 'contentScriptType',
            contentstyletype: 'contentStyleType',
            cursor: 'cursor',
            cx: 'cx',
            cy: 'cy',
            d: 'd',
            datatype: 'datatype',
            decelerate: 'decelerate',
            descent: 'descent',
            diffuseconstant: 'diffuseConstant',
            direction: 'direction',
            display: 'display',
            divisor: 'divisor',
            dominantbaseline: 'dominantBaseline',
            'dominant-baseline': 'dominantBaseline',
            dur: 'dur',
            dx: 'dx',
            dy: 'dy',
            edgemode: 'edgeMode',
            elevation: 'elevation',
            enablebackground: 'enableBackground',
            'enable-background': 'enableBackground',
            end: 'end',
            exponent: 'exponent',
            externalresourcesrequired: 'externalResourcesRequired',
            fill: 'fill',
            fillopacity: 'fillOpacity',
            'fill-opacity': 'fillOpacity',
            fillrule: 'fillRule',
            'fill-rule': 'fillRule',
            filter: 'filter',
            filterres: 'filterRes',
            filterunits: 'filterUnits',
            floodopacity: 'floodOpacity',
            'flood-opacity': 'floodOpacity',
            floodcolor: 'floodColor',
            'flood-color': 'floodColor',
            focusable: 'focusable',
            fontfamily: 'fontFamily',
            'font-family': 'fontFamily',
            fontsize: 'fontSize',
            'font-size': 'fontSize',
            fontsizeadjust: 'fontSizeAdjust',
            'font-size-adjust': 'fontSizeAdjust',
            fontstretch: 'fontStretch',
            'font-stretch': 'fontStretch',
            fontstyle: 'fontStyle',
            'font-style': 'fontStyle',
            fontvariant: 'fontVariant',
            'font-variant': 'fontVariant',
            fontweight: 'fontWeight',
            'font-weight': 'fontWeight',
            format: 'format',
            from: 'from',
            fx: 'fx',
            fy: 'fy',
            g1: 'g1',
            g2: 'g2',
            glyphname: 'glyphName',
            'glyph-name': 'glyphName',
            glyphorientationhorizontal: 'glyphOrientationHorizontal',
            'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
            glyphorientationvertical: 'glyphOrientationVertical',
            'glyph-orientation-vertical': 'glyphOrientationVertical',
            glyphref: 'glyphRef',
            gradienttransform: 'gradientTransform',
            gradientunits: 'gradientUnits',
            hanging: 'hanging',
            horizadvx: 'horizAdvX',
            'horiz-adv-x': 'horizAdvX',
            horizoriginx: 'horizOriginX',
            'horiz-origin-x': 'horizOriginX',
            ideographic: 'ideographic',
            imagerendering: 'imageRendering',
            'image-rendering': 'imageRendering',
            in2: 'in2',
            in: 'in',
            inlist: 'inlist',
            intercept: 'intercept',
            k1: 'k1',
            k2: 'k2',
            k3: 'k3',
            k4: 'k4',
            k: 'k',
            kernelmatrix: 'kernelMatrix',
            kernelunitlength: 'kernelUnitLength',
            kerning: 'kerning',
            keypoints: 'keyPoints',
            keysplines: 'keySplines',
            keytimes: 'keyTimes',
            lengthadjust: 'lengthAdjust',
            letterspacing: 'letterSpacing',
            'letter-spacing': 'letterSpacing',
            lightingcolor: 'lightingColor',
            'lighting-color': 'lightingColor',
            limitingconeangle: 'limitingConeAngle',
            local: 'local',
            markerend: 'markerEnd',
            'marker-end': 'markerEnd',
            markerheight: 'markerHeight',
            markermid: 'markerMid',
            'marker-mid': 'markerMid',
            markerstart: 'markerStart',
            'marker-start': 'markerStart',
            markerunits: 'markerUnits',
            markerwidth: 'markerWidth',
            mask: 'mask',
            maskcontentunits: 'maskContentUnits',
            maskunits: 'maskUnits',
            mathematical: 'mathematical',
            mode: 'mode',
            numoctaves: 'numOctaves',
            offset: 'offset',
            opacity: 'opacity',
            operator: 'operator',
            order: 'order',
            orient: 'orient',
            orientation: 'orientation',
            origin: 'origin',
            overflow: 'overflow',
            overlineposition: 'overlinePosition',
            'overline-position': 'overlinePosition',
            overlinethickness: 'overlineThickness',
            'overline-thickness': 'overlineThickness',
            paintorder: 'paintOrder',
            'paint-order': 'paintOrder',
            panose1: 'panose1',
            'panose-1': 'panose1',
            pathlength: 'pathLength',
            patterncontentunits: 'patternContentUnits',
            patterntransform: 'patternTransform',
            patternunits: 'patternUnits',
            pointerevents: 'pointerEvents',
            'pointer-events': 'pointerEvents',
            points: 'points',
            pointsatx: 'pointsAtX',
            pointsaty: 'pointsAtY',
            pointsatz: 'pointsAtZ',
            prefix: 'prefix',
            preservealpha: 'preserveAlpha',
            preserveaspectratio: 'preserveAspectRatio',
            primitiveunits: 'primitiveUnits',
            property: 'property',
            r: 'r',
            radius: 'radius',
            refx: 'refX',
            refy: 'refY',
            renderingintent: 'renderingIntent',
            'rendering-intent': 'renderingIntent',
            repeatcount: 'repeatCount',
            repeatdur: 'repeatDur',
            requiredextensions: 'requiredExtensions',
            requiredfeatures: 'requiredFeatures',
            resource: 'resource',
            restart: 'restart',
            result: 'result',
            results: 'results',
            rotate: 'rotate',
            rx: 'rx',
            ry: 'ry',
            scale: 'scale',
            security: 'security',
            seed: 'seed',
            shaperendering: 'shapeRendering',
            'shape-rendering': 'shapeRendering',
            slope: 'slope',
            spacing: 'spacing',
            specularconstant: 'specularConstant',
            specularexponent: 'specularExponent',
            speed: 'speed',
            spreadmethod: 'spreadMethod',
            startoffset: 'startOffset',
            stddeviation: 'stdDeviation',
            stemh: 'stemh',
            stemv: 'stemv',
            stitchtiles: 'stitchTiles',
            stopcolor: 'stopColor',
            'stop-color': 'stopColor',
            stopopacity: 'stopOpacity',
            'stop-opacity': 'stopOpacity',
            strikethroughposition: 'strikethroughPosition',
            'strikethrough-position': 'strikethroughPosition',
            strikethroughthickness: 'strikethroughThickness',
            'strikethrough-thickness': 'strikethroughThickness',
            string: 'string',
            stroke: 'stroke',
            strokedasharray: 'strokeDasharray',
            'stroke-dasharray': 'strokeDasharray',
            strokedashoffset: 'strokeDashoffset',
            'stroke-dashoffset': 'strokeDashoffset',
            strokelinecap: 'strokeLinecap',
            'stroke-linecap': 'strokeLinecap',
            strokelinejoin: 'strokeLinejoin',
            'stroke-linejoin': 'strokeLinejoin',
            strokemiterlimit: 'strokeMiterlimit',
            'stroke-miterlimit': 'strokeMiterlimit',
            strokewidth: 'strokeWidth',
            'stroke-width': 'strokeWidth',
            strokeopacity: 'strokeOpacity',
            'stroke-opacity': 'strokeOpacity',
            suppresscontenteditablewarning: 'suppressContentEditableWarning',
            suppresshydrationwarning: 'suppressHydrationWarning',
            surfacescale: 'surfaceScale',
            systemlanguage: 'systemLanguage',
            tablevalues: 'tableValues',
            targetx: 'targetX',
            targety: 'targetY',
            textanchor: 'textAnchor',
            'text-anchor': 'textAnchor',
            textdecoration: 'textDecoration',
            'text-decoration': 'textDecoration',
            textlength: 'textLength',
            textrendering: 'textRendering',
            'text-rendering': 'textRendering',
            to: 'to',
            transform: 'transform',
            typeof: 'typeof',
            u1: 'u1',
            u2: 'u2',
            underlineposition: 'underlinePosition',
            'underline-position': 'underlinePosition',
            underlinethickness: 'underlineThickness',
            'underline-thickness': 'underlineThickness',
            unicode: 'unicode',
            unicodebidi: 'unicodeBidi',
            'unicode-bidi': 'unicodeBidi',
            unicoderange: 'unicodeRange',
            'unicode-range': 'unicodeRange',
            unitsperem: 'unitsPerEm',
            'units-per-em': 'unitsPerEm',
            unselectable: 'unselectable',
            valphabetic: 'vAlphabetic',
            'v-alphabetic': 'vAlphabetic',
            values: 'values',
            vectoreffect: 'vectorEffect',
            'vector-effect': 'vectorEffect',
            version: 'version',
            vertadvy: 'vertAdvY',
            'vert-adv-y': 'vertAdvY',
            vertoriginx: 'vertOriginX',
            'vert-origin-x': 'vertOriginX',
            vertoriginy: 'vertOriginY',
            'vert-origin-y': 'vertOriginY',
            vhanging: 'vHanging',
            'v-hanging': 'vHanging',
            videographic: 'vIdeographic',
            'v-ideographic': 'vIdeographic',
            viewbox: 'viewBox',
            viewtarget: 'viewTarget',
            visibility: 'visibility',
            vmathematical: 'vMathematical',
            'v-mathematical': 'vMathematical',
            vocab: 'vocab',
            widths: 'widths',
            wordspacing: 'wordSpacing',
            'word-spacing': 'wordSpacing',
            writingmode: 'writingMode',
            'writing-mode': 'writingMode',
            x1: 'x1',
            x2: 'x2',
            x: 'x',
            xchannelselector: 'xChannelSelector',
            xheight: 'xHeight',
            'x-height': 'xHeight',
            xlinkactuate: 'xlinkActuate',
            'xlink:actuate': 'xlinkActuate',
            xlinkarcrole: 'xlinkArcrole',
            'xlink:arcrole': 'xlinkArcrole',
            xlinkhref: 'xlinkHref',
            'xlink:href': 'xlinkHref',
            xlinkrole: 'xlinkRole',
            'xlink:role': 'xlinkRole',
            xlinkshow: 'xlinkShow',
            'xlink:show': 'xlinkShow',
            xlinktitle: 'xlinkTitle',
            'xlink:title': 'xlinkTitle',
            xlinktype: 'xlinkType',
            'xlink:type': 'xlinkType',
            xmlbase: 'xmlBase',
            'xml:base': 'xmlBase',
            xmllang: 'xmlLang',
            'xml:lang': 'xmlLang',
            xmlns: 'xmlns',
            'xml:space': 'xmlSpace',
            xmlnsxlink: 'xmlnsXlink',
            'xmlns:xlink': 'xmlnsXlink',
            xmlspace: 'xmlSpace',
            y1: 'y1',
            y2: 'y2',
            y: 'y',
            ychannelselector: 'yChannelSelector',
            z: 'z',
            zoomandpan: 'zoomAndPan',
          },
          ariaProperties = {
            'aria-current': 0,
            'aria-details': 0,
            'aria-disabled': 0,
            'aria-hidden': 0,
            'aria-invalid': 0,
            'aria-keyshortcuts': 0,
            'aria-label': 0,
            'aria-roledescription': 0,
            'aria-autocomplete': 0,
            'aria-checked': 0,
            'aria-expanded': 0,
            'aria-haspopup': 0,
            'aria-level': 0,
            'aria-modal': 0,
            'aria-multiline': 0,
            'aria-multiselectable': 0,
            'aria-orientation': 0,
            'aria-placeholder': 0,
            'aria-pressed': 0,
            'aria-readonly': 0,
            'aria-required': 0,
            'aria-selected': 0,
            'aria-sort': 0,
            'aria-valuemax': 0,
            'aria-valuemin': 0,
            'aria-valuenow': 0,
            'aria-valuetext': 0,
            'aria-atomic': 0,
            'aria-busy': 0,
            'aria-live': 0,
            'aria-relevant': 0,
            'aria-dropeffect': 0,
            'aria-grabbed': 0,
            'aria-activedescendant': 0,
            'aria-colcount': 0,
            'aria-colindex': 0,
            'aria-colspan': 0,
            'aria-controls': 0,
            'aria-describedby': 0,
            'aria-errormessage': 0,
            'aria-flowto': 0,
            'aria-labelledby': 0,
            'aria-owns': 0,
            'aria-posinset': 0,
            'aria-rowcount': 0,
            'aria-rowindex': 0,
            'aria-rowspan': 0,
            'aria-setsize': 0,
          },
          warnedProperties = {},
          rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$'),
          rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$'),
          hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name) {
          if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) return !0;
          if (rARIACamel.test(name)) {
            var ariaName = 'aria-' + name.slice(4).toLowerCase(),
              correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (null == correctName)
              return (
                error(
                  'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',
                  name
                ),
                (warnedProperties[name] = !0),
                !0
              );
            if (name !== correctName)
              return (
                error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName),
                (warnedProperties[name] = !0),
                !0
              );
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase(),
              standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (null == standardName) return (warnedProperties[name] = !0), !1;
            if (name !== standardName)
              return (
                error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName),
                (warnedProperties[name] = !0),
                !0
              );
          }
          return !0;
        }
        function validateProperties(type, props) {
          isCustomComponent(type, props) ||
            (function warnInvalidARIAProps(type, props) {
              var invalidProps = [];
              for (var key in props) {
                validateProperty(0, key) || invalidProps.push(key);
              }
              var unknownPropString = invalidProps
                .map(function (prop) {
                  return '`' + prop + '`';
                })
                .join(', ');
              1 === invalidProps.length
                ? error(
                    'Invalid aria prop %s on <%s> tag. For details, see https://fb.me/invalid-aria-prop',
                    unknownPropString,
                    type
                  )
                : invalidProps.length > 1 &&
                  error(
                    'Invalid aria props %s on <%s> tag. For details, see https://fb.me/invalid-aria-prop',
                    unknownPropString,
                    type
                  );
            })(type, props);
        }
        var didWarnValueNull = !1;
        var validateProperty$1,
          warnedProperties$1 = {},
          _hasOwnProperty = Object.prototype.hasOwnProperty,
          EVENT_NAME_REGEX = /^on./,
          INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
          rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$'),
          rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
        validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
          if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;
          var lowerCasedName = name.toLowerCase();
          if ('onfocusin' === lowerCasedName || 'onfocusout' === lowerCasedName)
            return (
              error(
                'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.'
              ),
              (warnedProperties$1[name] = !0),
              !0
            );
          if (canUseEventSystem) {
            if (registrationNameModules.hasOwnProperty(name)) return !0;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName)
              ? possibleRegistrationNames[lowerCasedName]
              : null;
            if (null != registrationName)
              return (
                error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName),
                (warnedProperties$1[name] = !0),
                !0
              );
            if (EVENT_NAME_REGEX.test(name))
              return (
                error('Unknown event handler property `%s`. It will be ignored.', name),
                (warnedProperties$1[name] = !0),
                !0
              );
          } else if (EVENT_NAME_REGEX.test(name))
            return (
              INVALID_EVENT_NAME_REGEX.test(name) &&
                error(
                  'Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.',
                  name
                ),
              (warnedProperties$1[name] = !0),
              !0
            );
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) return !0;
          if ('innerhtml' === lowerCasedName)
            return (
              error(
                'Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.'
              ),
              (warnedProperties$1[name] = !0),
              !0
            );
          if ('aria' === lowerCasedName)
            return (
              error(
                'The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.'
              ),
              (warnedProperties$1[name] = !0),
              !0
            );
          if ('is' === lowerCasedName && null != value && 'string' != typeof value)
            return (
              error(
                'Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.',
                typeof value
              ),
              (warnedProperties$1[name] = !0),
              !0
            );
          if ('number' == typeof value && isNaN(value))
            return (
              error('Received NaN for the `%s` attribute. If this is expected, cast the value to a string.', name),
              (warnedProperties$1[name] = !0),
              !0
            );
          var propertyInfo = getPropertyInfo(name),
            isReserved = null !== propertyInfo && 0 === propertyInfo.type;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name)
              return (
                error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName),
                (warnedProperties$1[name] = !0),
                !0
              );
          } else if (!isReserved && name !== lowerCasedName)
            return (
              error(
                'React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.',
                name,
                lowerCasedName
              ),
              (warnedProperties$1[name] = !0),
              !0
            );
          return 'boolean' == typeof value && shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1)
            ? (value
                ? error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  )
                : error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  ),
              (warnedProperties$1[name] = !0),
              !0)
            : !!isReserved ||
                (shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1)
                  ? ((warnedProperties$1[name] = !0), !1)
                  : (('false' !== value && 'true' !== value) ||
                      null === propertyInfo ||
                      3 !== propertyInfo.type ||
                      (error(
                        'Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?',
                        value,
                        name,
                        'false' === value
                          ? 'The browser will interpret it as a truthy value.'
                          : 'Although this works, it will not work as expected if you pass the string "false".',
                        name,
                        value
                      ),
                      (warnedProperties$1[name] = !0)),
                    !0));
        };
        function validateProperties$2(type, props, canUseEventSystem) {
          isCustomComponent(type, props) ||
            (function (type, props, canUseEventSystem) {
              var unknownProps = [];
              for (var key in props) {
                validateProperty$1(0, key, props[key], canUseEventSystem) || unknownProps.push(key);
              }
              var unknownPropString = unknownProps
                .map(function (prop) {
                  return '`' + prop + '`';
                })
                .join(', ');
              1 === unknownProps.length
                ? error(
                    'Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://fb.me/react-attribute-behavior',
                    unknownPropString,
                    type
                  )
                : unknownProps.length > 1 &&
                  error(
                    'Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://fb.me/react-attribute-behavior',
                    unknownPropString,
                    type
                  );
            })(type, props, canUseEventSystem);
        }
        var warnedUnknownTags,
          suppressHydrationWarning,
          validatePropertiesInDevelopment,
          warnForTextDifference,
          warnForPropDifference,
          warnForExtraAttributes,
          warnForInvalidEventListener,
          canDiffStyleForHydrationWarning,
          normalizeMarkupForTextOrAttribute,
          normalizeHTML,
          didWarnInvalidHydration = !1,
          HTML_NAMESPACE$1 = Namespaces_html;
        (warnedUnknownTags = { time: !0, dialog: !0, webview: !0 }),
          (validatePropertiesInDevelopment = function (type, props) {
            validateProperties(type, props),
              (function validateProperties$1(type, props) {
                ('input' !== type && 'textarea' !== type && 'select' !== type) ||
                  null == props ||
                  null !== props.value ||
                  didWarnValueNull ||
                  ((didWarnValueNull = !0),
                  'select' === type && props.multiple
                    ? error(
                        '`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.',
                        type
                      )
                    : error(
                        '`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.',
                        type
                      ));
              })(type, props),
              validateProperties$2(type, props, !0);
          }),
          (canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode);
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
          NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function ensureListeningTo(rootContainerElement, registrationName) {
          !(function legacyListenToEvent(registrationName, mountAt) {
            for (
              var listenerMap = getListenerMapForElement(mountAt),
                dependencies = registrationNameDependencies[registrationName],
                i = 0;
              i < dependencies.length;
              i++
            ) {
              legacyListenToTopLevelEvent(dependencies[i], mountAt, listenerMap);
            }
          })(
            registrationName,
            9 === rootContainerElement.nodeType || 11 === rootContainerElement.nodeType
              ? rootContainerElement
              : rootContainerElement.ownerDocument
          );
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop() {}
        function trapClickOnNonInteractiveElement(node) {
          node.onclick = noop;
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var props,
            isCustomComponentTag = isCustomComponent(tag, rawProps);
          switch ((validatePropertiesInDevelopment(tag, rawProps), tag)) {
            case 'iframe':
            case 'object':
            case 'embed':
              trapBubbledEvent('load', domElement), (props = rawProps);
              break;
            case 'video':
            case 'audio':
              for (var i = 0; i < mediaEventTypes.length; i++) trapBubbledEvent(mediaEventTypes[i], domElement);
              props = rawProps;
              break;
            case 'source':
              trapBubbledEvent('error', domElement), (props = rawProps);
              break;
            case 'img':
            case 'image':
            case 'link':
              trapBubbledEvent('error', domElement), trapBubbledEvent('load', domElement), (props = rawProps);
              break;
            case 'form':
              trapBubbledEvent('reset', domElement), trapBubbledEvent('submit', domElement), (props = rawProps);
              break;
            case 'details':
              trapBubbledEvent('toggle', domElement), (props = rawProps);
              break;
            case 'input':
              initWrapperState(domElement, rawProps),
                (props = getHostProps(domElement, rawProps)),
                trapBubbledEvent('invalid', domElement),
                ensureListeningTo(rootContainerElement, 'onChange');
              break;
            case 'option':
              validateProps(0, rawProps), (props = getHostProps$1(0, rawProps));
              break;
            case 'select':
              initWrapperState$1(domElement, rawProps),
                (props = getHostProps$2(0, rawProps)),
                trapBubbledEvent('invalid', domElement),
                ensureListeningTo(rootContainerElement, 'onChange');
              break;
            case 'textarea':
              initWrapperState$2(domElement, rawProps),
                (props = getHostProps$3(domElement, rawProps)),
                trapBubbledEvent('invalid', domElement),
                ensureListeningTo(rootContainerElement, 'onChange');
              break;
            default:
              props = rawProps;
          }
          switch (
            (assertValidProps(tag, props),
            (function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
              for (var propKey in nextProps)
                if (nextProps.hasOwnProperty(propKey)) {
                  var nextProp = nextProps[propKey];
                  if ('style' === propKey) nextProp && Object.freeze(nextProp), setValueForStyles(domElement, nextProp);
                  else if ('dangerouslySetInnerHTML' === propKey) {
                    var nextHtml = nextProp ? nextProp.__html : void 0;
                    null != nextHtml && setInnerHTML(domElement, nextHtml);
                  } else if ('children' === propKey) {
                    if ('string' == typeof nextProp)
                      ('textarea' !== tag || '' !== nextProp) && setTextContent(domElement, nextProp);
                    else 'number' == typeof nextProp && setTextContent(domElement, '' + nextProp);
                  } else
                    'suppressContentEditableWarning' === propKey ||
                      'suppressHydrationWarning' === propKey ||
                      'autoFocus' === propKey ||
                      (registrationNameModules.hasOwnProperty(propKey)
                        ? null != nextProp &&
                          ('function' != typeof nextProp && warnForInvalidEventListener(propKey, nextProp),
                          ensureListeningTo(rootContainerElement, propKey))
                        : null != nextProp && setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag));
                }
            })(tag, domElement, rootContainerElement, props, isCustomComponentTag),
            tag)
          ) {
            case 'input':
              track(domElement), postMountWrapper(domElement, rawProps, !1);
              break;
            case 'textarea':
              track(domElement), postMountWrapper$3(domElement);
              break;
            case 'option':
              !(function postMountWrapper$1(element, props) {
                null != props.value && element.setAttribute('value', toString(getToStringValue(props.value)));
              })(domElement, rawProps);
              break;
            case 'select':
              !(function postMountWrapper$2(element, props) {
                var node = element;
                node.multiple = !!props.multiple;
                var value = props.value;
                null != value
                  ? updateOptions(node, !!props.multiple, value, !1)
                  : null != props.defaultValue && updateOptions(node, !!props.multiple, props.defaultValue, !0);
              })(domElement, rawProps);
              break;
            default:
              'function' == typeof props.onClick && trapClickOnNonInteractiveElement(domElement);
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          validatePropertiesInDevelopment(tag, nextRawProps);
          var lastProps,
            nextProps,
            propKey,
            styleName,
            updatePayload = null;
          switch (tag) {
            case 'input':
              (lastProps = getHostProps(domElement, lastRawProps)),
                (nextProps = getHostProps(domElement, nextRawProps)),
                (updatePayload = []);
              break;
            case 'option':
              (lastProps = getHostProps$1(0, lastRawProps)),
                (nextProps = getHostProps$1(0, nextRawProps)),
                (updatePayload = []);
              break;
            case 'select':
              (lastProps = getHostProps$2(0, lastRawProps)),
                (nextProps = getHostProps$2(0, nextRawProps)),
                (updatePayload = []);
              break;
            case 'textarea':
              (lastProps = getHostProps$3(domElement, lastRawProps)),
                (nextProps = getHostProps$3(domElement, nextRawProps)),
                (updatePayload = []);
              break;
            default:
              (nextProps = nextRawProps),
                'function' != typeof (lastProps = lastRawProps).onClick &&
                  'function' == typeof nextProps.onClick &&
                  trapClickOnNonInteractiveElement(domElement);
          }
          assertValidProps(tag, nextProps);
          var styleUpdates = null;
          for (propKey in lastProps)
            if (!nextProps.hasOwnProperty(propKey) && lastProps.hasOwnProperty(propKey) && null != lastProps[propKey])
              if ('style' === propKey) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle)
                  lastStyle.hasOwnProperty(styleName) &&
                    (styleUpdates || (styleUpdates = {}), (styleUpdates[styleName] = ''));
              } else
                'dangerouslySetInnerHTML' === propKey ||
                  'children' === propKey ||
                  'suppressContentEditableWarning' === propKey ||
                  'suppressHydrationWarning' === propKey ||
                  'autoFocus' === propKey ||
                  (registrationNameModules.hasOwnProperty(propKey)
                    ? updatePayload || (updatePayload = [])
                    : (updatePayload = updatePayload || []).push(propKey, null));
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey],
              lastProp = null != lastProps ? lastProps[propKey] : void 0;
            if (nextProps.hasOwnProperty(propKey) && nextProp !== lastProp && (null != nextProp || null != lastProp))
              if ('style' === propKey)
                if ((nextProp && Object.freeze(nextProp), lastProp)) {
                  for (styleName in lastProp)
                    !lastProp.hasOwnProperty(styleName) ||
                      (nextProp && nextProp.hasOwnProperty(styleName)) ||
                      (styleUpdates || (styleUpdates = {}), (styleUpdates[styleName] = ''));
                  for (styleName in nextProp)
                    nextProp.hasOwnProperty(styleName) &&
                      lastProp[styleName] !== nextProp[styleName] &&
                      (styleUpdates || (styleUpdates = {}), (styleUpdates[styleName] = nextProp[styleName]));
                } else
                  styleUpdates || (updatePayload || (updatePayload = []), updatePayload.push(propKey, styleUpdates)),
                    (styleUpdates = nextProp);
              else if ('dangerouslySetInnerHTML' === propKey) {
                var nextHtml = nextProp ? nextProp.__html : void 0,
                  lastHtml = lastProp ? lastProp.__html : void 0;
                null != nextHtml &&
                  lastHtml !== nextHtml &&
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
              } else
                'children' === propKey
                  ? lastProp === nextProp ||
                    ('string' != typeof nextProp && 'number' != typeof nextProp) ||
                    (updatePayload = updatePayload || []).push(propKey, '' + nextProp)
                  : 'suppressContentEditableWarning' === propKey ||
                    'suppressHydrationWarning' === propKey ||
                    (registrationNameModules.hasOwnProperty(propKey)
                      ? (null != nextProp &&
                          ('function' != typeof nextProp && warnForInvalidEventListener(propKey, nextProp),
                          ensureListeningTo(rootContainerElement, propKey)),
                        updatePayload || lastProp === nextProp || (updatePayload = []))
                      : (updatePayload = updatePayload || []).push(propKey, nextProp));
          }
          return (
            styleUpdates &&
              (!(function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
                if (nextStyles) {
                  var value,
                    expandedUpdates = expandShorthandMap(styleUpdates),
                    expandedStyles = expandShorthandMap(nextStyles),
                    warnedAbout = {};
                  for (var key in expandedUpdates) {
                    var originalKey = expandedUpdates[key],
                      correctOriginalKey = expandedStyles[key];
                    if (correctOriginalKey && originalKey !== correctOriginalKey) {
                      var warningKey = originalKey + ',' + correctOriginalKey;
                      if (warnedAbout[warningKey]) continue;
                      (warnedAbout[warningKey] = !0),
                        error(
                          "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                          null == (value = styleUpdates[originalKey]) || 'boolean' == typeof value || '' === value
                            ? 'Removing'
                            : 'Updating',
                          originalKey,
                          correctOriginalKey
                        );
                    }
                  }
                }
              })(styleUpdates, nextProps.style),
              (updatePayload = updatePayload || []).push('style', styleUpdates)),
            updatePayload
          );
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          'input' === tag &&
            'radio' === nextRawProps.type &&
            null != nextRawProps.name &&
            updateChecked(domElement, nextRawProps);
          isCustomComponent(tag, lastRawProps);
          switch (
            ((function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
              for (var i = 0; i < updatePayload.length; i += 2) {
                var propKey = updatePayload[i],
                  propValue = updatePayload[i + 1];
                'style' === propKey
                  ? setValueForStyles(domElement, propValue)
                  : 'dangerouslySetInnerHTML' === propKey
                  ? setInnerHTML(domElement, propValue)
                  : 'children' === propKey
                  ? setTextContent(domElement, propValue)
                  : setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            })(domElement, updatePayload, 0, isCustomComponent(tag, nextRawProps)),
            tag)
          ) {
            case 'input':
              updateWrapper(domElement, nextRawProps);
              break;
            case 'textarea':
              updateWrapper$1(domElement, nextRawProps);
              break;
            case 'select':
              !(function postUpdateWrapper(element, props) {
                var node = element,
                  wasMultiple = node._wrapperState.wasMultiple;
                node._wrapperState.wasMultiple = !!props.multiple;
                var value = props.value;
                null != value
                  ? updateOptions(node, !!props.multiple, value, !1)
                  : wasMultiple !== !!props.multiple &&
                    (null != props.defaultValue
                      ? updateOptions(node, !!props.multiple, props.defaultValue, !0)
                      : updateOptions(node, !!props.multiple, props.multiple ? [] : '', !1));
              })(domElement, nextRawProps);
          }
        }
        function warnForUnmatchedText(textNode, text) {
          warnForTextDifference(textNode.nodeValue, text);
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          didWarnInvalidHydration ||
            ((didWarnInvalidHydration = !0),
            error(
              'Did not expect server HTML to contain a <%s> in <%s>.',
              child.nodeName.toLowerCase(),
              parentNode.nodeName.toLowerCase()
            ));
        }
        function warnForDeletedHydratableText(parentNode, child) {
          didWarnInvalidHydration ||
            ((didWarnInvalidHydration = !0),
            error(
              'Did not expect server HTML to contain the text node "%s" in <%s>.',
              child.nodeValue,
              parentNode.nodeName.toLowerCase()
            ));
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
          didWarnInvalidHydration ||
            ((didWarnInvalidHydration = !0),
            error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase()));
        }
        function warnForInsertedHydratedText(parentNode, text) {
          '' !== text &&
            (didWarnInvalidHydration ||
              ((didWarnInvalidHydration = !0),
              error(
                'Expected server HTML to contain a matching text node for "%s" in <%s>.',
                text,
                parentNode.nodeName.toLowerCase()
              )));
        }
        function getActiveElement(doc) {
          if (void 0 === (doc = doc || ('undefined' != typeof document ? document : void 0))) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getSiblingNode(node) {
          for (; node; ) {
            if (node.nextSibling) return node.nextSibling;
            node = node.parentNode;
          }
        }
        function getNodeForCharacterOffset(root, offset) {
          for (var node = getLeafNode(root), nodeStart = 0, nodeEnd = 0; node; ) {
            if (3 === node.nodeType) {
              if (((nodeEnd = nodeStart + node.textContent.length), nodeStart <= offset && nodeEnd >= offset))
                return { node, offset: offset - nodeStart };
              nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument,
            win = (ownerDocument && ownerDocument.defaultView) || window,
            selection = win.getSelection && win.getSelection();
          if (!selection || 0 === selection.rangeCount) return null;
          var anchorNode = selection.anchorNode,
            anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode,
            focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType, focusNode.nodeType;
          } catch (e) {
            return null;
          }
          return (function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0,
              start = -1,
              end = -1,
              indexWithinAnchor = 0,
              indexWithinFocus = 0,
              node = outerNode,
              parentNode = null;
            outer: for (;;) {
              for (
                var next = null;
                node !== anchorNode || (0 !== anchorOffset && 3 !== node.nodeType) || (start = length + anchorOffset),
                  node !== focusNode || (0 !== focusOffset && 3 !== node.nodeType) || (end = length + focusOffset),
                  3 === node.nodeType && (length += node.nodeValue.length),
                  null !== (next = node.firstChild);

              )
                (parentNode = node), (node = next);
              for (;;) {
                if (node === outerNode) break outer;
                if (
                  (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset && (start = length),
                  parentNode === focusNode && ++indexWithinFocus === focusOffset && (end = length),
                  null !== (next = node.nextSibling))
                )
                  break;
                parentNode = (node = parentNode).parentNode;
              }
              node = next;
            }
            if (-1 === start || -1 === end) return null;
            return { start, end };
          })(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function isTextNode(node) {
          return node && 3 === node.nodeType;
        }
        function isInDocument(node) {
          return (
            node &&
            node.ownerDocument &&
            (function containsNode(outerNode, innerNode) {
              return (
                !(!outerNode || !innerNode) &&
                (outerNode === innerNode ||
                  (!isTextNode(outerNode) &&
                    (isTextNode(innerNode)
                      ? containsNode(outerNode, innerNode.parentNode)
                      : 'contains' in outerNode
                      ? outerNode.contains(innerNode)
                      : !!outerNode.compareDocumentPosition && !!(16 & outerNode.compareDocumentPosition(innerNode)))))
              );
            })(node.ownerDocument.documentElement, node)
          );
        }
        function isSameOriginFrame(iframe) {
          try {
            return 'string' == typeof iframe.contentWindow.location.href;
          } catch (err) {
            return !1;
          }
        }
        function getActiveElementDeep() {
          for (var win = window, element = getActiveElement(); element instanceof win.HTMLIFrameElement; ) {
            if (!isSameOriginFrame(element)) return element;
            element = getActiveElement((win = element.contentWindow).document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return (
            nodeName &&
            (('input' === nodeName &&
              ('text' === elem.type ||
                'search' === elem.type ||
                'tel' === elem.type ||
                'url' === elem.type ||
                'password' === elem.type)) ||
              'textarea' === nodeName ||
              'true' === elem.contentEditable)
          );
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep(),
            priorFocusedElem = priorSelectionInformation.focusedElem,
            priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            null !== priorSelectionRange &&
              hasSelectionCapabilities(priorFocusedElem) &&
              (function setSelection(input, offsets) {
                var start = offsets.start,
                  end = offsets.end;
                void 0 === end && (end = start);
                'selectionStart' in input
                  ? ((input.selectionStart = start), (input.selectionEnd = Math.min(end, input.value.length)))
                  : (function setOffsets(node, offsets) {
                      var doc = node.ownerDocument || document,
                        win = (doc && doc.defaultView) || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(),
                          length = node.textContent.length,
                          start = Math.min(offsets.start, length),
                          end = void 0 === offsets.end ? start : Math.min(offsets.end, length);
                        if (!selection.extend && start > end) {
                          var temp = end;
                          (end = start), (start = temp);
                        }
                        var startMarker = getNodeForCharacterOffset(node, start),
                          endMarker = getNodeForCharacterOffset(node, end);
                        if (startMarker && endMarker) {
                          if (
                            1 === selection.rangeCount &&
                            selection.anchorNode === startMarker.node &&
                            selection.anchorOffset === startMarker.offset &&
                            selection.focusNode === endMarker.node &&
                            selection.focusOffset === endMarker.offset
                          )
                            return;
                          var range = doc.createRange();
                          range.setStart(startMarker.node, startMarker.offset),
                            selection.removeAllRanges(),
                            start > end
                              ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset))
                              : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                        }
                      }
                    })(input, offsets);
              })(priorFocusedElem, priorSelectionRange);
            for (var ancestors = [], ancestor = priorFocusedElem; (ancestor = ancestor.parentNode); )
              1 === ancestor.nodeType &&
                ancestors.push({ element: ancestor, left: ancestor.scrollLeft, top: ancestor.scrollTop });
            'function' == typeof priorFocusedElem.focus && priorFocusedElem.focus();
            for (var i = 0; i < ancestors.length; i++) {
              var info = ancestors[i];
              (info.element.scrollLeft = info.left), (info.element.scrollTop = info.top);
            }
          }
        }
        function getSelection(input) {
          return (
            ('selectionStart' in input
              ? { start: input.selectionStart, end: input.selectionEnd }
              : getOffsets(input)) || { start: 0, end: 0 }
          );
        }
        (normalizeMarkupForTextOrAttribute = function (markup) {
          return ('string' == typeof markup ? markup : '' + markup)
            .replace(NORMALIZE_NEWLINES_REGEX, '\n')
            .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
        }),
          (warnForTextDifference = function (serverText, clientText) {
            if (!didWarnInvalidHydration) {
              var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText),
                normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
              normalizedServerText !== normalizedClientText &&
                ((didWarnInvalidHydration = !0),
                error(
                  'Text content did not match. Server: "%s" Client: "%s"',
                  normalizedServerText,
                  normalizedClientText
                ));
            }
          }),
          (warnForPropDifference = function (propName, serverValue, clientValue) {
            if (!didWarnInvalidHydration) {
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue),
                normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              normalizedServerValue !== normalizedClientValue &&
                ((didWarnInvalidHydration = !0),
                error(
                  'Prop `%s` did not match. Server: %s Client: %s',
                  propName,
                  JSON.stringify(normalizedServerValue),
                  JSON.stringify(normalizedClientValue)
                ));
            }
          }),
          (warnForExtraAttributes = function (attributeNames) {
            if (!didWarnInvalidHydration) {
              didWarnInvalidHydration = !0;
              var names = [];
              attributeNames.forEach(function (name) {
                names.push(name);
              }),
                error('Extra attributes from the server: %s', names);
            }
          }),
          (warnForInvalidEventListener = function (registrationName, listener) {
            !1 === listener
              ? error(
                  'Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                  registrationName,
                  registrationName,
                  registrationName
                )
              : error(
                  'Expected `%s` listener to be a function, instead got a value of `%s` type.',
                  registrationName,
                  typeof listener
                );
          }),
          (normalizeHTML = function (parent, html) {
            var testElement =
              parent.namespaceURI === HTML_NAMESPACE$1
                ? parent.ownerDocument.createElement(parent.tagName)
                : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            return (testElement.innerHTML = html), testElement.innerHTML;
          });
        var validateDOMNesting,
          updatedAncestorInfo,
          specialTags = [
            'address',
            'applet',
            'area',
            'article',
            'aside',
            'base',
            'basefont',
            'bgsound',
            'blockquote',
            'body',
            'br',
            'button',
            'caption',
            'center',
            'col',
            'colgroup',
            'dd',
            'details',
            'dir',
            'div',
            'dl',
            'dt',
            'embed',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'frame',
            'frameset',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'head',
            'header',
            'hgroup',
            'hr',
            'html',
            'iframe',
            'img',
            'input',
            'isindex',
            'li',
            'link',
            'listing',
            'main',
            'marquee',
            'menu',
            'menuitem',
            'meta',
            'nav',
            'noembed',
            'noframes',
            'noscript',
            'object',
            'ol',
            'p',
            'param',
            'plaintext',
            'pre',
            'script',
            'section',
            'select',
            'source',
            'style',
            'summary',
            'table',
            'tbody',
            'td',
            'template',
            'textarea',
            'tfoot',
            'th',
            'thead',
            'title',
            'tr',
            'track',
            'ul',
            'wbr',
            'xmp',
          ],
          inScopeTags = [
            'applet',
            'caption',
            'html',
            'table',
            'td',
            'th',
            'marquee',
            'object',
            'template',
            'foreignObject',
            'desc',
            'title',
          ],
          buttonScopeTags = inScopeTags.concat(['button']),
          impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'],
          emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null,
          };
        updatedAncestorInfo = function (oldInfo, tag) {
          var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo),
            info = { tag };
          return (
            -1 !== inScopeTags.indexOf(tag) &&
              ((ancestorInfo.aTagInScope = null),
              (ancestorInfo.buttonTagInScope = null),
              (ancestorInfo.nobrTagInScope = null)),
            -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null),
            -1 !== specialTags.indexOf(tag) &&
              'address' !== tag &&
              'div' !== tag &&
              'p' !== tag &&
              ((ancestorInfo.listItemTagAutoclosing = null), (ancestorInfo.dlItemTagAutoclosing = null)),
            (ancestorInfo.current = info),
            'form' === tag && (ancestorInfo.formTag = info),
            'a' === tag && (ancestorInfo.aTagInScope = info),
            'button' === tag && (ancestorInfo.buttonTagInScope = info),
            'nobr' === tag && (ancestorInfo.nobrTagInScope = info),
            'p' === tag && (ancestorInfo.pTagInButtonScope = info),
            'li' === tag && (ancestorInfo.listItemTagAutoclosing = info),
            ('dd' !== tag && 'dt' !== tag) || (ancestorInfo.dlItemTagAutoclosing = info),
            ancestorInfo
          );
        };
        var didWarn$1 = {};
        validateDOMNesting = function (childTag, childText, ancestorInfo) {
          var parentInfo = (ancestorInfo = ancestorInfo || emptyAncestorInfo).current,
            parentTag = parentInfo && parentInfo.tag;
          null != childText &&
            (null != childTag && error('validateDOMNesting: when childText is passed, childTag should be null'),
            (childTag = '#text'));
          var invalidParent = (function (tag, parentTag) {
              switch (parentTag) {
                case 'select':
                  return 'option' === tag || 'optgroup' === tag || '#text' === tag;
                case 'optgroup':
                  return 'option' === tag || '#text' === tag;
                case 'option':
                  return '#text' === tag;
                case 'tr':
                  return 'th' === tag || 'td' === tag || 'style' === tag || 'script' === tag || 'template' === tag;
                case 'tbody':
                case 'thead':
                case 'tfoot':
                  return 'tr' === tag || 'style' === tag || 'script' === tag || 'template' === tag;
                case 'colgroup':
                  return 'col' === tag || 'template' === tag;
                case 'table':
                  return (
                    'caption' === tag ||
                    'colgroup' === tag ||
                    'tbody' === tag ||
                    'tfoot' === tag ||
                    'thead' === tag ||
                    'style' === tag ||
                    'script' === tag ||
                    'template' === tag
                  );
                case 'head':
                  return (
                    'base' === tag ||
                    'basefont' === tag ||
                    'bgsound' === tag ||
                    'link' === tag ||
                    'meta' === tag ||
                    'title' === tag ||
                    'noscript' === tag ||
                    'noframes' === tag ||
                    'style' === tag ||
                    'script' === tag ||
                    'template' === tag
                  );
                case 'html':
                  return 'head' === tag || 'body' === tag || 'frameset' === tag;
                case 'frameset':
                  return 'frame' === tag;
                case '#document':
                  return 'html' === tag;
              }
              switch (tag) {
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                  return (
                    'h1' !== parentTag &&
                    'h2' !== parentTag &&
                    'h3' !== parentTag &&
                    'h4' !== parentTag &&
                    'h5' !== parentTag &&
                    'h6' !== parentTag
                  );
                case 'rp':
                case 'rt':
                  return -1 === impliedEndTags.indexOf(parentTag);
                case 'body':
                case 'caption':
                case 'col':
                case 'colgroup':
                case 'frameset':
                case 'frame':
                case 'head':
                case 'html':
                case 'tbody':
                case 'td':
                case 'tfoot':
                case 'th':
                case 'thead':
                case 'tr':
                  return null == parentTag;
              }
              return !0;
            })(childTag, parentTag)
              ? null
              : parentInfo,
            invalidAncestor = invalidParent
              ? null
              : (function (tag, ancestorInfo) {
                  switch (tag) {
                    case 'address':
                    case 'article':
                    case 'aside':
                    case 'blockquote':
                    case 'center':
                    case 'details':
                    case 'dialog':
                    case 'dir':
                    case 'div':
                    case 'dl':
                    case 'fieldset':
                    case 'figcaption':
                    case 'figure':
                    case 'footer':
                    case 'header':
                    case 'hgroup':
                    case 'main':
                    case 'menu':
                    case 'nav':
                    case 'ol':
                    case 'p':
                    case 'section':
                    case 'summary':
                    case 'ul':
                    case 'pre':
                    case 'listing':
                    case 'table':
                    case 'hr':
                    case 'xmp':
                    case 'h1':
                    case 'h2':
                    case 'h3':
                    case 'h4':
                    case 'h5':
                    case 'h6':
                      return ancestorInfo.pTagInButtonScope;
                    case 'form':
                      return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                    case 'li':
                      return ancestorInfo.listItemTagAutoclosing;
                    case 'dd':
                    case 'dt':
                      return ancestorInfo.dlItemTagAutoclosing;
                    case 'button':
                      return ancestorInfo.buttonTagInScope;
                    case 'a':
                      return ancestorInfo.aTagInScope;
                    case 'nobr':
                      return ancestorInfo.nobrTagInScope;
                  }
                  return null;
                })(childTag, ancestorInfo),
            invalidParentOrAncestor = invalidParent || invalidAncestor;
          if (invalidParentOrAncestor) {
            var ancestorTag = invalidParentOrAncestor.tag,
              warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + getCurrentFiberStackInDev();
            if (!didWarn$1[warnKey]) {
              didWarn$1[warnKey] = !0;
              var tagDisplayName = childTag,
                whitespaceInfo = '';
              if (
                ('#text' === childTag
                  ? /\S/.test(childText)
                    ? (tagDisplayName = 'Text nodes')
                    : ((tagDisplayName = 'Whitespace text nodes'),
                      (whitespaceInfo =
                        " Make sure you don't have any extra whitespace between tags on each line of your source code."))
                  : (tagDisplayName = '<' + childTag + '>'),
                invalidParent)
              ) {
                var info = '';
                'table' === ancestorTag &&
                  'tr' === childTag &&
                  (info +=
                    ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.'),
                  error(
                    'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',
                    tagDisplayName,
                    ancestorTag,
                    whitespaceInfo,
                    info
                  );
              } else
                error(
                  'validateDOMNesting(...): %s cannot appear as a descendant of <%s>.',
                  tagDisplayName,
                  ancestorTag
                );
            }
          }
        };
        var eventsEnabled = null,
          selectionInformation = null;
        function shouldAutoFocusHostComponent(type, props) {
          switch (type) {
            case 'button':
            case 'input':
            case 'select':
            case 'textarea':
              return !!props.autoFocus;
          }
          return !1;
        }
        function prepareForCommit(containerInfo) {
          (eventsEnabled = (function isEnabled() {
            return _enabled;
          })()),
            (selectionInformation = (function getSelectionInformation() {
              var focusedElem = getActiveElementDeep();
              return {
                activeElementDetached: null,
                focusedElem,
                selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null,
              };
            })()),
            setEnabled(!1);
        }
        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var hostContextDev = hostContext;
          if (
            (validateDOMNesting(type, null, hostContextDev.ancestorInfo),
            'string' == typeof props.children || 'number' == typeof props.children)
          ) {
            var string = '' + props.children,
              ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
          var domElement = (function createElement(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag,
              domElement,
              ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement),
              namespaceURI = parentNamespace;
            if (
              (namespaceURI === HTML_NAMESPACE$1 && (namespaceURI = getIntrinsicNamespace(type)),
              namespaceURI === HTML_NAMESPACE$1)
            ) {
              if (
                ((isCustomComponentTag = isCustomComponent(type, props)) ||
                  type === type.toLowerCase() ||
                  error(
                    '<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.',
                    type
                  ),
                'script' === type)
              ) {
                var div = ownerDocument.createElement('div');
                div.innerHTML = '<script></script>';
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if ('string' == typeof props.is) domElement = ownerDocument.createElement(type, { is: props.is });
              else if (((domElement = ownerDocument.createElement(type)), 'select' === type)) {
                var node = domElement;
                props.multiple ? (node.multiple = !0) : props.size && (node.size = props.size);
              }
            } else domElement = ownerDocument.createElementNS(namespaceURI, type);
            return (
              namespaceURI === HTML_NAMESPACE$1 &&
                (isCustomComponentTag ||
                  '[object HTMLUnknownElement]' !== Object.prototype.toString.call(domElement) ||
                  Object.prototype.hasOwnProperty.call(warnedUnknownTags, type) ||
                  ((warnedUnknownTags[type] = !0),
                  error(
                    'The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.',
                    type
                  ))),
              domElement
            );
          })(type, props, rootContainerInstance, hostContextDev.namespace);
          return precacheFiberNode(internalInstanceHandle, domElement), updateFiberProps(domElement, props), domElement;
        }
        function shouldSetTextContent(type, props) {
          return (
            'textarea' === type ||
            'option' === type ||
            'noscript' === type ||
            'string' == typeof props.children ||
            'number' == typeof props.children ||
            ('object' == typeof props.dangerouslySetInnerHTML &&
              null !== props.dangerouslySetInnerHTML &&
              null != props.dangerouslySetInnerHTML.__html)
          );
        }
        function shouldDeprioritizeSubtree(type, props) {
          return !!props.hidden;
        }
        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
          validateDOMNesting(null, text, hostContext.ancestorInfo);
          var textNode = (function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          })(text, rootContainerInstance);
          return precacheFiberNode(internalInstanceHandle, textNode), textNode;
        }
        var scheduleTimeout = 'function' == typeof setTimeout ? setTimeout : void 0,
          cancelTimeout = 'function' == typeof clearTimeout ? clearTimeout : void 0;
        function resetTextContent(domElement) {
          setTextContent(domElement, '');
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function hideInstance(instance) {
          var style = (instance = instance).style;
          'function' == typeof style.setProperty
            ? style.setProperty('display', 'none', 'important')
            : (style.display = 'none');
        }
        function unhideInstance(instance, props) {
          instance = instance;
          var styleProp = props.style,
            display = null != styleProp && styleProp.hasOwnProperty('display') ? styleProp.display : null;
          instance.style.display = dangerousStyleValue('display', display);
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function isSuspenseInstanceFallback(instance) {
          return '$!' === instance.data;
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
          }
          return node;
        }
        function getNextHydratableSibling(instance) {
          return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          return (
            precacheFiberNode(internalInstanceHandle, instance),
            updateFiberProps(instance, props),
            (function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
              var isCustomComponentTag, extraAttributeNames;
              switch (
                ((suppressHydrationWarning = !0 === rawProps.suppressHydrationWarning),
                (isCustomComponentTag = isCustomComponent(tag, rawProps)),
                validatePropertiesInDevelopment(tag, rawProps),
                tag)
              ) {
                case 'iframe':
                case 'object':
                case 'embed':
                  trapBubbledEvent('load', domElement);
                  break;
                case 'video':
                case 'audio':
                  for (var i = 0; i < mediaEventTypes.length; i++) trapBubbledEvent(mediaEventTypes[i], domElement);
                  break;
                case 'source':
                  trapBubbledEvent('error', domElement);
                  break;
                case 'img':
                case 'image':
                case 'link':
                  trapBubbledEvent('error', domElement), trapBubbledEvent('load', domElement);
                  break;
                case 'form':
                  trapBubbledEvent('reset', domElement), trapBubbledEvent('submit', domElement);
                  break;
                case 'details':
                  trapBubbledEvent('toggle', domElement);
                  break;
                case 'input':
                  initWrapperState(domElement, rawProps),
                    trapBubbledEvent('invalid', domElement),
                    ensureListeningTo(rootContainerElement, 'onChange');
                  break;
                case 'option':
                  validateProps(0, rawProps);
                  break;
                case 'select':
                  initWrapperState$1(domElement, rawProps),
                    trapBubbledEvent('invalid', domElement),
                    ensureListeningTo(rootContainerElement, 'onChange');
                  break;
                case 'textarea':
                  initWrapperState$2(domElement, rawProps),
                    trapBubbledEvent('invalid', domElement),
                    ensureListeningTo(rootContainerElement, 'onChange');
              }
              assertValidProps(tag, rawProps), (extraAttributeNames = new Set());
              for (var attributes = domElement.attributes, _i = 0; _i < attributes.length; _i++) {
                switch (attributes[_i].name.toLowerCase()) {
                  case 'data-reactroot':
                  case 'value':
                  case 'checked':
                  case 'selected':
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
              var lowerCasedName,
                updatePayload = null;
              for (var propKey in rawProps)
                if (rawProps.hasOwnProperty(propKey)) {
                  var nextProp = rawProps[propKey];
                  if ('children' === propKey)
                    'string' == typeof nextProp
                      ? domElement.textContent !== nextProp &&
                        (suppressHydrationWarning || warnForTextDifference(domElement.textContent, nextProp),
                        (updatePayload = ['children', nextProp]))
                      : 'number' == typeof nextProp &&
                        domElement.textContent !== '' + nextProp &&
                        (suppressHydrationWarning || warnForTextDifference(domElement.textContent, nextProp),
                        (updatePayload = ['children', '' + nextProp]));
                  else if (registrationNameModules.hasOwnProperty(propKey))
                    null != nextProp &&
                      ('function' != typeof nextProp && warnForInvalidEventListener(propKey, nextProp),
                      ensureListeningTo(rootContainerElement, propKey));
                  else if ('boolean' == typeof isCustomComponentTag) {
                    var serverValue = void 0,
                      propertyInfo = getPropertyInfo(propKey);
                    if (suppressHydrationWarning);
                    else if (
                      'suppressContentEditableWarning' === propKey ||
                      'suppressHydrationWarning' === propKey ||
                      'value' === propKey ||
                      'checked' === propKey ||
                      'selected' === propKey
                    );
                    else if ('dangerouslySetInnerHTML' === propKey) {
                      var serverHTML = domElement.innerHTML,
                        nextHtml = nextProp ? nextProp.__html : void 0,
                        expectedHTML = normalizeHTML(domElement, null != nextHtml ? nextHtml : '');
                      expectedHTML !== serverHTML && warnForPropDifference(propKey, serverHTML, expectedHTML);
                    } else if ('style' === propKey) {
                      if ((extraAttributeNames.delete(propKey), canDiffStyleForHydrationWarning)) {
                        var expectedStyle = createDangerousStringForStyles(nextProp);
                        expectedStyle !== (serverValue = domElement.getAttribute('style')) &&
                          warnForPropDifference(propKey, serverValue, expectedStyle);
                      }
                    } else if (isCustomComponentTag)
                      extraAttributeNames.delete(propKey.toLowerCase()),
                        nextProp !== (serverValue = getValueForAttribute(domElement, propKey, nextProp)) &&
                          warnForPropDifference(propKey, serverValue, nextProp);
                    else if (
                      !shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) &&
                      !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)
                    ) {
                      var isMismatchDueToBadCasing = !1;
                      if (null !== propertyInfo)
                        extraAttributeNames.delete(propertyInfo.attributeName),
                          (serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo));
                      else {
                        var ownNamespace = parentNamespace;
                        if (
                          (ownNamespace === HTML_NAMESPACE$1 && (ownNamespace = getIntrinsicNamespace(tag)),
                          ownNamespace === HTML_NAMESPACE$1)
                        )
                          extraAttributeNames.delete(propKey.toLowerCase());
                        else {
                          var standardName =
                            ((lowerCasedName = void 0),
                            (lowerCasedName = propKey.toLowerCase()),
                            (possibleStandardNames.hasOwnProperty(lowerCasedName) &&
                              possibleStandardNames[lowerCasedName]) ||
                              null);
                          null !== standardName &&
                            standardName !== propKey &&
                            ((isMismatchDueToBadCasing = !0), extraAttributeNames.delete(standardName)),
                            extraAttributeNames.delete(propKey);
                        }
                        serverValue = getValueForAttribute(domElement, propKey, nextProp);
                      }
                      nextProp === serverValue ||
                        isMismatchDueToBadCasing ||
                        warnForPropDifference(propKey, serverValue, nextProp);
                    }
                  }
                }
              switch (
                (extraAttributeNames.size > 0 &&
                  !suppressHydrationWarning &&
                  warnForExtraAttributes(extraAttributeNames),
                tag)
              ) {
                case 'input':
                  track(domElement), postMountWrapper(domElement, rawProps, !0);
                  break;
                case 'textarea':
                  track(domElement), postMountWrapper$3(domElement);
                  break;
                case 'select':
                case 'option':
                  break;
                default:
                  'function' == typeof rawProps.onClick && trapClickOnNonInteractiveElement(domElement);
              }
              return updatePayload;
            })(instance, type, props, hostContext.namespace, rootContainerInstance)
          );
        }
        function getParentSuspenseInstance(targetInstance) {
          for (var node = targetInstance.previousSibling, depth = 0; node; ) {
            if (8 === node.nodeType) {
              var data = node.data;
              if ('$' === data || '$!' === data || '$?' === data) {
                if (0 === depth) return node;
                depth--;
              } else '/$' === data && depth++;
            }
            node = node.previousSibling;
          }
          return null;
        }
        var randomKey = Math.random().toString(36).slice(2),
          internalInstanceKey = '__reactInternalInstance$' + randomKey,
          internalEventHandlersKey = '__reactEventHandlers$' + randomKey,
          internalContainerInstanceKey = '__reactContainere$' + randomKey;
        function precacheFiberNode(hostInst, node) {
          node[internalInstanceKey] = hostInst;
        }
        function unmarkContainerAsRoot(node) {
          node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
          return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if ((targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey])) {
              var alternate = targetInst.alternate;
              if (null !== targetInst.child || (null !== alternate && null !== alternate.child))
                for (var suspenseInstance = getParentSuspenseInstance(targetNode); null !== suspenseInstance; ) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) return targetSuspenseInst;
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              return targetInst;
            }
            parentNode = (targetNode = parentNode).parentNode;
          }
          return null;
        }
        function getInstanceFromNode$1(node) {
          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
          return inst && (5 === inst.tag || 6 === inst.tag || 13 === inst.tag || 3 === inst.tag) ? inst : null;
        }
        function getNodeFromInstance$1(inst) {
          if (5 === inst.tag || 6 === inst.tag) return inst.stateNode;
          throw Error('getNodeFromInstance: Invalid argument.');
        }
        function getFiberCurrentPropsFromNode$1(node) {
          return node[internalEventHandlersKey] || null;
        }
        function updateFiberProps(node, props) {
          node[internalEventHandlersKey] = props;
        }
        function getParent(inst) {
          do {
            inst = inst.return;
          } while (inst && 5 !== inst.tag);
          return inst || null;
        }
        function traverseEnterLeave(from, to, fn, argFrom, argTo) {
          for (
            var common =
                from && to
                  ? (function getLowestCommonAncestor(instA, instB) {
                      for (var depthA = 0, tempA = instA; tempA; tempA = getParent(tempA)) depthA++;
                      for (var depthB = 0, tempB = instB; tempB; tempB = getParent(tempB)) depthB++;
                      for (; depthA - depthB > 0; ) (instA = getParent(instA)), depthA--;
                      for (; depthB - depthA > 0; ) (instB = getParent(instB)), depthB--;
                      for (var depth = depthA; depth--; ) {
                        if (instA === instB || instA === instB.alternate) return instA;
                        (instA = getParent(instA)), (instB = getParent(instB));
                      }
                      return null;
                    })(from, to)
                  : null,
              pathFrom = [];
            from && from !== common;

          ) {
            var alternate = from.alternate;
            if (null !== alternate && alternate === common) break;
            pathFrom.push(from), (from = getParent(from));
          }
          for (var pathTo = []; to && to !== common; ) {
            var _alternate = to.alternate;
            if (null !== _alternate && _alternate === common) break;
            pathTo.push(to), (to = getParent(to));
          }
          for (var i = 0; i < pathFrom.length; i++) fn(pathFrom[i], 'bubbled', argFrom);
          for (var _i = pathTo.length; _i-- > 0; ) fn(pathTo[_i], 'captured', argTo);
        }
        function getListener(inst, registrationName) {
          var listener,
            stateNode = inst.stateNode;
          if (!stateNode) return null;
          var props = getFiberCurrentPropsFromNode(stateNode);
          if (!props) return null;
          if (
            ((listener = props[registrationName]),
            (function shouldPreventMouseEvent(name, type, props) {
              switch (name) {
                case 'onClick':
                case 'onClickCapture':
                case 'onDoubleClick':
                case 'onDoubleClickCapture':
                case 'onMouseDown':
                case 'onMouseDownCapture':
                case 'onMouseMove':
                case 'onMouseMoveCapture':
                case 'onMouseUp':
                case 'onMouseUpCapture':
                case 'onMouseEnter':
                  return !(
                    !props.disabled ||
                    !(function isInteractive(tag) {
                      return 'button' === tag || 'input' === tag || 'select' === tag || 'textarea' === tag;
                    })(type)
                  );
                default:
                  return !1;
              }
            })(registrationName, inst.type, props))
          )
            return null;
          if (listener && 'function' != typeof listener)
            throw Error(
              'Expected `' +
                registrationName +
                '` listener to be a function, instead got a value of `' +
                typeof listener +
                '` type.'
            );
          return listener;
        }
        function accumulateDirectionalDispatches(inst, phase, event) {
          inst || error('Dispatching inst must not be null');
          var listener = (function listenerAtPhase(inst, event, propagationPhase) {
            return getListener(inst, event.dispatchConfig.phasedRegistrationNames[propagationPhase]);
          })(inst, event, phase);
          listener &&
            ((event._dispatchListeners = accumulateInto(event._dispatchListeners, listener)),
            (event._dispatchInstances = accumulateInto(event._dispatchInstances, inst)));
        }
        function accumulateTwoPhaseDispatchesSingle(event) {
          event &&
            event.dispatchConfig.phasedRegistrationNames &&
            (function traverseTwoPhase(inst, fn, arg) {
              for (var i, path = []; inst; ) path.push(inst), (inst = getParent(inst));
              for (i = path.length; i-- > 0; ) fn(path[i], 'captured', arg);
              for (i = 0; i < path.length; i++) fn(path[i], 'bubbled', arg);
            })(event._targetInst, accumulateDirectionalDispatches, event);
        }
        function accumulateDispatches(inst, ignoredDirection, event) {
          if (inst && event && event.dispatchConfig.registrationName) {
            var listener = getListener(inst, event.dispatchConfig.registrationName);
            listener &&
              ((event._dispatchListeners = accumulateInto(event._dispatchListeners, listener)),
              (event._dispatchInstances = accumulateInto(event._dispatchInstances, inst)));
          }
        }
        function accumulateDirectDispatchesSingle(event) {
          event && event.dispatchConfig.registrationName && accumulateDispatches(event._targetInst, 0, event);
        }
        function accumulateTwoPhaseDispatches(events) {
          forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
        }
        var root = null,
          startText = null,
          fallbackText = null;
        function getData() {
          if (fallbackText) return fallbackText;
          var start,
            end,
            startValue = startText,
            startLength = startValue.length,
            endValue = getText(),
            endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
          var sliceTail = end > 1 ? 1 - end : void 0;
          return (fallbackText = endValue.slice(start, sliceTail));
        }
        function getText() {
          return 'value' in root ? root.value : root.textContent;
        }
        var EventInterface = {
          type: null,
          target: null,
          currentTarget: function () {
            return null;
          },
          eventPhase: null,
          bubbles: null,
          cancelable: null,
          timeStamp: function (event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: null,
          isTrusted: null,
        };
        function functionThatReturnsTrue() {
          return !0;
        }
        function functionThatReturnsFalse() {
          return !1;
        }
        function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
          delete this.nativeEvent,
            delete this.preventDefault,
            delete this.stopPropagation,
            delete this.isDefaultPrevented,
            delete this.isPropagationStopped,
            (this.dispatchConfig = dispatchConfig),
            (this._targetInst = targetInst),
            (this.nativeEvent = nativeEvent);
          var Interface = this.constructor.Interface;
          for (var propName in Interface)
            if (Interface.hasOwnProperty(propName)) {
              delete this[propName];
              var normalize = Interface[propName];
              normalize
                ? (this[propName] = normalize(nativeEvent))
                : 'target' === propName
                ? (this.target = nativeEventTarget)
                : (this[propName] = nativeEvent[propName]);
            }
          var defaultPrevented =
            null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue;
          return (
            (this.isDefaultPrevented = defaultPrevented ? functionThatReturnsTrue : functionThatReturnsFalse),
            (this.isPropagationStopped = functionThatReturnsFalse),
            this
          );
        }
        function getPooledWarningPropertyDefinition(propName, getVal) {
          var isFunction = 'function' == typeof getVal;
          return {
            configurable: !0,
            set: function set(val) {
              return (
                warn(isFunction ? 'setting the method' : 'setting the property', 'This is effectively a no-op'), val
              );
            },
            get: function get() {
              return (
                warn(
                  isFunction ? 'accessing the method' : 'accessing the property',
                  isFunction ? 'This is a no-op function' : 'This is set to null'
                ),
                getVal
              );
            },
          };
          function warn(action, result) {
            error(
              "This synthetic event is reused for performance reasons. If you're seeing this, you're %s `%s` on a released/nullified synthetic event. %s. If you must keep the original synthetic event around, use event.persist(). See https://fb.me/react-event-pooling for more information.",
              action,
              propName,
              result
            );
          }
        }
        function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
          if (this.eventPool.length) {
            var instance = this.eventPool.pop();
            return this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst), instance;
          }
          return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
        }
        function releasePooledEvent(event) {
          if (!(event instanceof this))
            throw Error('Trying to release an event instance into a pool of a different type.');
          event.destructor(), this.eventPool.length < 10 && this.eventPool.push(event);
        }
        function addEventPoolingTo(EventConstructor) {
          (EventConstructor.eventPool = []),
            (EventConstructor.getPooled = getPooledEvent),
            (EventConstructor.release = releasePooledEvent);
        }
        _assign(SyntheticEvent.prototype, {
          preventDefault: function () {
            this.defaultPrevented = !0;
            var event = this.nativeEvent;
            event &&
              (event.preventDefault
                ? event.preventDefault()
                : 'unknown' != typeof event.returnValue && (event.returnValue = !1),
              (this.isDefaultPrevented = functionThatReturnsTrue));
          },
          stopPropagation: function () {
            var event = this.nativeEvent;
            event &&
              (event.stopPropagation
                ? event.stopPropagation()
                : 'unknown' != typeof event.cancelBubble && (event.cancelBubble = !0),
              (this.isPropagationStopped = functionThatReturnsTrue));
          },
          persist: function () {
            this.isPersistent = functionThatReturnsTrue;
          },
          isPersistent: functionThatReturnsFalse,
          destructor: function () {
            var Interface = this.constructor.Interface;
            for (var propName in Interface)
              Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
            (this.dispatchConfig = null),
              (this._targetInst = null),
              (this.nativeEvent = null),
              (this.isDefaultPrevented = functionThatReturnsFalse),
              (this.isPropagationStopped = functionThatReturnsFalse),
              (this._dispatchListeners = null),
              (this._dispatchInstances = null),
              Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null)),
              Object.defineProperty(
                this,
                'isDefaultPrevented',
                getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse)
              ),
              Object.defineProperty(
                this,
                'isPropagationStopped',
                getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse)
              ),
              Object.defineProperty(
                this,
                'preventDefault',
                getPooledWarningPropertyDefinition('preventDefault', function () {})
              ),
              Object.defineProperty(
                this,
                'stopPropagation',
                getPooledWarningPropertyDefinition('stopPropagation', function () {})
              );
          },
        }),
          (SyntheticEvent.Interface = EventInterface),
          (SyntheticEvent.extend = function (Interface) {
            var Super = this,
              E = function () {};
            E.prototype = Super.prototype;
            var prototype = new E();
            function Class() {
              return Super.apply(this, arguments);
            }
            return (
              _assign(prototype, Class.prototype),
              (Class.prototype = prototype),
              (Class.prototype.constructor = Class),
              (Class.Interface = _assign({}, Super.Interface, Interface)),
              (Class.extend = Super.extend),
              addEventPoolingTo(Class),
              Class
            );
          }),
          addEventPoolingTo(SyntheticEvent);
        var SyntheticCompositionEvent = SyntheticEvent.extend({ data: null }),
          SyntheticInputEvent = SyntheticEvent.extend({ data: null }),
          END_KEYCODES = [9, 13, 27, 32],
          canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window,
          documentMode = null;
        canUseDOM && 'documentMode' in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode,
          useFallbackCompositionData =
            canUseDOM && (!canUseCompositionEvent || (documentMode && documentMode > 8 && documentMode <= 11)),
          SPACEBAR_CHAR = String.fromCharCode(32),
          eventTypes = {
            beforeInput: {
              phasedRegistrationNames: { bubbled: 'onBeforeInput', captured: 'onBeforeInputCapture' },
              dependencies: ['compositionend', 'keypress', 'textInput', 'paste'],
            },
            compositionEnd: {
              phasedRegistrationNames: { bubbled: 'onCompositionEnd', captured: 'onCompositionEndCapture' },
              dependencies: ['blur', 'compositionend', 'keydown', 'keypress', 'keyup', 'mousedown'],
            },
            compositionStart: {
              phasedRegistrationNames: { bubbled: 'onCompositionStart', captured: 'onCompositionStartCapture' },
              dependencies: ['blur', 'compositionstart', 'keydown', 'keypress', 'keyup', 'mousedown'],
            },
            compositionUpdate: {
              phasedRegistrationNames: { bubbled: 'onCompositionUpdate', captured: 'onCompositionUpdateCapture' },
              dependencies: ['blur', 'compositionupdate', 'keydown', 'keypress', 'keyup', 'mousedown'],
            },
          },
          hasSpaceKeypress = !1;
        function isFallbackCompositionEnd(topLevelType, nativeEvent) {
          switch (topLevelType) {
            case 'keyup':
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case 'keydown':
              return 229 !== nativeEvent.keyCode;
            case 'keypress':
            case 'mousedown':
            case 'blur':
              return !0;
            default:
              return !1;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          return 'object' == typeof detail && 'data' in detail ? detail.data : null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return 'ko' === nativeEvent.locale;
        }
        var isComposing = !1;
        function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          var eventType, fallbackData;
          if (
            (canUseCompositionEvent
              ? (eventType = (function getCompositionEventType(topLevelType) {
                  switch (topLevelType) {
                    case 'compositionstart':
                      return eventTypes.compositionStart;
                    case 'compositionend':
                      return eventTypes.compositionEnd;
                    case 'compositionupdate':
                      return eventTypes.compositionUpdate;
                  }
                })(topLevelType))
              : isComposing
              ? isFallbackCompositionEnd(topLevelType, nativeEvent) && (eventType = eventTypes.compositionEnd)
              : (function isFallbackCompositionStart(topLevelType, nativeEvent) {
                  return 'keydown' === topLevelType && 229 === nativeEvent.keyCode;
                })(topLevelType, nativeEvent) && (eventType = eventTypes.compositionStart),
            !eventType)
          )
            return null;
          useFallbackCompositionData &&
            !isUsingKoreanIME(nativeEvent) &&
            (isComposing || eventType !== eventTypes.compositionStart
              ? eventType === eventTypes.compositionEnd && isComposing && (fallbackData = getData())
              : (isComposing = (function initialize(nativeEventTarget) {
                  return (root = nativeEventTarget), (startText = getText()), !0;
                })(nativeEventTarget)));
          var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
          if (fallbackData) event.data = fallbackData;
          else {
            var customData = getDataFromCustomEvent(nativeEvent);
            null !== customData && (event.data = customData);
          }
          return accumulateTwoPhaseDispatches(event), event;
        }
        function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
          if (isComposing) {
            if (
              'compositionend' === topLevelType ||
              (!canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent))
            ) {
              var chars = getData();
              return (
                (function reset() {
                  (root = null), (startText = null), (fallbackText = null);
                })(),
                (isComposing = !1),
                chars
              );
            }
            return null;
          }
          switch (topLevelType) {
            case 'paste':
              return null;
            case 'keypress':
              if (
                !(function isKeypressCommand(nativeEvent) {
                  return (
                    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
                    !(nativeEvent.ctrlKey && nativeEvent.altKey)
                  );
                })(nativeEvent)
              ) {
                if (nativeEvent.char && nativeEvent.char.length > 1) return nativeEvent.char;
                if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case 'compositionend':
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
          var chars;
          if (
            !(chars = canUseTextInputEvent
              ? (function getNativeBeforeInputChars(topLevelType, nativeEvent) {
                  switch (topLevelType) {
                    case 'compositionend':
                      return getDataFromCustomEvent(nativeEvent);
                    case 'keypress':
                      return 32 !== nativeEvent.which ? null : ((hasSpaceKeypress = !0), SPACEBAR_CHAR);
                    case 'textInput':
                      var chars = nativeEvent.data;
                      return chars === SPACEBAR_CHAR && hasSpaceKeypress ? null : chars;
                    default:
                      return null;
                  }
                })(topLevelType, nativeEvent)
              : getFallbackBeforeInputChars(topLevelType, nativeEvent))
          )
            return null;
          var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
          return (event.data = chars), accumulateTwoPhaseDispatches(event), event;
        }
        var BeforeInputEventPlugin = {
            eventTypes,
            extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget),
                beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);
              return null === composition
                ? beforeInput
                : null === beforeInput
                ? composition
                : [composition, beforeInput];
            },
          },
          supportedInputTypes = {
            color: !0,
            date: !0,
            datetime: !0,
            'datetime-local': !0,
            email: !0,
            month: !0,
            number: !0,
            password: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0,
          };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return 'input' === nodeName ? !!supportedInputTypes[elem.type] : 'textarea' === nodeName;
        }
        var eventTypes$1 = {
          change: {
            phasedRegistrationNames: { bubbled: 'onChange', captured: 'onChangeCapture' },
            dependencies: ['blur', 'change', 'click', 'focus', 'input', 'keydown', 'keyup', 'selectionchange'],
          },
        };
        function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
          var event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);
          return (event.type = 'change'), enqueueStateRestore(target), accumulateTwoPhaseDispatches(event), event;
        }
        var activeElement = null,
          activeElementInst = null;
        function manualDispatchChangeEvent(nativeEvent) {
          !(function batchedUpdates(fn, bookkeeping) {
            if (isInsideEventHandler) return fn(bookkeeping);
            isInsideEventHandler = !0;
            try {
              return batchedUpdatesImpl(fn, bookkeeping);
            } finally {
              (isInsideEventHandler = !1), finishEventHandler();
            }
          })(
            runEventInBatch,
            createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent))
          );
        }
        function runEventInBatch(event) {
          runEventsInBatch(event);
        }
        function getInstIfValueChanged(targetInst) {
          if (updateValueIfChanged(getNodeFromInstance$1(targetInst))) return targetInst;
        }
        function getTargetInstForChangeEvent(topLevelType, targetInst) {
          if ('change' === topLevelType) return targetInst;
        }
        var isInputEventSupported = !1;
        function stopWatchingForValueChange() {
          activeElement &&
            (activeElement.detachEvent('onpropertychange', handlePropertyChange),
            (activeElement = null),
            (activeElementInst = null));
        }
        function handlePropertyChange(nativeEvent) {
          'value' === nativeEvent.propertyName &&
            getInstIfValueChanged(activeElementInst) &&
            manualDispatchChangeEvent(nativeEvent);
        }
        function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
          'focus' === topLevelType
            ? (stopWatchingForValueChange(),
              (function startWatchingForValueChange(target, targetInst) {
                (activeElementInst = targetInst),
                  (activeElement = target).attachEvent('onpropertychange', handlePropertyChange);
              })(target, targetInst))
            : 'blur' === topLevelType && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
          if ('selectionchange' === topLevelType || 'keyup' === topLevelType || 'keydown' === topLevelType)
            return getInstIfValueChanged(activeElementInst);
        }
        function getTargetInstForClickEvent(topLevelType, targetInst) {
          if ('click' === topLevelType) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
          if ('input' === topLevelType || 'change' === topLevelType) return getInstIfValueChanged(targetInst);
        }
        canUseDOM &&
          (isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9));
        var ChangeEventPlugin = {
            eventTypes: eventTypes$1,
            _isInputEventSupported: isInputEventSupported,
            extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var getTargetInstFunc,
                handleEventFunc,
                targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;
              if (
                (!(function shouldUseChangeEvent(elem) {
                  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
                  return 'select' === nodeName || ('input' === nodeName && 'file' === elem.type);
                })(targetNode)
                  ? isTextInputElement(targetNode)
                    ? isInputEventSupported
                      ? (getTargetInstFunc = getTargetInstForInputOrChangeEvent)
                      : ((getTargetInstFunc = getTargetInstForInputEventPolyfill),
                        (handleEventFunc = handleEventsForInputEventPolyfill))
                    : (function shouldUseClickEvent(elem) {
                        var nodeName = elem.nodeName;
                        return (
                          nodeName &&
                          'input' === nodeName.toLowerCase() &&
                          ('checkbox' === elem.type || 'radio' === elem.type)
                        );
                      })(targetNode) && (getTargetInstFunc = getTargetInstForClickEvent)
                  : (getTargetInstFunc = getTargetInstForChangeEvent),
                getTargetInstFunc)
              ) {
                var inst = getTargetInstFunc(topLevelType, targetInst);
                if (inst) return createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
              }
              handleEventFunc && handleEventFunc(topLevelType, targetNode, targetInst),
                'blur' === topLevelType &&
                  (function handleControlledInputBlur(node) {
                    var state = node._wrapperState;
                    state && state.controlled && 'number' === node.type && setDefaultValue(node, 'number', node.value);
                  })(targetNode);
            },
          },
          SyntheticUIEvent = SyntheticEvent.extend({ view: null, detail: null }),
          modifierKeyToProp = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' };
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          if (nativeEvent.getModifierState) return nativeEvent.getModifierState(keyArg);
          var keyProp = modifierKeyToProp[keyArg];
          return !!keyProp && !!nativeEvent[keyProp];
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var previousScreenX = 0,
          previousScreenY = 0,
          isMovementXSet = !1,
          isMovementYSet = !1,
          SyntheticMouseEvent = SyntheticUIEvent.extend({
            screenX: null,
            screenY: null,
            clientX: null,
            clientY: null,
            pageX: null,
            pageY: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            getModifierState: getEventModifierState,
            button: null,
            buttons: null,
            relatedTarget: function (event) {
              return (
                event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement)
              );
            },
            movementX: function (event) {
              if ('movementX' in event) return event.movementX;
              var screenX = previousScreenX;
              return (
                (previousScreenX = event.screenX),
                isMovementXSet ? ('mousemove' === event.type ? event.screenX - screenX : 0) : ((isMovementXSet = !0), 0)
              );
            },
            movementY: function (event) {
              if ('movementY' in event) return event.movementY;
              var screenY = previousScreenY;
              return (
                (previousScreenY = event.screenY),
                isMovementYSet ? ('mousemove' === event.type ? event.screenY - screenY : 0) : ((isMovementYSet = !0), 0)
              );
            },
          }),
          SyntheticPointerEvent = SyntheticMouseEvent.extend({
            pointerId: null,
            width: null,
            height: null,
            pressure: null,
            tangentialPressure: null,
            tiltX: null,
            tiltY: null,
            twist: null,
            pointerType: null,
            isPrimary: null,
          }),
          eventTypes$2 = {
            mouseEnter: { registrationName: 'onMouseEnter', dependencies: ['mouseout', 'mouseover'] },
            mouseLeave: { registrationName: 'onMouseLeave', dependencies: ['mouseout', 'mouseover'] },
            pointerEnter: { registrationName: 'onPointerEnter', dependencies: ['pointerout', 'pointerover'] },
            pointerLeave: { registrationName: 'onPointerLeave', dependencies: ['pointerout', 'pointerover'] },
          },
          EnterLeaveEventPlugin = {
            eventTypes: eventTypes$2,
            extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var win,
                from,
                to,
                eventInterface,
                leaveEventType,
                enterEventType,
                eventTypePrefix,
                isOverEvent = 'mouseover' === topLevelType || 'pointerover' === topLevelType,
                isOutEvent = 'mouseout' === topLevelType || 'pointerout' === topLevelType;
              if (isOverEvent && 0 == (32 & eventSystemFlags) && (nativeEvent.relatedTarget || nativeEvent.fromElement))
                return null;
              if (!isOutEvent && !isOverEvent) return null;
              if (nativeEventTarget.window === nativeEventTarget) win = nativeEventTarget;
              else {
                var doc = nativeEventTarget.ownerDocument;
                win = doc ? doc.defaultView || doc.parentWindow : window;
              }
              if (isOutEvent) {
                from = targetInst;
                var related = nativeEvent.relatedTarget || nativeEvent.toElement;
                if (null !== (to = related ? getClosestInstanceFromNode(related) : null))
                  (to !== getNearestMountedFiber(to) || (5 !== to.tag && 6 !== to.tag)) && (to = null);
              } else (from = null), (to = targetInst);
              if (from === to) return null;
              'mouseout' === topLevelType || 'mouseover' === topLevelType
                ? ((eventInterface = SyntheticMouseEvent),
                  (leaveEventType = eventTypes$2.mouseLeave),
                  (enterEventType = eventTypes$2.mouseEnter),
                  (eventTypePrefix = 'mouse'))
                : ('pointerout' !== topLevelType && 'pointerover' !== topLevelType) ||
                  ((eventInterface = SyntheticPointerEvent),
                  (leaveEventType = eventTypes$2.pointerLeave),
                  (enterEventType = eventTypes$2.pointerEnter),
                  (eventTypePrefix = 'pointer'));
              var fromNode = null == from ? win : getNodeFromInstance$1(from),
                toNode = null == to ? win : getNodeFromInstance$1(to),
                leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);
              (leave.type = eventTypePrefix + 'leave'), (leave.target = fromNode), (leave.relatedTarget = toNode);
              var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);
              return (
                (enter.type = eventTypePrefix + 'enter'),
                (enter.target = toNode),
                (enter.relatedTarget = fromNode),
                (function accumulateEnterLeaveDispatches(leave, enter, from, to) {
                  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
                })(leave, enter, from, to),
                0 == (64 & eventSystemFlags) ? [leave] : [leave, enter]
              );
            },
          };
        var objectIs =
            'function' == typeof Object.is
              ? Object.is
              : function is(x, y) {
                  return (x === y && (0 !== x || 1 / x == 1 / y)) || (x != x && y != y);
                },
          hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return !0;
          if ('object' != typeof objA || null === objA || 'object' != typeof objB || null === objB) return !1;
          var keysA = Object.keys(objA),
            keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return !1;
          for (var i = 0; i < keysA.length; i++)
            if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) return !1;
          return !0;
        }
        var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11,
          eventTypes$3 = {
            select: {
              phasedRegistrationNames: { bubbled: 'onSelect', captured: 'onSelectCapture' },
              dependencies: [
                'blur',
                'contextmenu',
                'dragend',
                'focus',
                'keydown',
                'keyup',
                'mousedown',
                'mouseup',
                'selectionchange',
              ],
            },
          },
          activeElement$1 = null,
          activeElementInst$1 = null,
          lastSelection = null,
          mouseDown = !1;
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget
            ? eventTarget.document
            : 9 === eventTarget.nodeType
            ? eventTarget
            : eventTarget.ownerDocument;
        }
        function constructSelectEvent(nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || null == activeElement$1 || activeElement$1 !== getActiveElement(doc)) return null;
          var currentSelection = (function getSelection$1(node) {
            if ('selectionStart' in node && hasSelectionCapabilities(node))
              return { start: node.selectionStart, end: node.selectionEnd };
            var selection = ((node.ownerDocument && node.ownerDocument.defaultView) || window).getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset,
            };
          })(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var syntheticEvent = SyntheticEvent.getPooled(
              eventTypes$3.select,
              activeElementInst$1,
              nativeEvent,
              nativeEventTarget
            );
            return (
              (syntheticEvent.type = 'select'),
              (syntheticEvent.target = activeElement$1),
              accumulateTwoPhaseDispatches(syntheticEvent),
              syntheticEvent
            );
          }
          return null;
        }
        var SelectEventPlugin = {
            eventTypes: eventTypes$3,
            extractEvents: function (
              topLevelType,
              targetInst,
              nativeEvent,
              nativeEventTarget,
              eventSystemFlags,
              container
            ) {
              var containerOrDoc = container || getEventTargetDocument(nativeEventTarget);
              if (
                !containerOrDoc ||
                !(function isListeningToAllDependencies(registrationName, mountAt) {
                  for (
                    var listenerMap = getListenerMapForElement(mountAt),
                      dependencies = registrationNameDependencies[registrationName],
                      i = 0;
                    i < dependencies.length;
                    i++
                  ) {
                    var dependency = dependencies[i];
                    if (!listenerMap.has(dependency)) return !1;
                  }
                  return !0;
                })('onSelect', containerOrDoc)
              )
                return null;
              var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;
              switch (topLevelType) {
                case 'focus':
                  (isTextInputElement(targetNode) || 'true' === targetNode.contentEditable) &&
                    ((activeElement$1 = targetNode), (activeElementInst$1 = targetInst), (lastSelection = null));
                  break;
                case 'blur':
                  (activeElement$1 = null), (activeElementInst$1 = null), (lastSelection = null);
                  break;
                case 'mousedown':
                  mouseDown = !0;
                  break;
                case 'contextmenu':
                case 'mouseup':
                case 'dragend':
                  return (mouseDown = !1), constructSelectEvent(nativeEvent, nativeEventTarget);
                case 'selectionchange':
                  if (skipSelectionChangeEvent) break;
                case 'keydown':
                case 'keyup':
                  return constructSelectEvent(nativeEvent, nativeEventTarget);
              }
              return null;
            },
          },
          SyntheticAnimationEvent = SyntheticEvent.extend({
            animationName: null,
            elapsedTime: null,
            pseudoElement: null,
          }),
          SyntheticClipboardEvent = SyntheticEvent.extend({
            clipboardData: function (event) {
              return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
            },
          }),
          SyntheticFocusEvent = SyntheticUIEvent.extend({ relatedTarget: null });
        function getEventCharCode(nativeEvent) {
          var charCode,
            keyCode = nativeEvent.keyCode;
          return (
            'charCode' in nativeEvent
              ? 0 === (charCode = nativeEvent.charCode) && 13 === keyCode && (charCode = 13)
              : (charCode = keyCode),
            10 === charCode && (charCode = 13),
            charCode >= 32 || 13 === charCode ? charCode : 0
          );
        }
        var normalizeKey = {
            Esc: 'Escape',
            Spacebar: ' ',
            Left: 'ArrowLeft',
            Up: 'ArrowUp',
            Right: 'ArrowRight',
            Down: 'ArrowDown',
            Del: 'Delete',
            Win: 'OS',
            Menu: 'ContextMenu',
            Apps: 'ContextMenu',
            Scroll: 'ScrollLock',
            MozPrintableKey: 'Unidentified',
          },
          translateToKey = {
            8: 'Backspace',
            9: 'Tab',
            12: 'Clear',
            13: 'Enter',
            16: 'Shift',
            17: 'Control',
            18: 'Alt',
            19: 'Pause',
            20: 'CapsLock',
            27: 'Escape',
            32: ' ',
            33: 'PageUp',
            34: 'PageDown',
            35: 'End',
            36: 'Home',
            37: 'ArrowLeft',
            38: 'ArrowUp',
            39: 'ArrowRight',
            40: 'ArrowDown',
            45: 'Insert',
            46: 'Delete',
            112: 'F1',
            113: 'F2',
            114: 'F3',
            115: 'F4',
            116: 'F5',
            117: 'F6',
            118: 'F7',
            119: 'F8',
            120: 'F9',
            121: 'F10',
            122: 'F11',
            123: 'F12',
            144: 'NumLock',
            145: 'ScrollLock',
            224: 'Meta',
          };
        var SyntheticKeyboardEvent = SyntheticUIEvent.extend({
            key: function getEventKey(nativeEvent) {
              if (nativeEvent.key) {
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if ('Unidentified' !== key) return key;
              }
              if ('keypress' === nativeEvent.type) {
                var charCode = getEventCharCode(nativeEvent);
                return 13 === charCode ? 'Enter' : String.fromCharCode(charCode);
              }
              return 'keydown' === nativeEvent.type || 'keyup' === nativeEvent.type
                ? translateToKey[nativeEvent.keyCode] || 'Unidentified'
                : '';
            },
            location: null,
            ctrlKey: null,
            shiftKey: null,
            altKey: null,
            metaKey: null,
            repeat: null,
            locale: null,
            getModifierState: getEventModifierState,
            charCode: function (event) {
              return 'keypress' === event.type ? getEventCharCode(event) : 0;
            },
            keyCode: function (event) {
              return 'keydown' === event.type || 'keyup' === event.type ? event.keyCode : 0;
            },
            which: function (event) {
              return 'keypress' === event.type
                ? getEventCharCode(event)
                : 'keydown' === event.type || 'keyup' === event.type
                ? event.keyCode
                : 0;
            },
          }),
          SyntheticDragEvent = SyntheticMouseEvent.extend({ dataTransfer: null }),
          SyntheticTouchEvent = SyntheticUIEvent.extend({
            touches: null,
            targetTouches: null,
            changedTouches: null,
            altKey: null,
            metaKey: null,
            ctrlKey: null,
            shiftKey: null,
            getModifierState: getEventModifierState,
          }),
          SyntheticTransitionEvent = SyntheticEvent.extend({
            propertyName: null,
            elapsedTime: null,
            pseudoElement: null,
          }),
          SyntheticWheelEvent = SyntheticMouseEvent.extend({
            deltaX: function (event) {
              return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function (event) {
              return 'deltaY' in event
                ? event.deltaY
                : 'wheelDeltaY' in event
                ? -event.wheelDeltaY
                : 'wheelDelta' in event
                ? -event.wheelDelta
                : 0;
            },
            deltaZ: null,
            deltaMode: null,
          }),
          knownHTMLTopLevelTypes = [
            'abort',
            'cancel',
            'canplay',
            'canplaythrough',
            'close',
            'durationchange',
            'emptied',
            'encrypted',
            'ended',
            'error',
            'input',
            'invalid',
            'load',
            'loadeddata',
            'loadedmetadata',
            'loadstart',
            'pause',
            'play',
            'playing',
            'progress',
            'ratechange',
            'reset',
            'seeked',
            'seeking',
            'stalled',
            'submit',
            'suspend',
            'timeupdate',
            'toggle',
            'volumechange',
            'waiting',
          ],
          SimpleEventPlugin = {
            eventTypes: simpleEventPluginEventTypes,
            extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {
              var EventConstructor,
                dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);
              if (!dispatchConfig) return null;
              switch (topLevelType) {
                case 'keypress':
                  if (0 === getEventCharCode(nativeEvent)) return null;
                case 'keydown':
                case 'keyup':
                  EventConstructor = SyntheticKeyboardEvent;
                  break;
                case 'blur':
                case 'focus':
                  EventConstructor = SyntheticFocusEvent;
                  break;
                case 'click':
                  if (2 === nativeEvent.button) return null;
                case 'auxclick':
                case 'dblclick':
                case 'mousedown':
                case 'mousemove':
                case 'mouseup':
                case 'mouseout':
                case 'mouseover':
                case 'contextmenu':
                  EventConstructor = SyntheticMouseEvent;
                  break;
                case 'drag':
                case 'dragend':
                case 'dragenter':
                case 'dragexit':
                case 'dragleave':
                case 'dragover':
                case 'dragstart':
                case 'drop':
                  EventConstructor = SyntheticDragEvent;
                  break;
                case 'touchcancel':
                case 'touchend':
                case 'touchmove':
                case 'touchstart':
                  EventConstructor = SyntheticTouchEvent;
                  break;
                case TOP_ANIMATION_END:
                case TOP_ANIMATION_ITERATION:
                case TOP_ANIMATION_START:
                  EventConstructor = SyntheticAnimationEvent;
                  break;
                case TOP_TRANSITION_END:
                  EventConstructor = SyntheticTransitionEvent;
                  break;
                case 'scroll':
                  EventConstructor = SyntheticUIEvent;
                  break;
                case 'wheel':
                  EventConstructor = SyntheticWheelEvent;
                  break;
                case 'copy':
                case 'cut':
                case 'paste':
                  EventConstructor = SyntheticClipboardEvent;
                  break;
                case 'gotpointercapture':
                case 'lostpointercapture':
                case 'pointercancel':
                case 'pointerdown':
                case 'pointermove':
                case 'pointerout':
                case 'pointerover':
                case 'pointerup':
                  EventConstructor = SyntheticPointerEvent;
                  break;
                default:
                  -1 === knownHTMLTopLevelTypes.indexOf(topLevelType) &&
                    error(
                      'SimpleEventPlugin: Unhandled event type, `%s`. This warning is likely caused by a bug in React. Please file an issue.',
                      topLevelType
                    ),
                    (EventConstructor = SyntheticEvent);
              }
              var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
              return accumulateTwoPhaseDispatches(event), event;
            },
          };
        !(function injectEventPluginOrder(injectedEventPluginOrder) {
          if (eventPluginOrder)
            throw Error(
              'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'
            );
          (eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder)), recomputePluginOrdering();
        })([
          'ResponderEventPlugin',
          'SimpleEventPlugin',
          'EnterLeaveEventPlugin',
          'ChangeEventPlugin',
          'SelectEventPlugin',
          'BeforeInputEventPlugin',
        ]),
          (function setComponentTree(
            getFiberCurrentPropsFromNodeImpl,
            getInstanceFromNodeImpl,
            getNodeFromInstanceImpl
          ) {
            (getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl),
              (getInstanceFromNode = getInstanceFromNodeImpl),
              ((getNodeFromInstance = getNodeFromInstanceImpl) && getInstanceFromNode) ||
                error(
                  'EventPluginUtils.setComponentTree(...): Injected module is missing getNodeFromInstance or getInstanceFromNode.'
                );
          })(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1),
          injectEventPluginsByName({
            SimpleEventPlugin,
            EnterLeaveEventPlugin,
            ChangeEventPlugin,
            SelectEventPlugin,
            BeforeInputEventPlugin,
          });
        var supportsUserTiming =
            'undefined' != typeof performance &&
            'function' == typeof performance.mark &&
            'function' == typeof performance.clearMarks &&
            'function' == typeof performance.measure &&
            'function' == typeof performance.clearMeasures,
          currentFiber = null,
          currentPhase = null,
          currentPhaseFiber = null,
          isCommitting = !1,
          hasScheduledUpdateInCurrentCommit = !1,
          hasScheduledUpdateInCurrentPhase = !1,
          commitCountInCurrentWorkLoop = 0,
          effectCountInCurrentCommit = 0,
          labelsInCurrentCommit = new Set(),
          formatMarkName = function (markName) {
            return ' ' + markName;
          },
          beginMark = function (markName) {
            performance.mark(formatMarkName(markName));
          },
          endMark = function (label, markName, warning) {
            var formattedMarkName = formatMarkName(markName),
              formattedLabel = (function (label, warning) {
                return '' + (warning ? ' ' : ' ') + label + (warning ? ' Warning: ' + warning : '');
              })(label, warning);
            try {
              performance.measure(formattedLabel, formattedMarkName);
            } catch (err) {}
            performance.clearMarks(formattedMarkName), performance.clearMeasures(formattedLabel);
          },
          getFiberMarkName = function (label, debugID) {
            return label + ' (#' + debugID + ')';
          },
          getFiberLabel = function (componentName, isMounted, phase) {
            return null === phase
              ? componentName + ' [' + (isMounted ? 'update' : 'mount') + ']'
              : componentName + '.' + phase;
          },
          beginFiberMark = function (fiber, phase) {
            var componentName = getComponentName(fiber.type) || 'Unknown',
              debugID = fiber._debugID,
              isMounted = null !== fiber.alternate,
              label = getFiberLabel(componentName, isMounted, phase);
            if (isCommitting && labelsInCurrentCommit.has(label)) return !1;
            labelsInCurrentCommit.add(label);
            var markName = getFiberMarkName(label, debugID);
            return beginMark(markName), !0;
          },
          clearFiberMark = function (fiber, phase) {
            var componentName = getComponentName(fiber.type) || 'Unknown',
              debugID = fiber._debugID,
              isMounted = null !== fiber.alternate,
              label = getFiberLabel(componentName, isMounted, phase);
            !(function (markName) {
              performance.clearMarks(formatMarkName(markName));
            })(getFiberMarkName(label, debugID));
          },
          endFiberMark = function (fiber, phase, warning) {
            var componentName = getComponentName(fiber.type) || 'Unknown',
              debugID = fiber._debugID,
              isMounted = null !== fiber.alternate,
              label = getFiberLabel(componentName, isMounted, phase),
              markName = getFiberMarkName(label, debugID);
            endMark(label, markName, warning);
          },
          shouldIgnoreFiber = function (fiber) {
            switch (fiber.tag) {
              case 3:
              case 5:
              case 6:
              case 4:
              case 7:
              case 10:
              case 9:
              case 8:
                return !0;
              default:
                return !1;
            }
          },
          resumeTimersRecursively = function (fiber) {
            null !== fiber.return && resumeTimersRecursively(fiber.return),
              fiber._debugIsCurrentlyTiming && beginFiberMark(fiber, null);
          };
        function recordEffect() {
          effectCountInCurrentCommit++;
        }
        function startWorkTimer(fiber) {
          supportsUserTiming &&
            !shouldIgnoreFiber(fiber) &&
            ((currentFiber = fiber), beginFiberMark(fiber, null) && (fiber._debugIsCurrentlyTiming = !0));
        }
        function cancelWorkTimer(fiber) {
          supportsUserTiming &&
            !shouldIgnoreFiber(fiber) &&
            ((fiber._debugIsCurrentlyTiming = !1), clearFiberMark(fiber, null));
        }
        function stopWorkTimer(fiber) {
          supportsUserTiming &&
            !shouldIgnoreFiber(fiber) &&
            ((currentFiber = fiber.return),
            fiber._debugIsCurrentlyTiming && ((fiber._debugIsCurrentlyTiming = !1), endFiberMark(fiber, null, null)));
        }
        function stopFailedWorkTimer(fiber) {
          if (
            supportsUserTiming &&
            !shouldIgnoreFiber(fiber) &&
            ((currentFiber = fiber.return), fiber._debugIsCurrentlyTiming)
          ) {
            fiber._debugIsCurrentlyTiming = !1;
            var warning =
              13 === fiber.tag ? 'Rendering was suspended' : 'An error was thrown inside this error boundary';
            endFiberMark(fiber, null, warning);
          }
        }
        function startPhaseTimer(fiber, phase) {
          supportsUserTiming &&
            (null !== currentPhase && null !== currentPhaseFiber && clearFiberMark(currentPhaseFiber, currentPhase),
            (currentPhaseFiber = null),
            (currentPhase = null),
            (hasScheduledUpdateInCurrentPhase = !1),
            beginFiberMark(fiber, phase) && ((currentPhaseFiber = fiber), (currentPhase = phase)));
        }
        function stopPhaseTimer() {
          supportsUserTiming &&
            (null !== currentPhase &&
              null !== currentPhaseFiber &&
              endFiberMark(
                currentPhaseFiber,
                currentPhase,
                hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null
              ),
            (currentPhase = null),
            (currentPhaseFiber = null));
        }
        function startWorkLoopTimer(nextUnitOfWork) {
          (currentFiber = nextUnitOfWork),
            supportsUserTiming &&
              ((commitCountInCurrentWorkLoop = 0),
              beginMark('(React Tree Reconciliation)'),
              null !== currentFiber && resumeTimersRecursively(currentFiber));
        }
        function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
          if (supportsUserTiming) {
            var warning = null;
            null !== interruptedBy
              ? (warning =
                  3 === interruptedBy.tag
                    ? 'A top-level update interrupted the previous render'
                    : 'An update to ' +
                      (getComponentName(interruptedBy.type) || 'Unknown') +
                      ' interrupted the previous render')
              : commitCountInCurrentWorkLoop > 1 && (warning = 'There were cascading updates'),
              (commitCountInCurrentWorkLoop = 0);
            var label = didCompleteRoot
              ? '(React Tree Reconciliation: Completed Root)'
              : '(React Tree Reconciliation: Yielded)';
            !(function () {
              for (var fiber = currentFiber; fiber; )
                fiber._debugIsCurrentlyTiming && endFiberMark(fiber, null, null), (fiber = fiber.return);
            })(),
              endMark(label, '(React Tree Reconciliation)', warning);
          }
        }
        function startCommitSnapshotEffectsTimer() {
          supportsUserTiming && ((effectCountInCurrentCommit = 0), beginMark('(Committing Snapshot Effects)'));
        }
        function stopCommitSnapshotEffectsTimer() {
          if (supportsUserTiming) {
            var count = effectCountInCurrentCommit;
            (effectCountInCurrentCommit = 0),
              endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);
          }
        }
        function startCommitHostEffectsTimer() {
          supportsUserTiming && ((effectCountInCurrentCommit = 0), beginMark('(Committing Host Effects)'));
        }
        function stopCommitHostEffectsTimer() {
          if (supportsUserTiming) {
            var count = effectCountInCurrentCommit;
            (effectCountInCurrentCommit = 0),
              endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
          }
        }
        function startCommitLifeCyclesTimer() {
          supportsUserTiming && ((effectCountInCurrentCommit = 0), beginMark('(Calling Lifecycle Methods)'));
        }
        function stopCommitLifeCyclesTimer() {
          if (supportsUserTiming) {
            var count = effectCountInCurrentCommit;
            (effectCountInCurrentCommit = 0),
              endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
          }
        }
        var fiberStack,
          valueStack = [];
        fiberStack = [];
        var warnedAboutMissingGetChildContext,
          index = -1;
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          index < 0
            ? error('Unexpected pop.')
            : (fiber !== fiberStack[index] && error('Unexpected Fiber popped.'),
              (cursor.current = valueStack[index]),
              (valueStack[index] = null),
              (fiberStack[index] = null),
              index--);
        }
        function push(cursor, value, fiber) {
          index++, (valueStack[index] = cursor.current), (fiberStack[index] = fiber), (cursor.current = value);
        }
        warnedAboutMissingGetChildContext = {};
        var emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var contextStackCursor = createCursor(emptyContextObject),
          didPerformWorkStackCursor = createCursor(!1),
          previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
          return didPushOwnContextIfProvider && isContextProvider(Component)
            ? previousContext
            : contextStackCursor.current;
        }
        function cacheContext(workInProgress, unmaskedContext, maskedContext) {
          var instance = workInProgress.stateNode;
          (instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
            (instance.__reactInternalMemoizedMaskedChildContext = maskedContext);
        }
        function getMaskedContext(workInProgress, unmaskedContext) {
          var type = workInProgress.type,
            contextTypes = type.contextTypes;
          if (!contextTypes) return emptyContextObject;
          var instance = workInProgress.stateNode;
          if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext)
            return instance.__reactInternalMemoizedMaskedChildContext;
          var context = {};
          for (var key in contextTypes) context[key] = unmaskedContext[key];
          var name = getComponentName(type) || 'Unknown';
          return (
            checkPropTypes(contextTypes, context, 'context', name, getCurrentFiberStackInDev),
            instance && cacheContext(workInProgress, unmaskedContext, context),
            context
          );
        }
        function hasContextChanged() {
          return didPerformWorkStackCursor.current;
        }
        function isContextProvider(type) {
          var childContextTypes = type.childContextTypes;
          return null != childContextTypes;
        }
        function popContext(fiber) {
          pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
        }
        function popTopLevelContextObject(fiber) {
          pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
          if (contextStackCursor.current !== emptyContextObject)
            throw Error(
              'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'
            );
          push(contextStackCursor, context, fiber), push(didPerformWorkStackCursor, didChange, fiber);
        }
        function processChildContext(fiber, type, parentContext) {
          var childContext,
            instance = fiber.stateNode,
            childContextTypes = type.childContextTypes;
          if ('function' != typeof instance.getChildContext) {
            var componentName = getComponentName(type) || 'Unknown';
            return (
              warnedAboutMissingGetChildContext[componentName] ||
                ((warnedAboutMissingGetChildContext[componentName] = !0),
                error(
                  '%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.',
                  componentName,
                  componentName
                )),
              parentContext
            );
          }
          for (var contextKey in (startPhaseTimer(fiber, 'getChildContext'),
          (childContext = instance.getChildContext()),
          stopPhaseTimer(),
          childContext))
            if (!(contextKey in childContextTypes))
              throw Error(
                (getComponentName(type) || 'Unknown') +
                  '.getChildContext(): key "' +
                  contextKey +
                  '" is not defined in childContextTypes.'
              );
          var name = getComponentName(type) || 'Unknown';
          return (
            checkPropTypes(childContextTypes, childContext, 'child context', name, getCurrentFiberStackInDev),
            _assign({}, parentContext, {}, childContext)
          );
        }
        function pushContextProvider(workInProgress) {
          var instance = workInProgress.stateNode,
            memoizedMergedChildContext =
              (instance && instance.__reactInternalMemoizedMergedChildContext) || emptyContextObject;
          return (
            (previousContext = contextStackCursor.current),
            push(contextStackCursor, memoizedMergedChildContext, workInProgress),
            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress),
            !0
          );
        }
        function invalidateContextProvider(workInProgress, type, didChange) {
          var instance = workInProgress.stateNode;
          if (!instance)
            throw Error(
              'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'
            );
          if (didChange) {
            var mergedContext = processChildContext(workInProgress, type, previousContext);
            (instance.__reactInternalMemoizedMergedChildContext = mergedContext),
              pop(didPerformWorkStackCursor, workInProgress),
              pop(contextStackCursor, workInProgress),
              push(contextStackCursor, mergedContext, workInProgress),
              push(didPerformWorkStackCursor, didChange, workInProgress);
          } else
            pop(didPerformWorkStackCursor, workInProgress), push(didPerformWorkStackCursor, didChange, workInProgress);
        }
        function findCurrentUnmaskedContext(fiber) {
          if (
            !(function isFiberMounted(fiber) {
              return getNearestMountedFiber(fiber) === fiber;
            })(fiber) ||
            1 !== fiber.tag
          )
            throw Error(
              'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'
            );
          var node = fiber;
          do {
            switch (node.tag) {
              case 3:
                return node.stateNode.context;
              case 1:
                if (isContextProvider(node.type)) return node.stateNode.__reactInternalMemoizedMergedChildContext;
            }
            node = node.return;
          } while (null !== node);
          throw Error(
            'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'
          );
        }
        var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
          Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
          Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
          Scheduler_shouldYield = Scheduler.unstable_shouldYield,
          Scheduler_requestPaint = Scheduler.unstable_requestPaint,
          Scheduler_now = Scheduler.unstable_now,
          Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
          Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
          Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
          Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
          Scheduler_LowPriority = Scheduler.unstable_LowPriority,
          Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
        if (null == tracing.__interactionsRef || null == tracing.__interactionsRef.current)
          throw Error(
            'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling'
          );
        var fakeCallbackNode = {},
          shouldYield = Scheduler_shouldYield,
          requestPaint = void 0 !== Scheduler_requestPaint ? Scheduler_requestPaint : function () {},
          syncQueue = null,
          immediateQueueCallbackNode = null,
          isFlushingSyncQueue = !1,
          initialTimeMs = Scheduler_now(),
          now =
            initialTimeMs < 1e4
              ? Scheduler_now
              : function () {
                  return Scheduler_now() - initialTimeMs;
                };
        function getCurrentPriorityLevel() {
          switch (Scheduler_getCurrentPriorityLevel()) {
            case Scheduler_ImmediatePriority:
              return 99;
            case Scheduler_UserBlockingPriority:
              return 98;
            case Scheduler_NormalPriority:
              return 97;
            case Scheduler_LowPriority:
              return 96;
            case Scheduler_IdlePriority:
              return 95;
            default:
              throw Error('Unknown priority level.');
          }
        }
        function reactPriorityToSchedulerPriority(reactPriorityLevel) {
          switch (reactPriorityLevel) {
            case 99:
              return Scheduler_ImmediatePriority;
            case 98:
              return Scheduler_UserBlockingPriority;
            case 97:
              return Scheduler_NormalPriority;
            case 96:
              return Scheduler_LowPriority;
            case 95:
              return Scheduler_IdlePriority;
            default:
              throw Error('Unknown priority level.');
          }
        }
        function runWithPriority$1(reactPriorityLevel, fn) {
          var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
          return Scheduler_runWithPriority(priorityLevel, fn);
        }
        function scheduleCallback(reactPriorityLevel, callback, options) {
          var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
          return Scheduler_scheduleCallback(priorityLevel, callback, options);
        }
        function scheduleSyncCallback(callback) {
          return (
            null === syncQueue
              ? ((syncQueue = [callback]),
                (immediateQueueCallbackNode = Scheduler_scheduleCallback(
                  Scheduler_ImmediatePriority,
                  flushSyncCallbackQueueImpl
                )))
              : syncQueue.push(callback),
            fakeCallbackNode
          );
        }
        function flushSyncCallbackQueue() {
          if (null !== immediateQueueCallbackNode) {
            var node = immediateQueueCallbackNode;
            (immediateQueueCallbackNode = null), Scheduler_cancelCallback(node);
          }
          flushSyncCallbackQueueImpl();
        }
        function flushSyncCallbackQueueImpl() {
          if (!isFlushingSyncQueue && null !== syncQueue) {
            isFlushingSyncQueue = !0;
            var i = 0;
            try {
              var queue = syncQueue;
              runWithPriority$1(99, function () {
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(!0);
                  } while (null !== callback);
                }
              }),
                (syncQueue = null);
            } catch (error) {
              throw (
                (null !== syncQueue && (syncQueue = syncQueue.slice(i + 1)),
                Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue),
                error)
              );
            } finally {
              isFlushingSyncQueue = !1;
            }
          }
        }
        var Sync = 1073741823;
        function msToExpirationTime(ms) {
          return 1073741821 - ((ms / 10) | 0);
        }
        function expirationTimeToMs(expirationTime) {
          return 10 * (1073741821 - expirationTime);
        }
        function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
          return (
            1073741821 -
            (function ceiling(num, precision) {
              return (1 + ((num / precision) | 0)) * precision;
            })(1073741821 - currentTime + expirationInMs / 10, bucketSizeMs / 10)
          );
        }
        function computeInteractiveExpiration(currentTime) {
          return computeExpirationBucket(currentTime, 500, 100);
        }
        function inferPriorityFromExpirationTime(currentTime, expirationTime) {
          if (expirationTime === Sync) return 99;
          if (1 === expirationTime || 2 === expirationTime) return 95;
          var msUntil = expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);
          return msUntil <= 0 ? 99 : msUntil <= 600 ? 98 : msUntil <= 5250 ? 97 : 95;
        }
        var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function (fiber, instance) {},
            flushPendingUnsafeLifecycleWarnings: function () {},
            recordLegacyContextWarning: function (fiber, instance) {},
            flushLegacyContextWarning: function () {},
            discardPendingWarnings: function () {},
          },
          setToSortedString = function (set) {
            var array = [];
            return (
              set.forEach(function (value) {
                array.push(value);
              }),
              array.sort().join(', ')
            );
          },
          pendingComponentWillMountWarnings = [],
          pendingUNSAFE_ComponentWillMountWarnings = [],
          pendingComponentWillReceivePropsWarnings = [],
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
          pendingComponentWillUpdateWarnings = [],
          pendingUNSAFE_ComponentWillUpdateWarnings = [],
          didWarnAboutUnsafeLifecycles = new Set();
        (ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) ||
            ('function' == typeof instance.componentWillMount &&
              !0 !== instance.componentWillMount.__suppressDeprecationWarning &&
              pendingComponentWillMountWarnings.push(fiber),
            1 & fiber.mode &&
              'function' == typeof instance.UNSAFE_componentWillMount &&
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber),
            'function' == typeof instance.componentWillReceiveProps &&
              !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning &&
              pendingComponentWillReceivePropsWarnings.push(fiber),
            1 & fiber.mode &&
              'function' == typeof instance.UNSAFE_componentWillReceiveProps &&
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),
            'function' == typeof instance.componentWillUpdate &&
              !0 !== instance.componentWillUpdate.__suppressDeprecationWarning &&
              pendingComponentWillUpdateWarnings.push(fiber),
            1 & fiber.mode &&
              'function' == typeof instance.UNSAFE_componentWillUpdate &&
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        }),
          (ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
            var componentWillMountUniqueNames = new Set();
            pendingComponentWillMountWarnings.length > 0 &&
              (pendingComponentWillMountWarnings.forEach(function (fiber) {
                componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component'),
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
              }),
              (pendingComponentWillMountWarnings = []));
            var UNSAFE_componentWillMountUniqueNames = new Set();
            pendingUNSAFE_ComponentWillMountWarnings.length > 0 &&
              (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component'),
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
              }),
              (pendingUNSAFE_ComponentWillMountWarnings = []));
            var componentWillReceivePropsUniqueNames = new Set();
            pendingComponentWillReceivePropsWarnings.length > 0 &&
              (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component'),
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
              }),
              (pendingComponentWillReceivePropsWarnings = []));
            var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
            pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0 &&
              (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component'),
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
              }),
              (pendingUNSAFE_ComponentWillReceivePropsWarnings = []));
            var componentWillUpdateUniqueNames = new Set();
            pendingComponentWillUpdateWarnings.length > 0 &&
              (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
                componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component'),
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
              }),
              (pendingComponentWillUpdateWarnings = []));
            var UNSAFE_componentWillUpdateUniqueNames = new Set();
            (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0 &&
              (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component'),
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
              }),
              (pendingUNSAFE_ComponentWillUpdateWarnings = [])),
            UNSAFE_componentWillMountUniqueNames.size > 0) &&
              error(
                'Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s',
                setToSortedString(UNSAFE_componentWillMountUniqueNames)
              );
            UNSAFE_componentWillReceivePropsUniqueNames.size > 0 &&
              error(
                "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n\nPlease update the following components: %s",
                setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames)
              );
            UNSAFE_componentWillUpdateUniqueNames.size > 0 &&
              error(
                'Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s',
                setToSortedString(UNSAFE_componentWillUpdateUniqueNames)
              );
            componentWillMountUniqueNames.size > 0 &&
              warn(
                'componentWillMount has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s',
                setToSortedString(componentWillMountUniqueNames)
              );
            componentWillReceivePropsUniqueNames.size > 0 &&
              warn(
                "componentWillReceiveProps has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://fb.me/react-derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
                setToSortedString(componentWillReceivePropsUniqueNames)
              );
            componentWillUpdateUniqueNames.size > 0 &&
              warn(
                'componentWillUpdate has been renamed, and is not recommended for use. See https://fb.me/react-unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 17.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s',
                setToSortedString(componentWillUpdateUniqueNames)
              );
          });
        var pendingLegacyContextWarning = new Map(),
          didWarnAboutLegacyContext = new Set();
        (ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
          var strictRoot = (function (fiber) {
            for (var maybeStrictRoot = null, node = fiber; null !== node; )
              1 & node.mode && (maybeStrictRoot = node), (node = node.return);
            return maybeStrictRoot;
          })(fiber);
          if (null !== strictRoot) {
            if (!didWarnAboutLegacyContext.has(fiber.type)) {
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              (null != fiber.type.contextTypes ||
                null != fiber.type.childContextTypes ||
                (null !== instance && 'function' == typeof instance.getChildContext)) &&
                (void 0 === warningsForRoot &&
                  ((warningsForRoot = []), pendingLegacyContextWarning.set(strictRoot, warningsForRoot)),
                warningsForRoot.push(fiber));
            }
          } else
            error(
              'Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.'
            );
        }),
          (ReactStrictModeWarnings.flushLegacyContextWarning = function () {
            pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
              if (0 !== fiberArray.length) {
                var firstFiber = fiberArray[0],
                  uniqueNames = new Set();
                fiberArray.forEach(function (fiber) {
                  uniqueNames.add(getComponentName(fiber.type) || 'Component'),
                    didWarnAboutLegacyContext.add(fiber.type);
                }),
                  error(
                    'Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://fb.me/react-legacy-context%s',
                    setToSortedString(uniqueNames),
                    getStackByFiberInDevAndProd(firstFiber)
                  );
              }
            });
          }),
          (ReactStrictModeWarnings.discardPendingWarnings = function () {
            (pendingComponentWillMountWarnings = []),
              (pendingUNSAFE_ComponentWillMountWarnings = []),
              (pendingComponentWillReceivePropsWarnings = []),
              (pendingUNSAFE_ComponentWillReceivePropsWarnings = []),
              (pendingComponentWillUpdateWarnings = []),
              (pendingUNSAFE_ComponentWillUpdateWarnings = []),
              (pendingLegacyContextWarning = new Map());
          });
        var resolveFamily = null,
          failedBoundaries = null,
          setRefreshHandler = function (handler) {
            resolveFamily = handler;
          };
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveClassForHotReloading(type) {
          return resolveFunctionForHotReloading(type);
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          if (void 0 === family) {
            if (null != type && 'function' == typeof type.render) {
              var currentRender = resolveFunctionForHotReloading(type.render);
              if (type.render !== currentRender) {
                var syntheticType = { $$typeof: REACT_FORWARD_REF_TYPE, render: currentRender };
                return void 0 !== type.displayName && (syntheticType.displayName = type.displayName), syntheticType;
              }
            }
            return type;
          }
          return family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return !1;
          var prevType = fiber.elementType,
            nextType = element.type,
            needsCompareFamilies = !1,
            $$typeofNextType = 'object' == typeof nextType && null !== nextType ? nextType.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              'function' == typeof nextType && (needsCompareFamilies = !0);
              break;
            case 0:
              ('function' == typeof nextType || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
              break;
            case 11:
              ($$typeofNextType === REACT_FORWARD_REF_TYPE || $$typeofNextType === REACT_LAZY_TYPE) &&
                (needsCompareFamilies = !0);
              break;
            case 14:
            case 15:
              ($$typeofNextType === REACT_MEMO_TYPE || $$typeofNextType === REACT_LAZY_TYPE) &&
                (needsCompareFamilies = !0);
              break;
            default:
              return !1;
          }
          if (needsCompareFamilies) {
            var prevFamily = resolveFamily(prevType);
            if (void 0 !== prevFamily && prevFamily === resolveFamily(nextType)) return !0;
          }
          return !1;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily &&
            'function' == typeof WeakSet &&
            (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));
        }
        var scheduleRefresh = function (root, update) {
            if (null !== resolveFamily) {
              var staleFamilies = update.staleFamilies,
                updatedFamilies = update.updatedFamilies;
              flushPassiveEffects(),
                flushSync(function () {
                  !(function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
                    var alternate = fiber.alternate,
                      child = fiber.child,
                      sibling = fiber.sibling,
                      tag = fiber.tag,
                      type = fiber.type,
                      candidateType = null;
                    switch (tag) {
                      case 0:
                      case 15:
                      case 1:
                        candidateType = type;
                        break;
                      case 11:
                        candidateType = type.render;
                    }
                    if (null === resolveFamily) throw new Error('Expected resolveFamily to be set during hot reload.');
                    var needsRender = !1,
                      needsRemount = !1;
                    if (null !== candidateType) {
                      var family = resolveFamily(candidateType);
                      void 0 !== family &&
                        (staleFamilies.has(family)
                          ? (needsRemount = !0)
                          : updatedFamilies.has(family) && (1 === tag ? (needsRemount = !0) : (needsRender = !0)));
                    }
                    null !== failedBoundaries &&
                      (failedBoundaries.has(fiber) || (null !== alternate && failedBoundaries.has(alternate))) &&
                      (needsRemount = !0);
                    needsRemount && (fiber._debugNeedsRemount = !0);
                    (needsRemount || needsRender) && scheduleWork(fiber, Sync);
                    null === child ||
                      needsRemount ||
                      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
                    null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
                  })(root.current, updatedFamilies, staleFamilies);
                });
            }
          },
          scheduleRoot = function (root, element) {
            root.context === emptyContextObject &&
              (flushPassiveEffects(),
              (function syncUpdates(fn, a, b, c) {
                return runWithPriority$1(99, fn.bind(null, a, b, c));
              })(function () {
                updateContainer(element, root, null, null);
              }));
          };
        var findHostInstancesForRefresh = function (root, families) {
          var hostInstances = new Set(),
            types = new Set(
              families.map(function (family) {
                return family.current;
              })
            );
          return (
            (function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
              var child = fiber.child,
                sibling = fiber.sibling,
                tag = fiber.tag,
                type = fiber.type,
                candidateType = null;
              switch (tag) {
                case 0:
                case 15:
                case 1:
                  candidateType = type;
                  break;
                case 11:
                  candidateType = type.render;
              }
              var didMatch = !1;
              null !== candidateType && types.has(candidateType) && (didMatch = !0);
              didMatch
                ? (function findHostInstancesForFiberShallowly(fiber, hostInstances) {
                    if (
                      (function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
                        var node = fiber,
                          foundHostInstances = !1;
                        for (;;) {
                          if (5 === node.tag) (foundHostInstances = !0), hostInstances.add(node.stateNode);
                          else if (null !== node.child) {
                            (node.child.return = node), (node = node.child);
                            continue;
                          }
                          if (node === fiber) return foundHostInstances;
                          for (; null === node.sibling; ) {
                            if (null === node.return || node.return === fiber) return foundHostInstances;
                            node = node.return;
                          }
                          (node.sibling.return = node.return), (node = node.sibling);
                        }
                        return !1;
                      })(fiber, hostInstances)
                    )
                      return;
                    var node = fiber;
                    for (;;) {
                      switch (node.tag) {
                        case 5:
                          return void hostInstances.add(node.stateNode);
                        case 4:
                        case 3:
                          return void hostInstances.add(node.stateNode.containerInfo);
                      }
                      if (null === node.return) throw new Error('Expected to reach root first.');
                      node = node.return;
                    }
                  })(fiber, hostInstances)
                : null !== child && findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
              null !== sibling && findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
            })(root.current, types, hostInstances),
            hostInstances
          );
        };
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = _assign({}, baseProps),
              defaultProps = Component.defaultProps;
            for (var propName in defaultProps) void 0 === props[propName] && (props[propName] = defaultProps[propName]);
            return props;
          }
          return baseProps;
        }
        function readLazyComponentType(lazyComponent) {
          if (
            ((function initializeLazyComponentType(lazyComponent) {
              if (-1 === lazyComponent._status) {
                lazyComponent._status = 0;
                var thenable = (0, lazyComponent._ctor)();
                (lazyComponent._result = thenable),
                  thenable.then(
                    function (moduleObject) {
                      if (0 === lazyComponent._status) {
                        var defaultExport = moduleObject.default;
                        void 0 === defaultExport &&
                          error(
                            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
                            moduleObject
                          ),
                          (lazyComponent._status = 1),
                          (lazyComponent._result = defaultExport);
                      }
                    },
                    function (error) {
                      0 === lazyComponent._status && ((lazyComponent._status = 2), (lazyComponent._result = error));
                    }
                  );
              }
            })(lazyComponent),
            1 !== lazyComponent._status)
          )
            throw lazyComponent._result;
          return lazyComponent._result;
        }
        var rendererSigil,
          valueCursor = createCursor(null);
        rendererSigil = {};
        var currentlyRenderingFiber = null,
          lastContextDependency = null,
          lastContextWithAllBitsObserved = null,
          isDisallowedContextReadInDEV = !1;
        function resetContextDependencies() {
          (currentlyRenderingFiber = null),
            (lastContextDependency = null),
            (lastContextWithAllBitsObserved = null),
            (isDisallowedContextReadInDEV = !1);
        }
        function enterDisallowedContextReadInDEV() {
          isDisallowedContextReadInDEV = !0;
        }
        function exitDisallowedContextReadInDEV() {
          isDisallowedContextReadInDEV = !1;
        }
        function pushProvider(providerFiber, nextValue) {
          var context = providerFiber.type._context;
          push(valueCursor, context._currentValue, providerFiber),
            (context._currentValue = nextValue),
            void 0 !== context._currentRenderer &&
              null !== context._currentRenderer &&
              context._currentRenderer !== rendererSigil &&
              error(
                'Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.'
              ),
            (context._currentRenderer = rendererSigil);
        }
        function popProvider(providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber), (providerFiber.type._context._currentValue = currentValue);
        }
        function scheduleWorkOnParentPath(parent, renderExpirationTime) {
          for (var node = parent; null !== node; ) {
            var alternate = node.alternate;
            if (node.childExpirationTime < renderExpirationTime)
              (node.childExpirationTime = renderExpirationTime),
                null !== alternate &&
                  alternate.childExpirationTime < renderExpirationTime &&
                  (alternate.childExpirationTime = renderExpirationTime);
            else {
              if (!(null !== alternate && alternate.childExpirationTime < renderExpirationTime)) break;
              alternate.childExpirationTime = renderExpirationTime;
            }
            node = node.return;
          }
        }
        function prepareToReadContext(workInProgress, renderExpirationTime) {
          (currentlyRenderingFiber = workInProgress),
            (lastContextDependency = null),
            (lastContextWithAllBitsObserved = null);
          var dependencies = workInProgress.dependencies;
          null !== dependencies &&
            null !== dependencies.firstContext &&
            (dependencies.expirationTime >= renderExpirationTime && markWorkInProgressReceivedUpdate(),
            (dependencies.firstContext = null));
        }
        function readContext(context, observedBits) {
          if (
            (isDisallowedContextReadInDEV &&
              error(
                'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
              ),
            lastContextWithAllBitsObserved === context)
          );
          else if (!1 === observedBits || 0 === observedBits);
          else {
            var resolvedObservedBits;
            'number' != typeof observedBits || 1073741823 === observedBits
              ? ((lastContextWithAllBitsObserved = context), (resolvedObservedBits = 1073741823))
              : (resolvedObservedBits = observedBits);
            var contextItem = { context, observedBits: resolvedObservedBits, next: null };
            if (null === lastContextDependency) {
              if (null === currentlyRenderingFiber)
                throw Error(
                  'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
                );
              (lastContextDependency = contextItem),
                (currentlyRenderingFiber.dependencies = {
                  expirationTime: 0,
                  firstContext: contextItem,
                  responders: null,
                });
            } else lastContextDependency = lastContextDependency.next = contextItem;
          }
          return context._currentValue;
        }
        var didWarnUpdateInsideUpdate,
          currentlyProcessingQueue,
          ForceUpdate = 2,
          hasForceUpdate = !1;
        function initializeUpdateQueue(fiber) {
          var queue = { baseState: fiber.memoizedState, baseQueue: null, shared: { pending: null }, effects: null };
          fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current, workInProgress) {
          var queue = workInProgress.updateQueue,
            currentQueue = current.updateQueue;
          if (queue === currentQueue) {
            var clone = {
              baseState: currentQueue.baseState,
              baseQueue: currentQueue.baseQueue,
              shared: currentQueue.shared,
              effects: currentQueue.effects,
            };
            workInProgress.updateQueue = clone;
          }
        }
        function createUpdate(expirationTime, suspenseConfig) {
          var update = { expirationTime, suspenseConfig, tag: 0, payload: null, callback: null, next: null };
          return (update.next = update), (update.priority = getCurrentPriorityLevel()), update;
        }
        function enqueueUpdate(fiber, update) {
          var updateQueue = fiber.updateQueue;
          if (null !== updateQueue) {
            var sharedQueue = updateQueue.shared,
              pending = sharedQueue.pending;
            null === pending ? (update.next = update) : ((update.next = pending.next), (pending.next = update)),
              (sharedQueue.pending = update),
              currentlyProcessingQueue !== sharedQueue ||
                didWarnUpdateInsideUpdate ||
                (error(
                  'An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.'
                ),
                (didWarnUpdateInsideUpdate = !0));
          }
        }
        function enqueueCapturedUpdate(workInProgress, update) {
          var current = workInProgress.alternate;
          null !== current && cloneUpdateQueue(current, workInProgress);
          var queue = workInProgress.updateQueue,
            last = queue.baseQueue;
          null === last
            ? ((queue.baseQueue = update.next = update), (update.next = update))
            : ((update.next = last.next), (last.next = update));
        }
        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
          switch (update.tag) {
            case 1:
              var payload = update.payload;
              if ('function' == typeof payload) {
                enterDisallowedContextReadInDEV(),
                  1 & workInProgress.mode && payload.call(instance, prevState, nextProps);
                var nextState = payload.call(instance, prevState, nextProps);
                return exitDisallowedContextReadInDEV(), nextState;
              }
              return payload;
            case 3:
              workInProgress.effectTag = (-4097 & workInProgress.effectTag) | 64;
            case 0:
              var partialState,
                _payload = update.payload;
              return (
                'function' == typeof _payload
                  ? (enterDisallowedContextReadInDEV(),
                    1 & workInProgress.mode && _payload.call(instance, prevState, nextProps),
                    (partialState = _payload.call(instance, prevState, nextProps)),
                    exitDisallowedContextReadInDEV())
                  : (partialState = _payload),
                null == partialState ? prevState : _assign({}, prevState, partialState)
              );
            case ForceUpdate:
              return (hasForceUpdate = !0), prevState;
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress, props, instance, renderExpirationTime) {
          var queue = workInProgress.updateQueue;
          (hasForceUpdate = !1), (currentlyProcessingQueue = queue.shared);
          var baseQueue = queue.baseQueue,
            pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next,
                pendingFirst = pendingQueue.next;
              (baseQueue.next = pendingFirst), (pendingQueue.next = baseFirst);
            }
            (baseQueue = pendingQueue), (queue.shared.pending = null);
            var current = workInProgress.alternate;
            if (null !== current) {
              var currentQueue = current.updateQueue;
              null !== currentQueue && (currentQueue.baseQueue = pendingQueue);
            }
          }
          if (null !== baseQueue) {
            var first = baseQueue.next,
              newState = queue.baseState,
              newExpirationTime = 0,
              newBaseState = null,
              newBaseQueueFirst = null,
              newBaseQueueLast = null;
            if (null !== first)
              for (var update = first; ; ) {
                var updateExpirationTime = update.expirationTime;
                if (updateExpirationTime < renderExpirationTime) {
                  var clone = {
                    expirationTime: update.expirationTime,
                    suspenseConfig: update.suspenseConfig,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null,
                  };
                  null === newBaseQueueLast
                    ? ((newBaseQueueFirst = newBaseQueueLast = clone), (newBaseState = newState))
                    : (newBaseQueueLast = newBaseQueueLast.next = clone),
                    updateExpirationTime > newExpirationTime && (newExpirationTime = updateExpirationTime);
                } else {
                  if (null !== newBaseQueueLast) {
                    var _clone = {
                      expirationTime: Sync,
                      suspenseConfig: update.suspenseConfig,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null,
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (
                    (markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig),
                    (newState = getStateFromUpdate(workInProgress, 0, update, newState, props, instance)),
                    null !== update.callback)
                  ) {
                    workInProgress.effectTag |= 32;
                    var effects = queue.effects;
                    null === effects ? (queue.effects = [update]) : effects.push(update);
                  }
                }
                if (null === (update = update.next) || update === first) {
                  if (null === (pendingQueue = queue.shared.pending)) break;
                  (update = baseQueue.next = pendingQueue.next),
                    (pendingQueue.next = first),
                    (queue.baseQueue = baseQueue = pendingQueue),
                    (queue.shared.pending = null);
                }
              }
            null === newBaseQueueLast ? (newBaseState = newState) : (newBaseQueueLast.next = newBaseQueueFirst),
              (queue.baseState = newBaseState),
              (queue.baseQueue = newBaseQueueLast),
              markUnprocessedUpdateTime(newExpirationTime),
              (workInProgress.expirationTime = newExpirationTime),
              (workInProgress.memoizedState = newState);
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ('function' != typeof callback)
            throw Error('Invalid argument passed as callback. Expected a function. Instead received: ' + callback);
          callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = !1;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
          var effects = finishedQueue.effects;
          if (((finishedQueue.effects = null), null !== effects))
            for (var i = 0; i < effects.length; i++) {
              var effect = effects[i],
                callback = effect.callback;
              null !== callback && ((effect.callback = null), callCallback(callback, instance));
            }
        }
        (didWarnUpdateInsideUpdate = !1), (currentlyProcessingQueue = null);
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        function requestCurrentSuspenseConfig() {
          return ReactCurrentBatchConfig.suspense;
        }
        var didWarnAboutStateAssignmentForComponent,
          didWarnAboutUninitializedState,
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate,
          didWarnAboutLegacyLifecyclesAndDerivedState,
          didWarnAboutUndefinedDerivedState,
          warnOnUndefinedDerivedState,
          warnOnInvalidCallback,
          didWarnAboutDirectlyAssigningPropsToState,
          didWarnAboutContextTypeAndContextTypes,
          didWarnAboutInvalidateContextType,
          fakeInternalInstance = {},
          isArray = Array.isArray,
          emptyRefsObject = new React.Component().refs;
        (didWarnAboutStateAssignmentForComponent = new Set()),
          (didWarnAboutUninitializedState = new Set()),
          (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set()),
          (didWarnAboutLegacyLifecyclesAndDerivedState = new Set()),
          (didWarnAboutDirectlyAssigningPropsToState = new Set()),
          (didWarnAboutUndefinedDerivedState = new Set()),
          (didWarnAboutContextTypeAndContextTypes = new Set()),
          (didWarnAboutInvalidateContextType = new Set());
        var didWarnOnInvalidCallback = new Set();
        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress.memoizedState;
          1 & workInProgress.mode && getDerivedStateFromProps(nextProps, prevState);
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          warnOnUndefinedDerivedState(ctor, partialState);
          var memoizedState = null == partialState ? prevState : _assign({}, prevState, partialState);
          ((workInProgress.memoizedState = memoizedState), 0 === workInProgress.expirationTime) &&
            (workInProgress.updateQueue.baseState = memoizedState);
        }
        (warnOnInvalidCallback = function (callback, callerName) {
          if (null !== callback && 'function' != typeof callback) {
            var key = callerName + '_' + callback;
            didWarnOnInvalidCallback.has(key) ||
              (didWarnOnInvalidCallback.add(key),
              error(
                '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
                callerName,
                callback
              ));
          }
        }),
          (warnOnUndefinedDerivedState = function (type, partialState) {
            if (void 0 === partialState) {
              var componentName = getComponentName(type) || 'Component';
              didWarnAboutUndefinedDerivedState.has(componentName) ||
                (didWarnAboutUndefinedDerivedState.add(componentName),
                error(
                  '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.',
                  componentName
                ));
            }
          }),
          Object.defineProperty(fakeInternalInstance, '_processChildContext', {
            enumerable: !1,
            value: function () {
              throw Error(
                "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)."
              );
            },
          }),
          Object.freeze(fakeInternalInstance);
        var didWarnAboutMaps,
          didWarnAboutGenerators,
          didWarnAboutStringRefs,
          ownerHasKeyUseWarning,
          ownerHasFunctionTypeWarning,
          classComponentUpdater = {
            isMounted: function isMounted(component) {
              var owner = ReactCurrentOwner.current;
              if (null !== owner && 1 === owner.tag) {
                var ownerFiber = owner,
                  instance = ownerFiber.stateNode;
                instance._warnedAboutRefsInRender ||
                  error(
                    '%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
                    getComponentName(ownerFiber.type) || 'A component'
                  ),
                  (instance._warnedAboutRefsInRender = !0);
              }
              var fiber = get(component);
              return !!fiber && getNearestMountedFiber(fiber) === fiber;
            },
            enqueueSetState: function (inst, payload, callback) {
              var fiber = get(inst),
                currentTime = requestCurrentTimeForUpdate(),
                suspenseConfig = requestCurrentSuspenseConfig(),
                expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig),
                update = createUpdate(expirationTime, suspenseConfig);
              (update.payload = payload),
                null != callback && (warnOnInvalidCallback(callback, 'setState'), (update.callback = callback)),
                enqueueUpdate(fiber, update),
                scheduleWork(fiber, expirationTime);
            },
            enqueueReplaceState: function (inst, payload, callback) {
              var fiber = get(inst),
                currentTime = requestCurrentTimeForUpdate(),
                suspenseConfig = requestCurrentSuspenseConfig(),
                expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig),
                update = createUpdate(expirationTime, suspenseConfig);
              (update.tag = 1),
                (update.payload = payload),
                null != callback && (warnOnInvalidCallback(callback, 'replaceState'), (update.callback = callback)),
                enqueueUpdate(fiber, update),
                scheduleWork(fiber, expirationTime);
            },
            enqueueForceUpdate: function (inst, callback) {
              var fiber = get(inst),
                currentTime = requestCurrentTimeForUpdate(),
                suspenseConfig = requestCurrentSuspenseConfig(),
                expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig),
                update = createUpdate(expirationTime, suspenseConfig);
              (update.tag = ForceUpdate),
                null != callback && (warnOnInvalidCallback(callback, 'forceUpdate'), (update.callback = callback)),
                enqueueUpdate(fiber, update),
                scheduleWork(fiber, expirationTime);
            },
          };
        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress.stateNode;
          if ('function' == typeof instance.shouldComponentUpdate) {
            1 & workInProgress.mode && instance.shouldComponentUpdate(newProps, newState, nextContext),
              startPhaseTimer(workInProgress, 'shouldComponentUpdate');
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            return (
              stopPhaseTimer(),
              void 0 === shouldUpdate &&
                error(
                  '%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.',
                  getComponentName(ctor) || 'Component'
                ),
              shouldUpdate
            );
          }
          return (
            !ctor.prototype ||
            !ctor.prototype.isPureReactComponent ||
            !shallowEqual(oldProps, newProps) ||
            !shallowEqual(oldState, newState)
          );
        }
        function adoptClassInstance(workInProgress, instance) {
          (instance.updater = classComponentUpdater),
            (workInProgress.stateNode = instance),
            (function set(key, value) {
              key._reactInternalFiber = value;
            })(instance, workInProgress),
            (instance._reactInternalInstance = fakeInternalInstance);
        }
        function constructClassInstance(workInProgress, ctor, props) {
          var isLegacyContextConsumer = !1,
            unmaskedContext = emptyContextObject,
            context = emptyContextObject,
            contextType = ctor.contextType;
          if (
            'contextType' in ctor &&
            !(
              null === contextType ||
              (void 0 !== contextType && contextType.$$typeof === REACT_CONTEXT_TYPE && void 0 === contextType._context)
            ) &&
            !didWarnAboutInvalidateContextType.has(ctor)
          ) {
            didWarnAboutInvalidateContextType.add(ctor);
            var addendum = '';
            (addendum =
              void 0 === contextType
                ? ' However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.'
                : 'object' != typeof contextType
                ? ' However, it is set to a ' + typeof contextType + '.'
                : contextType.$$typeof === REACT_PROVIDER_TYPE
                ? ' Did you accidentally pass the Context.Provider instead?'
                : void 0 !== contextType._context
                ? ' Did you accidentally pass the Context.Consumer instead?'
                : ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.'),
              error(
                '%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s',
                getComponentName(ctor) || 'Component',
                addendum
              );
          }
          if ('object' == typeof contextType && null !== contextType) context = readContext(contextType);
          else {
            unmaskedContext = getUnmaskedContext(0, ctor, !0);
            var contextTypes = ctor.contextTypes;
            context = (isLegacyContextConsumer = null != contextTypes)
              ? getMaskedContext(workInProgress, unmaskedContext)
              : emptyContextObject;
          }
          1 & workInProgress.mode && new ctor(props, context);
          var instance = new ctor(props, context),
            state = (workInProgress.memoizedState =
              null !== instance.state && void 0 !== instance.state ? instance.state : null);
          if (
            (adoptClassInstance(workInProgress, instance),
            'function' == typeof ctor.getDerivedStateFromProps && null === state)
          ) {
            var componentName = getComponentName(ctor) || 'Component';
            didWarnAboutUninitializedState.has(componentName) ||
              (didWarnAboutUninitializedState.add(componentName),
              error(
                '`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',
                componentName,
                null === instance.state ? 'null' : 'undefined',
                componentName
              ));
          }
          if (
            'function' == typeof ctor.getDerivedStateFromProps ||
            'function' == typeof instance.getSnapshotBeforeUpdate
          ) {
            var foundWillMountName = null,
              foundWillReceivePropsName = null,
              foundWillUpdateName = null;
            if (
              ('function' == typeof instance.componentWillMount &&
              !0 !== instance.componentWillMount.__suppressDeprecationWarning
                ? (foundWillMountName = 'componentWillMount')
                : 'function' == typeof instance.UNSAFE_componentWillMount &&
                  (foundWillMountName = 'UNSAFE_componentWillMount'),
              'function' == typeof instance.componentWillReceiveProps &&
              !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning
                ? (foundWillReceivePropsName = 'componentWillReceiveProps')
                : 'function' == typeof instance.UNSAFE_componentWillReceiveProps &&
                  (foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps'),
              'function' == typeof instance.componentWillUpdate &&
              !0 !== instance.componentWillUpdate.__suppressDeprecationWarning
                ? (foundWillUpdateName = 'componentWillUpdate')
                : 'function' == typeof instance.UNSAFE_componentWillUpdate &&
                  (foundWillUpdateName = 'UNSAFE_componentWillUpdate'),
              null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName)
            ) {
              var _componentName = getComponentName(ctor) || 'Component',
                newApiName =
                  'function' == typeof ctor.getDerivedStateFromProps
                    ? 'getDerivedStateFromProps()'
                    : 'getSnapshotBeforeUpdate()';
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) ||
                (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName),
                error(
                  'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-unsafe-component-lifecycles',
                  _componentName,
                  newApiName,
                  null !== foundWillMountName ? '\n  ' + foundWillMountName : '',
                  null !== foundWillReceivePropsName ? '\n  ' + foundWillReceivePropsName : '',
                  null !== foundWillUpdateName ? '\n  ' + foundWillUpdateName : ''
                ));
            }
          }
          return isLegacyContextConsumer && cacheContext(workInProgress, unmaskedContext, context), instance;
        }
        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
          var oldState = instance.state;
          if (
            (startPhaseTimer(workInProgress, 'componentWillReceiveProps'),
            'function' == typeof instance.componentWillReceiveProps &&
              instance.componentWillReceiveProps(newProps, nextContext),
            'function' == typeof instance.UNSAFE_componentWillReceiveProps &&
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext),
            stopPhaseTimer(),
            instance.state !== oldState)
          ) {
            var componentName = getComponentName(workInProgress.type) || 'Component';
            didWarnAboutStateAssignmentForComponent.has(componentName) ||
              (didWarnAboutStateAssignmentForComponent.add(componentName),
              error(
                "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                componentName
              )),
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
          !(function checkClassInstance(workInProgress, ctor, newProps) {
            var instance = workInProgress.stateNode,
              name = getComponentName(ctor) || 'Component';
            instance.render ||
              (ctor.prototype && 'function' == typeof ctor.prototype.render
                ? error(
                    '%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?',
                    name
                  )
                : error(
                    '%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.',
                    name
                  )),
              !instance.getInitialState ||
                instance.getInitialState.isReactClassApproved ||
                instance.state ||
                error(
                  'getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?',
                  name
                ),
              instance.getDefaultProps &&
                !instance.getDefaultProps.isReactClassApproved &&
                error(
                  'getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.',
                  name
                ),
              instance.propTypes &&
                error(
                  'propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.',
                  name
                ),
              instance.contextType &&
                error(
                  'contextType was defined as an instance property on %s. Use a static property to define contextType instead.',
                  name
                ),
              instance.contextTypes &&
                error(
                  'contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.',
                  name
                ),
              ctor.contextType &&
                ctor.contextTypes &&
                !didWarnAboutContextTypeAndContextTypes.has(ctor) &&
                (didWarnAboutContextTypeAndContextTypes.add(ctor),
                error(
                  '%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.',
                  name
                )),
              'function' == typeof instance.componentShouldUpdate &&
                error(
                  '%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.',
                  name
                ),
              ctor.prototype &&
                ctor.prototype.isPureReactComponent &&
                void 0 !== instance.shouldComponentUpdate &&
                error(
                  '%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.',
                  getComponentName(ctor) || 'A pure component'
                ),
              'function' == typeof instance.componentDidUnmount &&
                error(
                  '%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?',
                  name
                ),
              'function' == typeof instance.componentDidReceiveProps &&
                error(
                  '%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
                  name
                ),
              'function' == typeof instance.componentWillRecieveProps &&
                error(
                  '%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
                  name
                ),
              'function' == typeof instance.UNSAFE_componentWillRecieveProps &&
                error(
                  '%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',
                  name
                );
            var hasMutatedProps = instance.props !== newProps;
            void 0 !== instance.props &&
              hasMutatedProps &&
              error(
                "%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
                name,
                name
              ),
              instance.defaultProps &&
                error(
                  'Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.',
                  name,
                  name
                ),
              'function' != typeof instance.getSnapshotBeforeUpdate ||
                'function' == typeof instance.componentDidUpdate ||
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) ||
                (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor),
                error(
                  '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.',
                  getComponentName(ctor)
                )),
              'function' == typeof instance.getDerivedStateFromProps &&
                error(
                  '%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
                  name
                ),
              'function' == typeof instance.getDerivedStateFromError &&
                error(
                  '%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.',
                  name
                ),
              'function' == typeof ctor.getSnapshotBeforeUpdate &&
                error(
                  '%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.',
                  name
                );
            var _state = instance.state;
            _state &&
              ('object' != typeof _state || isArray(_state)) &&
              error('%s.state: must be set to an object or null', name),
              'function' == typeof instance.getChildContext &&
                'object' != typeof ctor.childContextTypes &&
                error(
                  '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',
                  name
                );
          })(workInProgress, ctor, newProps);
          var instance = workInProgress.stateNode;
          (instance.props = newProps),
            (instance.state = workInProgress.memoizedState),
            (instance.refs = emptyRefsObject),
            initializeUpdateQueue(workInProgress);
          var contextType = ctor.contextType;
          if ('object' == typeof contextType && null !== contextType) instance.context = readContext(contextType);
          else {
            var unmaskedContext = getUnmaskedContext(0, ctor, !0);
            instance.context = getMaskedContext(workInProgress, unmaskedContext);
          }
          if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || 'Component';
            didWarnAboutDirectlyAssigningPropsToState.has(componentName) ||
              (didWarnAboutDirectlyAssigningPropsToState.add(componentName),
              error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                componentName
              ));
          }
          1 & workInProgress.mode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance),
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance),
            processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime),
            (instance.state = workInProgress.memoizedState);
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          'function' == typeof getDerivedStateFromProps &&
            (applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps),
            (instance.state = workInProgress.memoizedState)),
            'function' == typeof ctor.getDerivedStateFromProps ||
              'function' == typeof instance.getSnapshotBeforeUpdate ||
              ('function' != typeof instance.UNSAFE_componentWillMount &&
                'function' != typeof instance.componentWillMount) ||
              (!(function callComponentWillMount(workInProgress, instance) {
                startPhaseTimer(workInProgress, 'componentWillMount');
                var oldState = instance.state;
                'function' == typeof instance.componentWillMount && instance.componentWillMount(),
                  'function' == typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount(),
                  stopPhaseTimer(),
                  oldState !== instance.state &&
                    (error(
                      "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                      getComponentName(workInProgress.type) || 'Component'
                    ),
                    classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
              })(workInProgress, instance),
              processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime),
              (instance.state = workInProgress.memoizedState)),
            'function' == typeof instance.componentDidMount && (workInProgress.effectTag |= 4);
        }
        var warnForMissingKey;
        (didWarnAboutMaps = !1),
          (didWarnAboutGenerators = !1),
          (didWarnAboutStringRefs = {}),
          (ownerHasKeyUseWarning = {}),
          (ownerHasFunctionTypeWarning = {}),
          (warnForMissingKey = function (child) {
            if (
              null !== child &&
              'object' == typeof child &&
              child._store &&
              !child._store.validated &&
              null == child.key
            ) {
              if ('object' != typeof child._store)
                throw Error(
                  'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'
                );
              child._store.validated = !0;
              var currentComponentErrorInfo =
                'Each child in a list should have a unique "key" prop. See https://fb.me/react-warning-keys for more information.' +
                getCurrentFiberStackInDev();
              ownerHasKeyUseWarning[currentComponentErrorInfo] ||
                ((ownerHasKeyUseWarning[currentComponentErrorInfo] = !0),
                error(
                  'Each child in a list should have a unique "key" prop. See https://fb.me/react-warning-keys for more information.'
                ));
            }
          });
        var isArray$1 = Array.isArray;
        function coerceRef(returnFiber, current, element) {
          var mixedRef = element.ref;
          if (null !== mixedRef && 'function' != typeof mixedRef && 'object' != typeof mixedRef) {
            if (
              1 & returnFiber.mode &&
              (!element._owner || !element._self || element._owner.stateNode === element._self)
            ) {
              var componentName = getComponentName(returnFiber.type) || 'Component';
              didWarnAboutStringRefs[componentName] ||
                (error(
                  'A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref%s',
                  mixedRef,
                  getStackByFiberInDevAndProd(returnFiber)
                ),
                (didWarnAboutStringRefs[componentName] = !0));
            }
            if (element._owner) {
              var inst,
                owner = element._owner;
              if (owner) {
                var ownerFiber = owner;
                if (1 !== ownerFiber.tag)
                  throw Error(
                    'Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref'
                  );
                inst = ownerFiber.stateNode;
              }
              if (!inst)
                throw Error(
                  'Missing owner for string ref ' +
                    mixedRef +
                    '. This error is likely caused by a bug in React. Please file an issue.'
                );
              var stringRef = '' + mixedRef;
              if (
                null !== current &&
                null !== current.ref &&
                'function' == typeof current.ref &&
                current.ref._stringRef === stringRef
              )
                return current.ref;
              var ref = function (value) {
                var refs = inst.refs;
                refs === emptyRefsObject && (refs = inst.refs = {}),
                  null === value ? delete refs[stringRef] : (refs[stringRef] = value);
              };
              return (ref._stringRef = stringRef), ref;
            }
            if ('string' != typeof mixedRef)
              throw Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');
            if (!element._owner)
              throw Error(
                'Element ref was specified as a string (' +
                  mixedRef +
                  ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information."
              );
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          if ('textarea' !== returnFiber.type) {
            var addendum;
            throw (
              ((addendum =
                ' If you meant to render a collection of children, use an array instead.' +
                getCurrentFiberStackInDev()),
              Error(
                'Objects are not valid as a React child (found: ' +
                  ('[object Object]' === Object.prototype.toString.call(newChild)
                    ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'
                    : newChild) +
                  ').' +
                  addendum
              ))
            );
          }
        }
        function warnOnFunctionType() {
          var currentComponentErrorInfo =
            'Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.' +
            getCurrentFiberStackInDev();
          ownerHasFunctionTypeWarning[currentComponentErrorInfo] ||
            ((ownerHasFunctionTypeWarning[currentComponentErrorInfo] = !0),
            error(
              'Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.'
            ));
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var last = returnFiber.lastEffect;
              null !== last
                ? ((last.nextEffect = childToDelete), (returnFiber.lastEffect = childToDelete))
                : (returnFiber.firstEffect = returnFiber.lastEffect = childToDelete),
                (childToDelete.nextEffect = null),
                (childToDelete.effectTag = 8);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (var childToDelete = currentFirstChild; null !== childToDelete; )
              deleteChild(returnFiber, childToDelete), (childToDelete = childToDelete.sibling);
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            for (var existingChildren = new Map(), existingChild = currentFirstChild; null !== existingChild; )
              null !== existingChild.key
                ? existingChildren.set(existingChild.key, existingChild)
                : existingChildren.set(existingChild.index, existingChild),
                (existingChild = existingChild.sibling);
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone = createWorkInProgress(fiber, pendingProps);
            return (clone.index = 0), (clone.sibling = null), clone;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            if (((newFiber.index = newIndex), !shouldTrackSideEffects)) return lastPlacedIndex;
            var current = newFiber.alternate;
            if (null !== current) {
              var oldIndex = current.index;
              return oldIndex < lastPlacedIndex ? ((newFiber.effectTag = 2), lastPlacedIndex) : oldIndex;
            }
            return (newFiber.effectTag = 2), lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            return shouldTrackSideEffects && null === newFiber.alternate && (newFiber.effectTag = 2), newFiber;
          }
          function updateTextNode(returnFiber, current, textContent, expirationTime) {
            if (null === current || 6 !== current.tag) {
              var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
              return (created.return = returnFiber), created;
            }
            var existing = useFiber(current, textContent);
            return (existing.return = returnFiber), existing;
          }
          function updateElement(returnFiber, current, element, expirationTime) {
            if (
              null !== current &&
              (current.elementType === element.type || isCompatibleFamilyForHotReloading(current, element))
            ) {
              var existing = useFiber(current, element.props);
              return (
                (existing.ref = coerceRef(returnFiber, current, element)),
                (existing.return = returnFiber),
                (existing._debugSource = element._source),
                (existing._debugOwner = element._owner),
                existing
              );
            }
            var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
            return (created.ref = coerceRef(returnFiber, current, element)), (created.return = returnFiber), created;
          }
          function updatePortal(returnFiber, current, portal, expirationTime) {
            if (
              null === current ||
              4 !== current.tag ||
              current.stateNode.containerInfo !== portal.containerInfo ||
              current.stateNode.implementation !== portal.implementation
            ) {
              var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
              return (created.return = returnFiber), created;
            }
            var existing = useFiber(current, portal.children || []);
            return (existing.return = returnFiber), existing;
          }
          function updateFragment(returnFiber, current, fragment, expirationTime, key) {
            if (null === current || 7 !== current.tag) {
              var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
              return (created.return = returnFiber), created;
            }
            var existing = useFiber(current, fragment);
            return (existing.return = returnFiber), existing;
          }
          function createChild(returnFiber, newChild, expirationTime) {
            if ('string' == typeof newChild || 'number' == typeof newChild) {
              var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);
              return (created.return = returnFiber), created;
            }
            if ('object' == typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);
                  return (
                    (_created.ref = coerceRef(returnFiber, null, newChild)), (_created.return = returnFiber), _created
                  );
                case REACT_PORTAL_TYPE:
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);
                  return (_created2.return = returnFiber), _created2;
              }
              if (isArray$1(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);
                return (_created3.return = returnFiber), _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            return 'function' == typeof newChild && warnOnFunctionType(), null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ('string' == typeof newChild || 'number' == typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
            if ('object' == typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key
                    ? newChild.type === REACT_FRAGMENT_TYPE
                      ? updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key)
                      : updateElement(returnFiber, oldFiber, newChild, expirationTime)
                    : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, expirationTime) : null;
              }
              if (isArray$1(newChild) || getIteratorFn(newChild))
                return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            return 'function' == typeof newChild && warnOnFunctionType(), null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
            if ('string' == typeof newChild || 'number' == typeof newChild)
              return updateTextNode(returnFiber, existingChildren.get(newIdx) || null, '' + newChild, expirationTime);
            if ('object' == typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var _matchedFiber = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null;
                  return newChild.type === REACT_FRAGMENT_TYPE
                    ? updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key)
                    : updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
                case REACT_PORTAL_TYPE:
                  return updatePortal(
                    returnFiber,
                    existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null,
                    newChild,
                    expirationTime
                  );
              }
              if (isArray$1(newChild) || getIteratorFn(newChild))
                return updateFragment(
                  returnFiber,
                  existingChildren.get(newIdx) || null,
                  newChild,
                  expirationTime,
                  null
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            return 'function' == typeof newChild && warnOnFunctionType(), null;
          }
          function warnOnInvalidKey(child, knownKeys) {
            if ('object' != typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child);
                var key = child.key;
                if ('string' != typeof key) break;
                if (null === knownKeys) {
                  (knownKeys = new Set()).add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                error(
                  'Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.',
                  key
                );
            }
            return knownKeys;
          }
          return function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
            var isUnkeyedTopLevelFragment =
              'object' == typeof newChild &&
              null !== newChild &&
              newChild.type === REACT_FRAGMENT_TYPE &&
              null === newChild.key;
            isUnkeyedTopLevelFragment && (newChild = newChild.props.children);
            var isObject = 'object' == typeof newChild && null !== newChild;
            if (isObject)
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(
                    (function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
                      for (var key = element.key, child = currentFirstChild; null !== child; ) {
                        if (child.key === key) {
                          switch (child.tag) {
                            case 7:
                              if (element.type === REACT_FRAGMENT_TYPE) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var existing = useFiber(child, element.props.children);
                                return (
                                  (existing.return = returnFiber),
                                  (existing._debugSource = element._source),
                                  (existing._debugOwner = element._owner),
                                  existing
                                );
                              }
                              break;
                            case 22:
                            default:
                              if (
                                child.elementType === element.type ||
                                isCompatibleFamilyForHotReloading(child, element)
                              ) {
                                deleteRemainingChildren(returnFiber, child.sibling);
                                var _existing3 = useFiber(child, element.props);
                                return (
                                  (_existing3.ref = coerceRef(returnFiber, child, element)),
                                  (_existing3.return = returnFiber),
                                  (_existing3._debugSource = element._source),
                                  (_existing3._debugOwner = element._owner),
                                  _existing3
                                );
                              }
                          }
                          deleteRemainingChildren(returnFiber, child);
                          break;
                        }
                        deleteChild(returnFiber, child), (child = child.sibling);
                      }
                      if (element.type === REACT_FRAGMENT_TYPE) {
                        var created = createFiberFromFragment(
                          element.props.children,
                          returnFiber.mode,
                          expirationTime,
                          element.key
                        );
                        return (created.return = returnFiber), created;
                      }
                      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);
                      return (
                        (_created4.ref = coerceRef(returnFiber, currentFirstChild, element)),
                        (_created4.return = returnFiber),
                        _created4
                      );
                    })(returnFiber, currentFirstChild, newChild, expirationTime)
                  );
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(
                    (function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
                      for (var key = portal.key, child = currentFirstChild; null !== child; ) {
                        if (child.key === key) {
                          if (
                            4 === child.tag &&
                            child.stateNode.containerInfo === portal.containerInfo &&
                            child.stateNode.implementation === portal.implementation
                          ) {
                            deleteRemainingChildren(returnFiber, child.sibling);
                            var existing = useFiber(child, portal.children || []);
                            return (existing.return = returnFiber), existing;
                          }
                          deleteRemainingChildren(returnFiber, child);
                          break;
                        }
                        deleteChild(returnFiber, child), (child = child.sibling);
                      }
                      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
                      return (created.return = returnFiber), created;
                    })(returnFiber, currentFirstChild, newChild, expirationTime)
                  );
              }
            if ('string' == typeof newChild || 'number' == typeof newChild)
              return placeSingleChild(
                (function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
                  if (null !== currentFirstChild && 6 === currentFirstChild.tag) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    var existing = useFiber(currentFirstChild, textContent);
                    return (existing.return = returnFiber), existing;
                  }
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
                  return (created.return = returnFiber), created;
                })(returnFiber, currentFirstChild, '' + newChild, expirationTime)
              );
            if (isArray$1(newChild))
              return (function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
                for (var knownKeys = null, i = 0; i < newChildren.length; i++) {
                  knownKeys = warnOnInvalidKey(newChildren[i], knownKeys);
                }
                for (
                  var resultingFirstChild = null,
                    previousNewFiber = null,
                    oldFiber = currentFirstChild,
                    lastPlacedIndex = 0,
                    newIdx = 0,
                    nextOldFiber = null;
                  null !== oldFiber && newIdx < newChildren.length;
                  newIdx++
                ) {
                  oldFiber.index > newIdx
                    ? ((nextOldFiber = oldFiber), (oldFiber = null))
                    : (nextOldFiber = oldFiber.sibling);
                  var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
                  if (null === newFiber) {
                    null === oldFiber && (oldFiber = nextOldFiber);
                    break;
                  }
                  shouldTrackSideEffects &&
                    oldFiber &&
                    null === newFiber.alternate &&
                    deleteChild(returnFiber, oldFiber),
                    (lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)),
                    null === previousNewFiber
                      ? (resultingFirstChild = newFiber)
                      : (previousNewFiber.sibling = newFiber),
                    (previousNewFiber = newFiber),
                    (oldFiber = nextOldFiber);
                }
                if (newIdx === newChildren.length)
                  return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;
                if (null === oldFiber) {
                  for (; newIdx < newChildren.length; newIdx++) {
                    var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
                    null !== _newFiber &&
                      ((lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx)),
                      null === previousNewFiber
                        ? (resultingFirstChild = _newFiber)
                        : (previousNewFiber.sibling = _newFiber),
                      (previousNewFiber = _newFiber));
                  }
                  return resultingFirstChild;
                }
                for (var existingChildren = mapRemainingChildren(0, oldFiber); newIdx < newChildren.length; newIdx++) {
                  var _newFiber2 = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChildren[newIdx],
                    expirationTime
                  );
                  null !== _newFiber2 &&
                    (shouldTrackSideEffects &&
                      null !== _newFiber2.alternate &&
                      existingChildren.delete(null === _newFiber2.key ? newIdx : _newFiber2.key),
                    (lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx)),
                    null === previousNewFiber
                      ? (resultingFirstChild = _newFiber2)
                      : (previousNewFiber.sibling = _newFiber2),
                    (previousNewFiber = _newFiber2));
                }
                return (
                  shouldTrackSideEffects &&
                    existingChildren.forEach(function (child) {
                      return deleteChild(returnFiber, child);
                    }),
                  resultingFirstChild
                );
              })(returnFiber, currentFirstChild, newChild, expirationTime);
            if (getIteratorFn(newChild))
              return (function reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChildrenIterable,
                expirationTime
              ) {
                var iteratorFn = getIteratorFn(newChildrenIterable);
                if ('function' != typeof iteratorFn)
                  throw Error(
                    'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'
                  );
                'function' == typeof Symbol &&
                  'Generator' === newChildrenIterable[Symbol.toStringTag] &&
                  (didWarnAboutGenerators ||
                    error(
                      'Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.'
                    ),
                  (didWarnAboutGenerators = !0)),
                  newChildrenIterable.entries === iteratorFn &&
                    (didWarnAboutMaps ||
                      error(
                        'Using Maps as children is unsupported and will likely yield unexpected results. Convert it to a sequence/iterable of keyed ReactElements instead.'
                      ),
                    (didWarnAboutMaps = !0));
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren)
                  for (var knownKeys = null, _step = _newChildren.next(); !_step.done; _step = _newChildren.next()) {
                    knownKeys = warnOnInvalidKey(_step.value, knownKeys);
                  }
                var newChildren = iteratorFn.call(newChildrenIterable);
                if (null == newChildren) throw Error('An iterable object provided no iterator.');
                for (
                  var resultingFirstChild = null,
                    previousNewFiber = null,
                    oldFiber = currentFirstChild,
                    lastPlacedIndex = 0,
                    newIdx = 0,
                    nextOldFiber = null,
                    step = newChildren.next();
                  null !== oldFiber && !step.done;
                  newIdx++, step = newChildren.next()
                ) {
                  oldFiber.index > newIdx
                    ? ((nextOldFiber = oldFiber), (oldFiber = null))
                    : (nextOldFiber = oldFiber.sibling);
                  var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
                  if (null === newFiber) {
                    null === oldFiber && (oldFiber = nextOldFiber);
                    break;
                  }
                  shouldTrackSideEffects &&
                    oldFiber &&
                    null === newFiber.alternate &&
                    deleteChild(returnFiber, oldFiber),
                    (lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)),
                    null === previousNewFiber
                      ? (resultingFirstChild = newFiber)
                      : (previousNewFiber.sibling = newFiber),
                    (previousNewFiber = newFiber),
                    (oldFiber = nextOldFiber);
                }
                if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;
                if (null === oldFiber) {
                  for (; !step.done; newIdx++, step = newChildren.next()) {
                    var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
                    null !== _newFiber3 &&
                      ((lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx)),
                      null === previousNewFiber
                        ? (resultingFirstChild = _newFiber3)
                        : (previousNewFiber.sibling = _newFiber3),
                      (previousNewFiber = _newFiber3));
                  }
                  return resultingFirstChild;
                }
                for (
                  var existingChildren = mapRemainingChildren(0, oldFiber);
                  !step.done;
                  newIdx++, step = newChildren.next()
                ) {
                  var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
                  null !== _newFiber4 &&
                    (shouldTrackSideEffects &&
                      null !== _newFiber4.alternate &&
                      existingChildren.delete(null === _newFiber4.key ? newIdx : _newFiber4.key),
                    (lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx)),
                    null === previousNewFiber
                      ? (resultingFirstChild = _newFiber4)
                      : (previousNewFiber.sibling = _newFiber4),
                    (previousNewFiber = _newFiber4));
                }
                return (
                  shouldTrackSideEffects &&
                    existingChildren.forEach(function (child) {
                      return deleteChild(returnFiber, child);
                    }),
                  resultingFirstChild
                );
              })(returnFiber, currentFirstChild, newChild, expirationTime);
            if (
              (isObject && throwOnInvalidObjectType(returnFiber, newChild),
              'function' == typeof newChild && warnOnFunctionType(),
              void 0 === newChild && !isUnkeyedTopLevelFragment)
            )
              switch (returnFiber.tag) {
                case 1:
                  if (returnFiber.stateNode.render._isMockFunction) break;
                case 0:
                  var Component = returnFiber.type;
                  throw Error(
                    (Component.displayName || Component.name || 'Component') +
                      '(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.'
                  );
              }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          };
        }
        var reconcileChildFibers = ChildReconciler(!0),
          mountChildFibers = ChildReconciler(!1);
        function resetChildFibers(workInProgress, renderExpirationTime) {
          for (var child = workInProgress.child; null !== child; )
            resetWorkInProgress(child, renderExpirationTime), (child = child.sibling);
        }
        var NO_CONTEXT = {},
          contextStackCursor$1 = createCursor(NO_CONTEXT),
          contextFiberStackCursor = createCursor(NO_CONTEXT),
          rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c) {
          if (c === NO_CONTEXT)
            throw Error(
              'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'
            );
          return c;
        }
        function getRootHostContainer() {
          return requiredContext(rootInstanceStackCursor.current);
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber),
            push(contextFiberStackCursor, fiber, fiber),
            push(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = (function getRootHostContext(rootContainerInstance) {
            var type,
              namespace,
              nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case 9:
              case 11:
                type = 9 === nodeType ? '#document' : '#fragment';
                var root = rootContainerInstance.documentElement;
                namespace = root ? root.namespaceURI : getChildNamespace(null, '');
                break;
              default:
                var container = 8 === nodeType ? rootContainerInstance.parentNode : rootContainerInstance;
                namespace = getChildNamespace(container.namespaceURI || null, (type = container.tagName));
            }
            var validatedTag = type.toLowerCase();
            return { namespace, ancestorInfo: updatedAncestorInfo(null, validatedTag) };
          })(nextRootInstance);
          pop(contextStackCursor$1, fiber), push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber), pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor$1.current);
        }
        function pushHostContext(fiber) {
          requiredContext(rootInstanceStackCursor.current);
          var context = requiredContext(contextStackCursor$1.current),
            nextContext = (function getChildHostContext(parentHostContext, type, rootContainerInstance) {
              var parentHostContextDev = parentHostContext;
              return {
                namespace: getChildNamespace(parentHostContextDev.namespace, type),
                ancestorInfo: updatedAncestorInfo(parentHostContextDev.ancestorInfo, type),
              };
            })(context, fiber.type);
          context !== nextContext &&
            (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber &&
            (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
        }
        var suspenseStackCursor = createCursor(0);
        function hasSuspenseContext(parentContext, flag) {
          return 0 != (parentContext & flag);
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return 1 & parentContext;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return (1 & parentContext) | shallowContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
          var nextState = workInProgress.memoizedState;
          if (null !== nextState) return null !== nextState.dehydrated;
          var props = workInProgress.memoizedProps;
          return void 0 !== props.fallback && (!0 !== props.unstable_avoidThisFallback || !hasInvisibleParent);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state) {
                var dehydrated = state.dehydrated;
                if (null === dehydrated || '$?' === dehydrated.data || isSuspenseInstanceFallback(dehydrated))
                  return node;
              }
            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
              if (0 != (64 & node.effectTag)) return node;
            } else if (null !== node.child) {
              (node.child.return = node), (node = node.child);
              continue;
            }
            if (node === row) return null;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            (node.sibling.return = node.return), (node = node.sibling);
          }
          return null;
        }
        function createDeprecatedResponderListener(responder, props) {
          var eventResponderListener = { responder, props };
          return Object.freeze(eventResponderListener), eventResponderListener;
        }
        var didWarnAboutMismatchedHooksForComponent,
          ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
          ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        didWarnAboutMismatchedHooksForComponent = new Set();
        var renderExpirationTime = 0,
          currentlyRenderingFiber$1 = null,
          currentHook = null,
          workInProgressHook = null,
          didScheduleRenderPhaseUpdate = !1,
          currentHookNameInDev = null,
          hookTypesDev = null,
          hookTypesUpdateIndexDev = -1,
          ignorePreviousDependencies = !1;
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? (hookTypesDev = [hookName]) : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          null !== hookTypesDev &&
            (hookTypesUpdateIndexDev++,
            hookTypesDev[hookTypesUpdateIndexDev] !== hookName &&
              (function warnOnHookMismatchInDev(currentHookName) {
                var componentName = getComponentName(currentlyRenderingFiber$1.type);
                if (
                  !didWarnAboutMismatchedHooksForComponent.has(componentName) &&
                  (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)
                ) {
                  for (var table = '', i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    for (
                      var oldHookName = hookTypesDev[i],
                        newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName,
                        row = i + 1 + '. ' + oldHookName;
                      row.length < 30;

                    )
                      row += ' ';
                    table += row += newHookName + '\n';
                  }
                  error(
                    'React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',
                    componentName,
                    table
                  );
                }
              })(hookName));
        }
        function checkDepsAreArrayDev(deps) {
          null == deps ||
            Array.isArray(deps) ||
            error(
              '%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.',
              currentHookNameInDev,
              typeof deps
            );
        }
        function throwInvalidHookError() {
          throw Error(
            'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.'
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return !1;
          if (null === prevDeps)
            return (
              error(
                '%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.',
                currentHookNameInDev
              ),
              !1
            );
          nextDeps.length !== prevDeps.length &&
            error(
              'The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s',
              currentHookNameInDev,
              '[' + prevDeps.join(', ') + ']',
              '[' + nextDeps.join(', ') + ']'
            );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
          return !0;
        }
        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderExpirationTime) {
          (renderExpirationTime = nextRenderExpirationTime),
            (currentlyRenderingFiber$1 = workInProgress),
            (hookTypesDev = null !== current ? current._debugHookTypes : null),
            (hookTypesUpdateIndexDev = -1),
            (ignorePreviousDependencies = null !== current && current.type !== workInProgress.type),
            (workInProgress.memoizedState = null),
            (workInProgress.updateQueue = null),
            (workInProgress.expirationTime = 0),
            null !== current && null !== current.memoizedState
              ? (ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV)
              : (ReactCurrentDispatcher.current =
                  null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV);
          var children = Component(props, secondArg);
          if (workInProgress.expirationTime === renderExpirationTime) {
            var numberOfReRenders = 0;
            do {
              if (((workInProgress.expirationTime = 0), !(numberOfReRenders < 25)))
                throw Error('Too many re-renders. React limits the number of renders to prevent an infinite loop.');
              (numberOfReRenders += 1),
                (ignorePreviousDependencies = !1),
                (currentHook = null),
                (workInProgressHook = null),
                (workInProgress.updateQueue = null),
                (hookTypesUpdateIndexDev = -1),
                (ReactCurrentDispatcher.current = HooksDispatcherOnRerenderInDEV),
                (children = Component(props, secondArg));
            } while (workInProgress.expirationTime === renderExpirationTime);
          }
          (ReactCurrentDispatcher.current = ContextOnlyDispatcher), (workInProgress._debugHookTypes = hookTypesDev);
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          if (
            ((renderExpirationTime = 0),
            (currentlyRenderingFiber$1 = null),
            (currentHook = null),
            (workInProgressHook = null),
            (currentHookNameInDev = null),
            (hookTypesDev = null),
            (hookTypesUpdateIndexDev = -1),
            (didScheduleRenderPhaseUpdate = !1),
            didRenderTooFewHooks)
          )
            throw Error(
              'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'
            );
          return children;
        }
        function bailoutHooks(current, workInProgress, expirationTime) {
          (workInProgress.updateQueue = current.updateQueue),
            (workInProgress.effectTag &= -517),
            current.expirationTime <= expirationTime && (current.expirationTime = 0);
        }
        function resetHooksAfterThrow() {
          if (((ReactCurrentDispatcher.current = ContextOnlyDispatcher), didScheduleRenderPhaseUpdate))
            for (var hook = currentlyRenderingFiber$1.memoizedState; null !== hook; ) {
              var queue = hook.queue;
              null !== queue && (queue.pending = null), (hook = hook.next);
            }
          (renderExpirationTime = 0),
            (currentlyRenderingFiber$1 = null),
            (currentHook = null),
            (workInProgressHook = null),
            (hookTypesDev = null),
            (hookTypesUpdateIndexDev = -1),
            (currentHookNameInDev = null),
            (didScheduleRenderPhaseUpdate = !1);
        }
        function mountWorkInProgressHook() {
          var hook = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
          return (
            null === workInProgressHook
              ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)
              : (workInProgressHook = workInProgressHook.next = hook),
            workInProgressHook
          );
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook, nextWorkInProgressHook;
          if (null === currentHook) {
            var current = currentlyRenderingFiber$1.alternate;
            nextCurrentHook = null !== current ? current.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          if (
            null !==
            (nextWorkInProgressHook =
              null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next)
          )
            (nextWorkInProgressHook = (workInProgressHook = nextWorkInProgressHook).next),
              (currentHook = nextCurrentHook);
          else {
            if (null === nextCurrentHook) throw Error('Rendered more hooks than during the previous render.');
            var newHook = {
              memoizedState: (currentHook = nextCurrentHook).memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null,
            };
            null === workInProgressHook
              ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook)
              : (workInProgressHook = workInProgressHook.next = newHook);
          }
          return workInProgressHook;
        }
        function basicStateReducer(state, action) {
          return 'function' == typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var initialState,
            hook = mountWorkInProgressHook();
          (initialState = void 0 !== init ? init(initialArg) : initialArg),
            (hook.memoizedState = hook.baseState = initialState);
          var queue = (hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState,
            }),
            dispatch = (queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue));
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook(),
            queue = hook.queue;
          if (null === queue) throw Error('Should have a queue. This is likely a bug in React. Please file an issue.');
          queue.lastRenderedReducer = reducer;
          var current = currentHook,
            baseQueue = current.baseQueue,
            pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next,
                pendingFirst = pendingQueue.next;
              (baseQueue.next = pendingFirst), (pendingQueue.next = baseFirst);
            }
            (current.baseQueue = baseQueue = pendingQueue), (queue.pending = null);
          }
          if (null !== baseQueue) {
            var first = baseQueue.next,
              newState = current.baseState,
              newBaseState = null,
              newBaseQueueFirst = null,
              newBaseQueueLast = null,
              update = first;
            do {
              var updateExpirationTime = update.expirationTime;
              if (updateExpirationTime < renderExpirationTime) {
                var clone = {
                  expirationTime: update.expirationTime,
                  suspenseConfig: update.suspenseConfig,
                  action: update.action,
                  eagerReducer: update.eagerReducer,
                  eagerState: update.eagerState,
                  next: null,
                };
                null === newBaseQueueLast
                  ? ((newBaseQueueFirst = newBaseQueueLast = clone), (newBaseState = newState))
                  : (newBaseQueueLast = newBaseQueueLast.next = clone),
                  updateExpirationTime > currentlyRenderingFiber$1.expirationTime &&
                    ((currentlyRenderingFiber$1.expirationTime = updateExpirationTime),
                    markUnprocessedUpdateTime(updateExpirationTime));
              } else {
                if (null !== newBaseQueueLast) {
                  var _clone = {
                    expirationTime: Sync,
                    suspenseConfig: update.suspenseConfig,
                    action: update.action,
                    eagerReducer: update.eagerReducer,
                    eagerState: update.eagerState,
                    next: null,
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (
                  (markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig),
                  update.eagerReducer === reducer)
                )
                  newState = update.eagerState;
                else newState = reducer(newState, update.action);
              }
              update = update.next;
            } while (null !== update && update !== first);
            null === newBaseQueueLast ? (newBaseState = newState) : (newBaseQueueLast.next = newBaseQueueFirst),
              objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(),
              (hook.memoizedState = newState),
              (hook.baseState = newBaseState),
              (hook.baseQueue = newBaseQueueLast),
              (queue.lastRenderedState = newState);
          }
          var dispatch = queue.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook(),
            queue = hook.queue;
          if (null === queue) throw Error('Should have a queue. This is likely a bug in React. Please file an issue.');
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch,
            lastRenderPhaseUpdate = queue.pending,
            newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next,
              update = firstRenderPhaseUpdate;
            do {
              (newState = reducer(newState, update.action)), (update = update.next);
            } while (update !== firstRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(),
              (hook.memoizedState = newState),
              null === hook.baseQueue && (hook.baseState = newState),
              (queue.lastRenderedState = newState);
          }
          return [newState, dispatch];
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          'function' == typeof initialState && (initialState = initialState()),
            (hook.memoizedState = hook.baseState = initialState);
          var queue = (hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState,
            }),
            dispatch = (queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue));
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create, destroy, deps) {
          var effect = { tag, create, destroy, deps, next: null },
            componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (null === componentUpdateQueue)
            (componentUpdateQueue = { lastEffect: null }),
              (currentlyRenderingFiber$1.updateQueue = componentUpdateQueue),
              (componentUpdateQueue.lastEffect = effect.next = effect);
          else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (null === lastEffect) componentUpdateQueue.lastEffect = effect.next = effect;
            else {
              var firstEffect = lastEffect.next;
              (lastEffect.next = effect), (effect.next = firstEffect), (componentUpdateQueue.lastEffect = effect);
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook(),
            ref = { current: initialValue };
          return Object.seal(ref), (hook.memoizedState = ref), ref;
        }
        function updateRef(initialValue) {
          return updateWorkInProgressHook().memoizedState;
        }
        function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
          var hook = mountWorkInProgressHook(),
            nextDeps = void 0 === deps ? null : deps;
          (currentlyRenderingFiber$1.effectTag |= fiberEffectTag),
            (hook.memoizedState = pushEffect(1 | hookEffectTag, create, void 0, nextDeps));
        }
        function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
          var hook = updateWorkInProgressHook(),
            nextDeps = void 0 === deps ? null : deps,
            destroy = void 0;
          if (null !== currentHook) {
            var prevEffect = currentHook.memoizedState;
            if (((destroy = prevEffect.destroy), null !== nextDeps))
              if (areHookInputsEqual(nextDeps, prevEffect.deps))
                return void pushEffect(hookEffectTag, create, destroy, nextDeps);
          }
          (currentlyRenderingFiber$1.effectTag |= fiberEffectTag),
            (hook.memoizedState = pushEffect(1 | hookEffectTag, create, destroy, nextDeps));
        }
        function mountEffect(create, deps) {
          return (
            'undefined' != typeof jest && warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1),
            mountEffectImpl(516, 4, create, deps)
          );
        }
        function updateEffect(create, deps) {
          return (
            'undefined' != typeof jest && warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1),
            updateEffectImpl(516, 4, create, deps)
          );
        }
        function mountLayoutEffect(create, deps) {
          return mountEffectImpl(4, 2, create, deps);
        }
        function updateLayoutEffect(create, deps) {
          return updateEffectImpl(4, 2, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ('function' == typeof ref) {
            var refCallback = ref,
              _inst = create();
            return (
              refCallback(_inst),
              function () {
                refCallback(null);
              }
            );
          }
          if (null != ref) {
            var refObject = ref;
            refObject.hasOwnProperty('current') ||
              error(
                'Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.',
                'an object with keys {' + Object.keys(refObject).join(', ') + '}'
              );
            var _inst2 = create();
            return (
              (refObject.current = _inst2),
              function () {
                refObject.current = null;
              }
            );
          }
        }
        function mountImperativeHandle(ref, create, deps) {
          'function' != typeof create &&
            error(
              'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
              null !== create ? typeof create : 'null'
            );
          var effectDeps = null != deps ? deps.concat([ref]) : null;
          return mountEffectImpl(4, 2, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create, deps) {
          'function' != typeof create &&
            error(
              'Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.',
              null !== create ? typeof create : 'null'
            );
          var effectDeps = null != deps ? deps.concat([ref]) : null;
          return updateEffectImpl(4, 2, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {}
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var nextDeps = void 0 === deps ? null : deps;
          return (mountWorkInProgressHook().memoizedState = [callback, nextDeps]), callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook(),
            nextDeps = void 0 === deps ? null : deps,
            prevState = hook.memoizedState;
          if (null !== prevState && null !== nextDeps && areHookInputsEqual(nextDeps, prevState[1]))
            return prevState[0];
          return (hook.memoizedState = [callback, nextDeps]), callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook(),
            nextDeps = void 0 === deps ? null : deps,
            nextValue = nextCreate();
          return (hook.memoizedState = [nextValue, nextDeps]), nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook(),
            nextDeps = void 0 === deps ? null : deps,
            prevState = hook.memoizedState;
          if (null !== prevState && null !== nextDeps && areHookInputsEqual(nextDeps, prevState[1]))
            return prevState[0];
          var nextValue = nextCreate();
          return (hook.memoizedState = [nextValue, nextDeps]), nextValue;
        }
        function mountDeferredValue(value, config) {
          var _mountState = mountState(value),
            prevValue = _mountState[0],
            setValue = _mountState[1];
          return (
            mountEffect(
              function () {
                var previousConfig = ReactCurrentBatchConfig$1.suspense;
                ReactCurrentBatchConfig$1.suspense = void 0 === config ? null : config;
                try {
                  setValue(value);
                } finally {
                  ReactCurrentBatchConfig$1.suspense = previousConfig;
                }
              },
              [value, config]
            ),
            prevValue
          );
        }
        function updateDeferredValue(value, config) {
          var _updateState = updateState(),
            prevValue = _updateState[0],
            setValue = _updateState[1];
          return (
            updateEffect(
              function () {
                var previousConfig = ReactCurrentBatchConfig$1.suspense;
                ReactCurrentBatchConfig$1.suspense = void 0 === config ? null : config;
                try {
                  setValue(value);
                } finally {
                  ReactCurrentBatchConfig$1.suspense = previousConfig;
                }
              },
              [value, config]
            ),
            prevValue
          );
        }
        function rerenderDeferredValue(value, config) {
          var _rerenderState = rerenderState(),
            prevValue = _rerenderState[0],
            setValue = _rerenderState[1];
          return (
            updateEffect(
              function () {
                var previousConfig = ReactCurrentBatchConfig$1.suspense;
                ReactCurrentBatchConfig$1.suspense = void 0 === config ? null : config;
                try {
                  setValue(value);
                } finally {
                  ReactCurrentBatchConfig$1.suspense = previousConfig;
                }
              },
              [value, config]
            ),
            prevValue
          );
        }
        function startTransition(setPending, config, callback) {
          var priorityLevel = getCurrentPriorityLevel();
          runWithPriority$1(priorityLevel < 98 ? 98 : priorityLevel, function () {
            setPending(!0);
          }),
            runWithPriority$1(priorityLevel > 97 ? 97 : priorityLevel, function () {
              var previousConfig = ReactCurrentBatchConfig$1.suspense;
              ReactCurrentBatchConfig$1.suspense = void 0 === config ? null : config;
              try {
                setPending(!1), callback();
              } finally {
                ReactCurrentBatchConfig$1.suspense = previousConfig;
              }
            });
        }
        function mountTransition(config) {
          var _mountState2 = mountState(!1),
            isPending = _mountState2[0],
            setPending = _mountState2[1];
          return [mountCallback(startTransition.bind(null, setPending, config), [setPending, config]), isPending];
        }
        function updateTransition(config) {
          var _updateState2 = updateState(),
            isPending = _updateState2[0],
            setPending = _updateState2[1];
          return [updateCallback(startTransition.bind(null, setPending, config), [setPending, config]), isPending];
        }
        function rerenderTransition(config) {
          var _rerenderState2 = rerenderState(),
            isPending = _rerenderState2[0],
            setPending = _rerenderState2[1];
          return [updateCallback(startTransition.bind(null, setPending, config), [setPending, config]), isPending];
        }
        function dispatchAction(fiber, queue, action) {
          'function' == typeof arguments[3] &&
            error(
              "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
            );
          var currentTime = requestCurrentTimeForUpdate(),
            suspenseConfig = requestCurrentSuspenseConfig(),
            expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig),
            update = { expirationTime, suspenseConfig, action, eagerReducer: null, eagerState: null, next: null };
          update.priority = getCurrentPriorityLevel();
          var pending = queue.pending;
          null === pending ? (update.next = update) : ((update.next = pending.next), (pending.next = update)),
            (queue.pending = update);
          var alternate = fiber.alternate;
          if (fiber === currentlyRenderingFiber$1 || (null !== alternate && alternate === currentlyRenderingFiber$1))
            (didScheduleRenderPhaseUpdate = !0),
              (update.expirationTime = renderExpirationTime),
              (currentlyRenderingFiber$1.expirationTime = renderExpirationTime);
          else {
            if (0 === fiber.expirationTime && (null === alternate || 0 === alternate.expirationTime)) {
              var lastRenderedReducer = queue.lastRenderedReducer;
              if (null !== lastRenderedReducer) {
                var prevDispatcher;
                (prevDispatcher = ReactCurrentDispatcher.current),
                  (ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV);
                try {
                  var currentState = queue.lastRenderedState,
                    eagerState = lastRenderedReducer(currentState, action);
                  if (
                    ((update.eagerReducer = lastRenderedReducer),
                    (update.eagerState = eagerState),
                    objectIs(eagerState, currentState))
                  )
                    return;
                } catch (error) {
                } finally {
                  ReactCurrentDispatcher.current = prevDispatcher;
                }
              }
            }
            'undefined' != typeof jest &&
              (warnIfNotScopedWithMatchingAct(fiber), warnIfNotCurrentlyActingUpdatesInDev(fiber)),
              scheduleWork(fiber, expirationTime);
          }
        }
        var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useResponder: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
          },
          HooksDispatcherOnMountInDEV = null,
          HooksDispatcherOnMountWithHookTypesInDEV = null,
          HooksDispatcherOnUpdateInDEV = null,
          HooksDispatcherOnRerenderInDEV = null,
          InvalidNestedHooksDispatcherOnMountInDEV = null,
          InvalidNestedHooksDispatcherOnUpdateInDEV = null,
          InvalidNestedHooksDispatcherOnRerenderInDEV = null,
          warnInvalidContextAccess = function () {
            error(
              'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'
            );
          },
          warnInvalidHookAccess = function () {
            error(
              'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://fb.me/rules-of-hooks'
            );
          };
        (HooksDispatcherOnMountInDEV = {
          readContext: function (context, observedBits) {
            return readContext(context, observedBits);
          },
          useCallback: function (callback, deps) {
            return (
              (currentHookNameInDev = 'useCallback'),
              mountHookTypesDev(),
              checkDepsAreArrayDev(deps),
              mountCallback(callback, deps)
            );
          },
          useContext: function (context, observedBits) {
            return (currentHookNameInDev = 'useContext'), mountHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function (create, deps) {
            return (
              (currentHookNameInDev = 'useEffect'),
              mountHookTypesDev(),
              checkDepsAreArrayDev(deps),
              mountEffect(create, deps)
            );
          },
          useImperativeHandle: function (ref, create, deps) {
            return (
              (currentHookNameInDev = 'useImperativeHandle'),
              mountHookTypesDev(),
              checkDepsAreArrayDev(deps),
              mountImperativeHandle(ref, create, deps)
            );
          },
          useLayoutEffect: function (create, deps) {
            return (
              (currentHookNameInDev = 'useLayoutEffect'),
              mountHookTypesDev(),
              checkDepsAreArrayDev(deps),
              mountLayoutEffect(create, deps)
            );
          },
          useMemo: function (create, deps) {
            (currentHookNameInDev = 'useMemo'), mountHookTypesDev(), checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher.current = prevDispatcher;
            }
          },
          useReducer: function (reducer, initialArg, init) {
            (currentHookNameInDev = 'useReducer'), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher.current = prevDispatcher;
            }
          },
          useRef: function (initialValue) {
            return (currentHookNameInDev = 'useRef'), mountHookTypesDev(), mountRef(initialValue);
          },
          useState: function (initialState) {
            (currentHookNameInDev = 'useState'), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher.current = prevDispatcher;
            }
          },
          useDebugValue: function (value, formatterFn) {
            (currentHookNameInDev = 'useDebugValue'), mountHookTypesDev();
          },
          useResponder: function (responder, props) {
            return (
              (currentHookNameInDev = 'useResponder'),
              mountHookTypesDev(),
              createDeprecatedResponderListener(responder, props)
            );
          },
          useDeferredValue: function (value, config) {
            return (currentHookNameInDev = 'useDeferredValue'), mountHookTypesDev(), mountDeferredValue(value, config);
          },
          useTransition: function (config) {
            return (currentHookNameInDev = 'useTransition'), mountHookTypesDev(), mountTransition(config);
          },
        }),
          (HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function (context, observedBits) {
              return readContext(context, observedBits);
            },
            useCallback: function (callback, deps) {
              return (currentHookNameInDev = 'useCallback'), updateHookTypesDev(), mountCallback(callback, deps);
            },
            useContext: function (context, observedBits) {
              return (currentHookNameInDev = 'useContext'), updateHookTypesDev(), readContext(context, observedBits);
            },
            useEffect: function (create, deps) {
              return (currentHookNameInDev = 'useEffect'), updateHookTypesDev(), mountEffect(create, deps);
            },
            useImperativeHandle: function (ref, create, deps) {
              return (
                (currentHookNameInDev = 'useImperativeHandle'),
                updateHookTypesDev(),
                mountImperativeHandle(ref, create, deps)
              );
            },
            useLayoutEffect: function (create, deps) {
              return (currentHookNameInDev = 'useLayoutEffect'), updateHookTypesDev(), mountLayoutEffect(create, deps);
            },
            useMemo: function (create, deps) {
              (currentHookNameInDev = 'useMemo'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useReducer: function (reducer, initialArg, init) {
              (currentHookNameInDev = 'useReducer'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useRef: function (initialValue) {
              return (currentHookNameInDev = 'useRef'), updateHookTypesDev(), mountRef(initialValue);
            },
            useState: function (initialState) {
              (currentHookNameInDev = 'useState'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useDebugValue: function (value, formatterFn) {
              (currentHookNameInDev = 'useDebugValue'), updateHookTypesDev();
            },
            useResponder: function (responder, props) {
              return (
                (currentHookNameInDev = 'useResponder'),
                updateHookTypesDev(),
                createDeprecatedResponderListener(responder, props)
              );
            },
            useDeferredValue: function (value, config) {
              return (
                (currentHookNameInDev = 'useDeferredValue'), updateHookTypesDev(), mountDeferredValue(value, config)
              );
            },
            useTransition: function (config) {
              return (currentHookNameInDev = 'useTransition'), updateHookTypesDev(), mountTransition(config);
            },
          }),
          (HooksDispatcherOnUpdateInDEV = {
            readContext: function (context, observedBits) {
              return readContext(context, observedBits);
            },
            useCallback: function (callback, deps) {
              return (currentHookNameInDev = 'useCallback'), updateHookTypesDev(), updateCallback(callback, deps);
            },
            useContext: function (context, observedBits) {
              return (currentHookNameInDev = 'useContext'), updateHookTypesDev(), readContext(context, observedBits);
            },
            useEffect: function (create, deps) {
              return (currentHookNameInDev = 'useEffect'), updateHookTypesDev(), updateEffect(create, deps);
            },
            useImperativeHandle: function (ref, create, deps) {
              return (
                (currentHookNameInDev = 'useImperativeHandle'),
                updateHookTypesDev(),
                updateImperativeHandle(ref, create, deps)
              );
            },
            useLayoutEffect: function (create, deps) {
              return (currentHookNameInDev = 'useLayoutEffect'), updateHookTypesDev(), updateLayoutEffect(create, deps);
            },
            useMemo: function (create, deps) {
              (currentHookNameInDev = 'useMemo'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useReducer: function (reducer, initialArg, init) {
              (currentHookNameInDev = 'useReducer'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useRef: function (initialValue) {
              return (currentHookNameInDev = 'useRef'), updateHookTypesDev(), updateRef();
            },
            useState: function (initialState) {
              (currentHookNameInDev = 'useState'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState();
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useDebugValue: function (value, formatterFn) {
              return (currentHookNameInDev = 'useDebugValue'), updateHookTypesDev(), updateDebugValue();
            },
            useResponder: function (responder, props) {
              return (
                (currentHookNameInDev = 'useResponder'),
                updateHookTypesDev(),
                createDeprecatedResponderListener(responder, props)
              );
            },
            useDeferredValue: function (value, config) {
              return (
                (currentHookNameInDev = 'useDeferredValue'), updateHookTypesDev(), updateDeferredValue(value, config)
              );
            },
            useTransition: function (config) {
              return (currentHookNameInDev = 'useTransition'), updateHookTypesDev(), updateTransition(config);
            },
          }),
          (HooksDispatcherOnRerenderInDEV = {
            readContext: function (context, observedBits) {
              return readContext(context, observedBits);
            },
            useCallback: function (callback, deps) {
              return (currentHookNameInDev = 'useCallback'), updateHookTypesDev(), updateCallback(callback, deps);
            },
            useContext: function (context, observedBits) {
              return (currentHookNameInDev = 'useContext'), updateHookTypesDev(), readContext(context, observedBits);
            },
            useEffect: function (create, deps) {
              return (currentHookNameInDev = 'useEffect'), updateHookTypesDev(), updateEffect(create, deps);
            },
            useImperativeHandle: function (ref, create, deps) {
              return (
                (currentHookNameInDev = 'useImperativeHandle'),
                updateHookTypesDev(),
                updateImperativeHandle(ref, create, deps)
              );
            },
            useLayoutEffect: function (create, deps) {
              return (currentHookNameInDev = 'useLayoutEffect'), updateHookTypesDev(), updateLayoutEffect(create, deps);
            },
            useMemo: function (create, deps) {
              (currentHookNameInDev = 'useMemo'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useReducer: function (reducer, initialArg, init) {
              (currentHookNameInDev = 'useReducer'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useRef: function (initialValue) {
              return (currentHookNameInDev = 'useRef'), updateHookTypesDev(), updateRef();
            },
            useState: function (initialState) {
              (currentHookNameInDev = 'useState'), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState();
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useDebugValue: function (value, formatterFn) {
              return (currentHookNameInDev = 'useDebugValue'), updateHookTypesDev(), updateDebugValue();
            },
            useResponder: function (responder, props) {
              return (
                (currentHookNameInDev = 'useResponder'),
                updateHookTypesDev(),
                createDeprecatedResponderListener(responder, props)
              );
            },
            useDeferredValue: function (value, config) {
              return (
                (currentHookNameInDev = 'useDeferredValue'), updateHookTypesDev(), rerenderDeferredValue(value, config)
              );
            },
            useTransition: function (config) {
              return (currentHookNameInDev = 'useTransition'), updateHookTypesDev(), rerenderTransition(config);
            },
          }),
          (InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function (context, observedBits) {
              return warnInvalidContextAccess(), readContext(context, observedBits);
            },
            useCallback: function (callback, deps) {
              return (
                (currentHookNameInDev = 'useCallback'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                mountCallback(callback, deps)
              );
            },
            useContext: function (context, observedBits) {
              return (
                (currentHookNameInDev = 'useContext'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                readContext(context, observedBits)
              );
            },
            useEffect: function (create, deps) {
              return (
                (currentHookNameInDev = 'useEffect'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                mountEffect(create, deps)
              );
            },
            useImperativeHandle: function (ref, create, deps) {
              return (
                (currentHookNameInDev = 'useImperativeHandle'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                mountImperativeHandle(ref, create, deps)
              );
            },
            useLayoutEffect: function (create, deps) {
              return (
                (currentHookNameInDev = 'useLayoutEffect'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                mountLayoutEffect(create, deps)
              );
            },
            useMemo: function (create, deps) {
              (currentHookNameInDev = 'useMemo'), warnInvalidHookAccess(), mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useReducer: function (reducer, initialArg, init) {
              (currentHookNameInDev = 'useReducer'), warnInvalidHookAccess(), mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useRef: function (initialValue) {
              return (
                (currentHookNameInDev = 'useRef'), warnInvalidHookAccess(), mountHookTypesDev(), mountRef(initialValue)
              );
            },
            useState: function (initialState) {
              (currentHookNameInDev = 'useState'), warnInvalidHookAccess(), mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useDebugValue: function (value, formatterFn) {
              (currentHookNameInDev = 'useDebugValue'), warnInvalidHookAccess(), mountHookTypesDev();
            },
            useResponder: function (responder, props) {
              return (
                (currentHookNameInDev = 'useResponder'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                createDeprecatedResponderListener(responder, props)
              );
            },
            useDeferredValue: function (value, config) {
              return (
                (currentHookNameInDev = 'useDeferredValue'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                mountDeferredValue(value, config)
              );
            },
            useTransition: function (config) {
              return (
                (currentHookNameInDev = 'useTransition'),
                warnInvalidHookAccess(),
                mountHookTypesDev(),
                mountTransition(config)
              );
            },
          }),
          (InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function (context, observedBits) {
              return warnInvalidContextAccess(), readContext(context, observedBits);
            },
            useCallback: function (callback, deps) {
              return (
                (currentHookNameInDev = 'useCallback'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateCallback(callback, deps)
              );
            },
            useContext: function (context, observedBits) {
              return (
                (currentHookNameInDev = 'useContext'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                readContext(context, observedBits)
              );
            },
            useEffect: function (create, deps) {
              return (
                (currentHookNameInDev = 'useEffect'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateEffect(create, deps)
              );
            },
            useImperativeHandle: function (ref, create, deps) {
              return (
                (currentHookNameInDev = 'useImperativeHandle'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateImperativeHandle(ref, create, deps)
              );
            },
            useLayoutEffect: function (create, deps) {
              return (
                (currentHookNameInDev = 'useLayoutEffect'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateLayoutEffect(create, deps)
              );
            },
            useMemo: function (create, deps) {
              (currentHookNameInDev = 'useMemo'), warnInvalidHookAccess(), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useReducer: function (reducer, initialArg, init) {
              (currentHookNameInDev = 'useReducer'), warnInvalidHookAccess(), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useRef: function (initialValue) {
              return (currentHookNameInDev = 'useRef'), warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
            },
            useState: function (initialState) {
              (currentHookNameInDev = 'useState'), warnInvalidHookAccess(), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState();
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useDebugValue: function (value, formatterFn) {
              return (
                (currentHookNameInDev = 'useDebugValue'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateDebugValue()
              );
            },
            useResponder: function (responder, props) {
              return (
                (currentHookNameInDev = 'useResponder'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                createDeprecatedResponderListener(responder, props)
              );
            },
            useDeferredValue: function (value, config) {
              return (
                (currentHookNameInDev = 'useDeferredValue'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateDeferredValue(value, config)
              );
            },
            useTransition: function (config) {
              return (
                (currentHookNameInDev = 'useTransition'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateTransition(config)
              );
            },
          }),
          (InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function (context, observedBits) {
              return warnInvalidContextAccess(), readContext(context, observedBits);
            },
            useCallback: function (callback, deps) {
              return (
                (currentHookNameInDev = 'useCallback'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateCallback(callback, deps)
              );
            },
            useContext: function (context, observedBits) {
              return (
                (currentHookNameInDev = 'useContext'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                readContext(context, observedBits)
              );
            },
            useEffect: function (create, deps) {
              return (
                (currentHookNameInDev = 'useEffect'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateEffect(create, deps)
              );
            },
            useImperativeHandle: function (ref, create, deps) {
              return (
                (currentHookNameInDev = 'useImperativeHandle'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateImperativeHandle(ref, create, deps)
              );
            },
            useLayoutEffect: function (create, deps) {
              return (
                (currentHookNameInDev = 'useLayoutEffect'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateLayoutEffect(create, deps)
              );
            },
            useMemo: function (create, deps) {
              (currentHookNameInDev = 'useMemo'), warnInvalidHookAccess(), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useReducer: function (reducer, initialArg, init) {
              (currentHookNameInDev = 'useReducer'), warnInvalidHookAccess(), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer);
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useRef: function (initialValue) {
              return (currentHookNameInDev = 'useRef'), warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
            },
            useState: function (initialState) {
              (currentHookNameInDev = 'useState'), warnInvalidHookAccess(), updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState();
              } finally {
                ReactCurrentDispatcher.current = prevDispatcher;
              }
            },
            useDebugValue: function (value, formatterFn) {
              return (
                (currentHookNameInDev = 'useDebugValue'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                updateDebugValue()
              );
            },
            useResponder: function (responder, props) {
              return (
                (currentHookNameInDev = 'useResponder'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                createDeprecatedResponderListener(responder, props)
              );
            },
            useDeferredValue: function (value, config) {
              return (
                (currentHookNameInDev = 'useDeferredValue'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                rerenderDeferredValue(value, config)
              );
            },
            useTransition: function (config) {
              return (
                (currentHookNameInDev = 'useTransition'),
                warnInvalidHookAccess(),
                updateHookTypesDev(),
                rerenderTransition(config)
              );
            },
          });
        var now$1 = Scheduler.unstable_now,
          commitTime = 0,
          profilerStartTime = -1;
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          (profilerStartTime = now$1()), fiber.actualStartTime < 0 && (fiber.actualStartTime = now$1());
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            (fiber.actualDuration += elapsedTime),
              overrideBaseTime && (fiber.selfBaseDuration = elapsedTime),
              (profilerStartTime = -1);
          }
        }
        var hydrationParentFiber = null,
          nextHydratableInstance = null,
          isHydrating = !1;
        function deleteHydratableInstance(returnFiber, instance) {
          switch (returnFiber.tag) {
            case 3:
              !(function didNotHydrateContainerInstance(parentContainer, instance) {
                1 === instance.nodeType
                  ? warnForDeletedHydratableElement(parentContainer, instance)
                  : 8 === instance.nodeType || warnForDeletedHydratableText(parentContainer, instance);
              })(returnFiber.stateNode.containerInfo, instance);
              break;
            case 5:
              !(function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
                !0 !== parentProps.suppressHydrationWarning &&
                  (1 === instance.nodeType
                    ? warnForDeletedHydratableElement(parentInstance, instance)
                    : 8 === instance.nodeType || warnForDeletedHydratableText(parentInstance, instance));
              })(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          }
          var childToDelete = (function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(5, null, null, 0);
            return (fiber.elementType = 'DELETED'), (fiber.type = 'DELETED'), fiber;
          })();
          (childToDelete.stateNode = instance),
            (childToDelete.return = returnFiber),
            (childToDelete.effectTag = 8),
            null !== returnFiber.lastEffect
              ? ((returnFiber.lastEffect.nextEffect = childToDelete), (returnFiber.lastEffect = childToDelete))
              : (returnFiber.firstEffect = returnFiber.lastEffect = childToDelete);
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          switch (((fiber.effectTag = (-1025 & fiber.effectTag) | 2), returnFiber.tag)) {
            case 3:
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case 5:
                  var type = fiber.type;
                  fiber.pendingProps;
                  !(function didNotFindHydratableContainerInstance(parentContainer, type, props) {
                    warnForInsertedHydratedElement(parentContainer, type);
                  })(parentContainer, type);
                  break;
                case 6:
                  !(function didNotFindHydratableContainerTextInstance(parentContainer, text) {
                    warnForInsertedHydratedText(parentContainer, text);
                  })(parentContainer, fiber.pendingProps);
              }
              break;
            case 5:
              returnFiber.type;
              var parentProps = returnFiber.memoizedProps,
                parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case 5:
                  var _type = fiber.type;
                  fiber.pendingProps;
                  !(function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
                    !0 !== parentProps.suppressHydrationWarning && warnForInsertedHydratedElement(parentInstance, type);
                  })(0, parentProps, parentInstance, _type);
                  break;
                case 6:
                  !(function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
                    !0 !== parentProps.suppressHydrationWarning && warnForInsertedHydratedText(parentInstance, text);
                  })(0, parentProps, parentInstance, fiber.pendingProps);
                  break;
                case 13:
                  !(function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
                    parentProps.suppressHydrationWarning;
                  })(0, parentProps);
              }
              break;
            default:
              return;
          }
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case 5:
              var type = fiber.type,
                instance =
                  (fiber.pendingProps,
                  (function canHydrateInstance(instance, type, props) {
                    return 1 !== instance.nodeType || type.toLowerCase() !== instance.nodeName.toLowerCase()
                      ? null
                      : instance;
                  })(nextInstance, type));
              return null !== instance && ((fiber.stateNode = instance), !0);
            case 6:
              var textInstance = (function canHydrateTextInstance(instance, text) {
                return '' === text || 3 !== instance.nodeType ? null : instance;
              })(nextInstance, fiber.pendingProps);
              return null !== textInstance && ((fiber.stateNode = textInstance), !0);
            case 13:
            default:
              return !1;
          }
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (isHydrating) {
            var nextInstance = nextHydratableInstance;
            if (!nextInstance)
              return (
                insertNonHydratedInstance(hydrationParentFiber, fiber),
                (isHydrating = !1),
                void (hydrationParentFiber = fiber)
              );
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (
                !(nextInstance = getNextHydratableSibling(firstAttemptedInstance)) ||
                !tryHydrate(fiber, nextInstance)
              )
                return (
                  insertNonHydratedInstance(hydrationParentFiber, fiber),
                  (isHydrating = !1),
                  void (hydrationParentFiber = fiber)
                );
              deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
            }
            (hydrationParentFiber = fiber), (nextHydratableInstance = getFirstHydratableChild(nextInstance));
          }
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode,
            textContent = fiber.memoizedProps,
            shouldUpdate = (function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
              return (
                precacheFiberNode(internalInstanceHandle, textInstance),
                (function diffHydratedText(textNode, text) {
                  return textNode.nodeValue !== text;
                })(textInstance, text)
              );
            })(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (null !== returnFiber)
              switch (returnFiber.tag) {
                case 3:
                  returnFiber.stateNode.containerInfo;
                  !(function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
                    warnForUnmatchedText(textInstance, text);
                  })(0, textInstance, textContent);
                  break;
                case 5:
                  returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  returnFiber.stateNode;
                  !(function didNotMatchHydratedTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    textInstance,
                    text
                  ) {
                    !0 !== parentProps.suppressHydrationWarning && warnForUnmatchedText(textInstance, text);
                  })(0, parentProps, 0, textInstance, textContent);
              }
          }
          return shouldUpdate;
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState,
            suspenseInstance = null !== suspenseState ? suspenseState.dehydrated : null;
          if (!suspenseInstance)
            throw Error(
              'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'
            );
          return (function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            for (var node = suspenseInstance.nextSibling, depth = 0; node; ) {
              if (8 === node.nodeType) {
                var data = node.data;
                if ('/$' === data) {
                  if (0 === depth) return getNextHydratableSibling(node);
                  depth--;
                } else ('$' !== data && '$!' !== data && '$?' !== data) || depth++;
              }
              node = node.nextSibling;
            }
            return null;
          })(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          for (
            var parent = fiber.return;
            null !== parent && 5 !== parent.tag && 3 !== parent.tag && 13 !== parent.tag;

          )
            parent = parent.return;
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return !1;
          if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
          var type = fiber.type;
          if (
            5 !== fiber.tag ||
            ('head' !== type && 'body' !== type && !shouldSetTextContent(type, fiber.memoizedProps))
          )
            for (var nextInstance = nextHydratableInstance; nextInstance; )
              deleteHydratableInstance(fiber, nextInstance), (nextInstance = getNextHydratableSibling(nextInstance));
          return (
            popToNextHostParent(fiber),
            (nextHydratableInstance =
              13 === fiber.tag
                ? skipPastDehydratedSuspenseInstance(fiber)
                : hydrationParentFiber
                ? getNextHydratableSibling(fiber.stateNode)
                : null),
            !0
          );
        }
        function resetHydrationState() {
          (hydrationParentFiber = null), (nextHydratableInstance = null), (isHydrating = !1);
        }
        var didWarnAboutBadClass,
          didWarnAboutModulePatternComponent,
          didWarnAboutContextTypeOnFunctionComponent,
          didWarnAboutGetDerivedStateOnFunctionComponent,
          didWarnAboutFunctionRefs,
          didWarnAboutReassigningProps,
          didWarnAboutRevealOrder,
          didWarnAboutTailOptions,
          ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner,
          didReceiveUpdate = !1;
        function reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime) {
          workInProgress.child =
            null === current
              ? mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime)
              : reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
        }
        function updateForwardRef(current, workInProgress, Component, nextProps, renderExpirationTime) {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;
            innerPropTypes &&
              checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component), getCurrentFiberStackInDev);
          }
          var nextChildren,
            render = Component.render,
            ref = workInProgress.ref;
          return (
            prepareToReadContext(workInProgress, renderExpirationTime),
            (ReactCurrentOwner$1.current = workInProgress),
            setIsRendering(!0),
            (nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime)),
            1 & workInProgress.mode &&
              null !== workInProgress.memoizedState &&
              (nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime)),
            setIsRendering(!1),
            null === current || didReceiveUpdate
              ? ((workInProgress.effectTag |= 1),
                reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime),
                workInProgress.child)
              : (bailoutHooks(current, workInProgress, renderExpirationTime),
                bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime))
          );
        }
        function updateMemoComponent(
          current,
          workInProgress,
          Component,
          nextProps,
          updateExpirationTime,
          renderExpirationTime
        ) {
          if (null === current) {
            var type = Component.type;
            if (
              (function isSimpleFunctionComponent(type) {
                return 'function' == typeof type && !shouldConstruct(type) && void 0 === type.defaultProps;
              })(type) &&
              null === Component.compare &&
              void 0 === Component.defaultProps
            ) {
              var resolvedType;
              return (
                (resolvedType = resolveFunctionForHotReloading(type)),
                (workInProgress.tag = 15),
                (workInProgress.type = resolvedType),
                validateFunctionComponentInDev(workInProgress, type),
                updateSimpleMemoComponent(
                  current,
                  workInProgress,
                  resolvedType,
                  nextProps,
                  updateExpirationTime,
                  renderExpirationTime
                )
              );
            }
            var innerPropTypes = type.propTypes;
            innerPropTypes &&
              checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(type), getCurrentFiberStackInDev);
            var child = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              null,
              workInProgress.mode,
              renderExpirationTime
            );
            return (
              (child.ref = workInProgress.ref), (child.return = workInProgress), (workInProgress.child = child), child
            );
          }
          var _type = Component.type,
            _innerPropTypes = _type.propTypes;
          _innerPropTypes &&
            checkPropTypes(_innerPropTypes, nextProps, 'prop', getComponentName(_type), getCurrentFiberStackInDev);
          var currentChild = current.child;
          if (updateExpirationTime < renderExpirationTime) {
            var prevProps = currentChild.memoizedProps,
              compare = Component.compare;
            if (
              (compare = null !== compare ? compare : shallowEqual)(prevProps, nextProps) &&
              current.ref === workInProgress.ref
            )
              return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
          }
          workInProgress.effectTag |= 1;
          var newChild = createWorkInProgress(currentChild, nextProps);
          return (
            (newChild.ref = workInProgress.ref),
            (newChild.return = workInProgress),
            (workInProgress.child = newChild),
            newChild
          );
        }
        function updateSimpleMemoComponent(
          current,
          workInProgress,
          Component,
          nextProps,
          updateExpirationTime,
          renderExpirationTime
        ) {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerMemoType = workInProgress.elementType;
            outerMemoType.$$typeof === REACT_LAZY_TYPE && (outerMemoType = refineResolvedLazyComponent(outerMemoType));
            var outerPropTypes = outerMemoType && outerMemoType.propTypes;
            outerPropTypes &&
              checkPropTypes(
                outerPropTypes,
                nextProps,
                'prop',
                getComponentName(outerMemoType),
                getCurrentFiberStackInDev
              );
          }
          if (
            null !== current &&
            shallowEqual(current.memoizedProps, nextProps) &&
            current.ref === workInProgress.ref &&
            workInProgress.type === current.type &&
            ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
          )
            return (
              (workInProgress.expirationTime = current.expirationTime),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime)
            );
          return updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime);
        }
        function markRef(current, workInProgress) {
          var ref = workInProgress.ref;
          ((null === current && null !== ref) || (null !== current && current.ref !== ref)) &&
            (workInProgress.effectTag |= 128);
        }
        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;
            innerPropTypes &&
              checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component), getCurrentFiberStackInDev);
          }
          var context, nextChildren;
          return (
            (context = getMaskedContext(workInProgress, getUnmaskedContext(0, Component, !0))),
            prepareToReadContext(workInProgress, renderExpirationTime),
            (ReactCurrentOwner$1.current = workInProgress),
            setIsRendering(!0),
            (nextChildren = renderWithHooks(
              current,
              workInProgress,
              Component,
              nextProps,
              context,
              renderExpirationTime
            )),
            1 & workInProgress.mode &&
              null !== workInProgress.memoizedState &&
              (nextChildren = renderWithHooks(
                current,
                workInProgress,
                Component,
                nextProps,
                context,
                renderExpirationTime
              )),
            setIsRendering(!1),
            null === current || didReceiveUpdate
              ? ((workInProgress.effectTag |= 1),
                reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime),
                workInProgress.child)
              : (bailoutHooks(current, workInProgress, renderExpirationTime),
                bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime))
          );
        }
        function updateClassComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {
          if (workInProgress.type !== workInProgress.elementType) {
            var innerPropTypes = Component.propTypes;
            innerPropTypes &&
              checkPropTypes(innerPropTypes, nextProps, 'prop', getComponentName(Component), getCurrentFiberStackInDev);
          }
          var hasContext, shouldUpdate;
          isContextProvider(Component) ? ((hasContext = !0), pushContextProvider(workInProgress)) : (hasContext = !1),
            prepareToReadContext(workInProgress, renderExpirationTime),
            null === workInProgress.stateNode
              ? (null !== current &&
                  ((current.alternate = null), (workInProgress.alternate = null), (workInProgress.effectTag |= 2)),
                constructClassInstance(workInProgress, Component, nextProps),
                mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime),
                (shouldUpdate = !0))
              : (shouldUpdate =
                  null === current
                    ? (function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
                        var instance = workInProgress.stateNode,
                          oldProps = workInProgress.memoizedProps;
                        instance.props = oldProps;
                        var oldContext = instance.context,
                          contextType = ctor.contextType,
                          nextContext = emptyContextObject;
                        nextContext =
                          'object' == typeof contextType && null !== contextType
                            ? readContext(contextType)
                            : getMaskedContext(workInProgress, getUnmaskedContext(0, ctor, !0));
                        var getDerivedStateFromProps = ctor.getDerivedStateFromProps,
                          hasNewLifecycles =
                            'function' == typeof getDerivedStateFromProps ||
                            'function' == typeof instance.getSnapshotBeforeUpdate;
                        hasNewLifecycles ||
                          ('function' != typeof instance.UNSAFE_componentWillReceiveProps &&
                            'function' != typeof instance.componentWillReceiveProps) ||
                          (oldProps === newProps && oldContext === nextContext) ||
                          callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext),
                          resetHasForceUpdateBeforeProcessing();
                        var oldState = workInProgress.memoizedState,
                          newState = (instance.state = oldState);
                        if (
                          (processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime),
                          (newState = workInProgress.memoizedState),
                          oldProps === newProps &&
                            oldState === newState &&
                            !hasContextChanged() &&
                            !checkHasForceUpdateAfterProcessing())
                        )
                          return 'function' == typeof instance.componentDidMount && (workInProgress.effectTag |= 4), !1;
                        'function' == typeof getDerivedStateFromProps &&
                          (applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps),
                          (newState = workInProgress.memoizedState));
                        var shouldUpdate =
                          checkHasForceUpdateAfterProcessing() ||
                          checkShouldComponentUpdate(
                            workInProgress,
                            ctor,
                            oldProps,
                            newProps,
                            oldState,
                            newState,
                            nextContext
                          );
                        return (
                          shouldUpdate
                            ? (hasNewLifecycles ||
                                ('function' != typeof instance.UNSAFE_componentWillMount &&
                                  'function' != typeof instance.componentWillMount) ||
                                (startPhaseTimer(workInProgress, 'componentWillMount'),
                                'function' == typeof instance.componentWillMount && instance.componentWillMount(),
                                'function' == typeof instance.UNSAFE_componentWillMount &&
                                  instance.UNSAFE_componentWillMount(),
                                stopPhaseTimer()),
                              'function' == typeof instance.componentDidMount && (workInProgress.effectTag |= 4))
                            : ('function' == typeof instance.componentDidMount && (workInProgress.effectTag |= 4),
                              (workInProgress.memoizedProps = newProps),
                              (workInProgress.memoizedState = newState)),
                          (instance.props = newProps),
                          (instance.state = newState),
                          (instance.context = nextContext),
                          shouldUpdate
                        );
                      })(workInProgress, Component, nextProps, renderExpirationTime)
                    : (function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
                        var instance = workInProgress.stateNode;
                        cloneUpdateQueue(current, workInProgress);
                        var oldProps = workInProgress.memoizedProps;
                        instance.props =
                          workInProgress.type === workInProgress.elementType
                            ? oldProps
                            : resolveDefaultProps(workInProgress.type, oldProps);
                        var oldContext = instance.context,
                          contextType = ctor.contextType,
                          nextContext = emptyContextObject;
                        nextContext =
                          'object' == typeof contextType && null !== contextType
                            ? readContext(contextType)
                            : getMaskedContext(workInProgress, getUnmaskedContext(0, ctor, !0));
                        var getDerivedStateFromProps = ctor.getDerivedStateFromProps,
                          hasNewLifecycles =
                            'function' == typeof getDerivedStateFromProps ||
                            'function' == typeof instance.getSnapshotBeforeUpdate;
                        hasNewLifecycles ||
                          ('function' != typeof instance.UNSAFE_componentWillReceiveProps &&
                            'function' != typeof instance.componentWillReceiveProps) ||
                          (oldProps === newProps && oldContext === nextContext) ||
                          callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext),
                          resetHasForceUpdateBeforeProcessing();
                        var oldState = workInProgress.memoizedState,
                          newState = (instance.state = oldState);
                        if (
                          (processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime),
                          (newState = workInProgress.memoizedState),
                          oldProps === newProps &&
                            oldState === newState &&
                            !hasContextChanged() &&
                            !checkHasForceUpdateAfterProcessing())
                        )
                          return (
                            'function' == typeof instance.componentDidUpdate &&
                              ((oldProps === current.memoizedProps && oldState === current.memoizedState) ||
                                (workInProgress.effectTag |= 4)),
                            'function' == typeof instance.getSnapshotBeforeUpdate &&
                              ((oldProps === current.memoizedProps && oldState === current.memoizedState) ||
                                (workInProgress.effectTag |= 256)),
                            !1
                          );
                        'function' == typeof getDerivedStateFromProps &&
                          (applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps),
                          (newState = workInProgress.memoizedState));
                        var shouldUpdate =
                          checkHasForceUpdateAfterProcessing() ||
                          checkShouldComponentUpdate(
                            workInProgress,
                            ctor,
                            oldProps,
                            newProps,
                            oldState,
                            newState,
                            nextContext
                          );
                        return (
                          shouldUpdate
                            ? (hasNewLifecycles ||
                                ('function' != typeof instance.UNSAFE_componentWillUpdate &&
                                  'function' != typeof instance.componentWillUpdate) ||
                                (startPhaseTimer(workInProgress, 'componentWillUpdate'),
                                'function' == typeof instance.componentWillUpdate &&
                                  instance.componentWillUpdate(newProps, newState, nextContext),
                                'function' == typeof instance.UNSAFE_componentWillUpdate &&
                                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext),
                                stopPhaseTimer()),
                              'function' == typeof instance.componentDidUpdate && (workInProgress.effectTag |= 4),
                              'function' == typeof instance.getSnapshotBeforeUpdate &&
                                (workInProgress.effectTag |= 256))
                            : ('function' == typeof instance.componentDidUpdate &&
                                ((oldProps === current.memoizedProps && oldState === current.memoizedState) ||
                                  (workInProgress.effectTag |= 4)),
                              'function' == typeof instance.getSnapshotBeforeUpdate &&
                                ((oldProps === current.memoizedProps && oldState === current.memoizedState) ||
                                  (workInProgress.effectTag |= 256)),
                              (workInProgress.memoizedProps = newProps),
                              (workInProgress.memoizedState = newState)),
                          (instance.props = newProps),
                          (instance.state = newState),
                          (instance.context = nextContext),
                          shouldUpdate
                        );
                      })(current, workInProgress, Component, nextProps, renderExpirationTime));
          var nextUnitOfWork = finishClassComponent(
            current,
            workInProgress,
            Component,
            shouldUpdate,
            hasContext,
            renderExpirationTime
          );
          return (
            workInProgress.stateNode.props !== nextProps &&
              (didWarnAboutReassigningProps ||
                error(
                  'It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.',
                  getComponentName(workInProgress.type) || 'a component'
                ),
              (didWarnAboutReassigningProps = !0)),
            nextUnitOfWork
          );
        }
        function finishClassComponent(
          current,
          workInProgress,
          Component,
          shouldUpdate,
          hasContext,
          renderExpirationTime
        ) {
          markRef(current, workInProgress);
          var didCaptureError = 0 != (64 & workInProgress.effectTag);
          if (!shouldUpdate && !didCaptureError)
            return (
              hasContext && invalidateContextProvider(workInProgress, Component, !1),
              bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime)
            );
          var nextChildren,
            instance = workInProgress.stateNode;
          return (
            (ReactCurrentOwner$1.current = workInProgress),
            didCaptureError && 'function' != typeof Component.getDerivedStateFromError
              ? ((nextChildren = null), stopProfilerTimerIfRunning())
              : (setIsRendering(!0),
                (nextChildren = instance.render()),
                1 & workInProgress.mode && instance.render(),
                setIsRendering(!1)),
            (workInProgress.effectTag |= 1),
            null !== current && didCaptureError
              ? (function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime) {
                  (workInProgress.child = reconcileChildFibers(
                    workInProgress,
                    current.child,
                    null,
                    renderExpirationTime
                  )),
                    (workInProgress.child = reconcileChildFibers(
                      workInProgress,
                      null,
                      nextChildren,
                      renderExpirationTime
                    ));
                })(current, workInProgress, nextChildren, renderExpirationTime)
              : reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime),
            (workInProgress.memoizedState = instance.state),
            hasContext && invalidateContextProvider(workInProgress, Component, !0),
            workInProgress.child
          );
        }
        function pushHostRootContext(workInProgress) {
          var root = workInProgress.stateNode;
          root.pendingContext
            ? pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context)
            : root.context && pushTopLevelContextObject(workInProgress, root.context, !1),
            pushHostContainer(workInProgress, root.containerInfo);
        }
        function updateHostRoot(current, workInProgress, renderExpirationTime) {
          pushHostRootContext(workInProgress);
          var updateQueue = workInProgress.updateQueue;
          if (null === current || null === updateQueue)
            throw Error(
              'If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.'
            );
          var nextProps = workInProgress.pendingProps,
            prevState = workInProgress.memoizedState,
            prevChildren = null !== prevState ? prevState.element : null;
          cloneUpdateQueue(current, workInProgress),
            processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);
          var nextChildren = workInProgress.memoizedState.element;
          if (nextChildren === prevChildren)
            return resetHydrationState(), bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
          if (
            workInProgress.stateNode.hydrate &&
            (function enterHydrationState(fiber) {
              var parentInstance = fiber.stateNode.containerInfo;
              return (
                (nextHydratableInstance = getFirstHydratableChild(parentInstance)),
                (hydrationParentFiber = fiber),
                (isHydrating = !0),
                !0
              );
            })(workInProgress)
          ) {
            var child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
            workInProgress.child = child;
            for (var node = child; node; ) (node.effectTag = (-3 & node.effectTag) | 1024), (node = node.sibling);
          } else reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime), resetHydrationState();
          return workInProgress.child;
        }
        function mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {
          null !== _current &&
            ((_current.alternate = null), (workInProgress.alternate = null), (workInProgress.effectTag |= 2));
          var props = workInProgress.pendingProps;
          cancelWorkTimer(workInProgress);
          var Component = readLazyComponentType(elementType);
          workInProgress.type = Component;
          var resolvedTag = (workInProgress.tag = (function resolveLazyComponentTag(Component) {
            if ('function' == typeof Component) return shouldConstruct(Component) ? 1 : 0;
            if (null != Component) {
              var $$typeof = Component.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) return 11;
              if ($$typeof === REACT_MEMO_TYPE) return 14;
            }
            return 2;
          })(Component));
          startWorkTimer(workInProgress);
          var resolvedProps = resolveDefaultProps(Component, props);
          switch (resolvedTag) {
            case 0:
              return (
                validateFunctionComponentInDev(workInProgress, Component),
                (workInProgress.type = Component = resolveFunctionForHotReloading(Component)),
                updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime)
              );
            case 1:
              return (
                (workInProgress.type = Component = resolveClassForHotReloading(Component)),
                updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime)
              );
            case 11:
              return (
                (workInProgress.type = Component = resolveForwardRefForHotReloading(Component)),
                updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime)
              );
            case 14:
              if (workInProgress.type !== workInProgress.elementType) {
                var outerPropTypes = Component.propTypes;
                outerPropTypes &&
                  checkPropTypes(
                    outerPropTypes,
                    resolvedProps,
                    'prop',
                    getComponentName(Component),
                    getCurrentFiberStackInDev
                  );
              }
              return updateMemoComponent(
                null,
                workInProgress,
                Component,
                resolveDefaultProps(Component.type, resolvedProps),
                updateExpirationTime,
                renderExpirationTime
              );
          }
          var hint = '';
          throw (
            (null !== Component &&
              'object' == typeof Component &&
              Component.$$typeof === REACT_LAZY_TYPE &&
              (hint = ' Did you wrap a component in React.lazy() more than once?'),
            Error(
              'Element type is invalid. Received a promise that resolves to: ' +
                Component +
                '. Lazy element type must resolve to a class or function.' +
                hint
            ))
          );
        }
        function validateFunctionComponentInDev(workInProgress, Component) {
          if (
            (Component &&
              Component.childContextTypes &&
              error(
                '%s(...): childContextTypes cannot be defined on a function component.',
                Component.displayName || Component.name || 'Component'
              ),
            null !== workInProgress.ref)
          ) {
            var info = '',
              ownerName = getCurrentFiberOwnerNameInDevOrNull();
            ownerName && (info += '\n\nCheck the render method of `' + ownerName + '`.');
            var warningKey = ownerName || workInProgress._debugID || '',
              debugSource = workInProgress._debugSource;
            debugSource && (warningKey = debugSource.fileName + ':' + debugSource.lineNumber),
              didWarnAboutFunctionRefs[warningKey] ||
                ((didWarnAboutFunctionRefs[warningKey] = !0),
                error(
                  'Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s',
                  info
                ));
          }
          if ('function' == typeof Component.getDerivedStateFromProps) {
            var _componentName2 = getComponentName(Component) || 'Unknown';
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] ||
              (error('%s: Function components do not support getDerivedStateFromProps.', _componentName2),
              (didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = !0));
          }
          if ('object' == typeof Component.contextType && null !== Component.contextType) {
            var _componentName3 = getComponentName(Component) || 'Unknown';
            didWarnAboutContextTypeOnFunctionComponent[_componentName3] ||
              (error('%s: Function components do not support contextType.', _componentName3),
              (didWarnAboutContextTypeOnFunctionComponent[_componentName3] = !0));
          }
        }
        (didWarnAboutBadClass = {}),
          (didWarnAboutModulePatternComponent = {}),
          (didWarnAboutContextTypeOnFunctionComponent = {}),
          (didWarnAboutGetDerivedStateOnFunctionComponent = {}),
          (didWarnAboutFunctionRefs = {}),
          (didWarnAboutReassigningProps = !1),
          (didWarnAboutRevealOrder = {}),
          (didWarnAboutTailOptions = {});
        var SUSPENDED_MARKER = { dehydrated: null, retryTime: 0 };
        function updateSuspenseComponent(current, workInProgress, renderExpirationTime) {
          var mode = workInProgress.mode,
            nextProps = workInProgress.pendingProps;
          (function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          })(workInProgress) && (workInProgress.effectTag |= 64);
          var suspenseContext = suspenseStackCursor.current,
            nextDidTimeout = !1;
          if (
            (0 != (64 & workInProgress.effectTag) ||
            (function shouldRemainOnFallback(suspenseContext, current, workInProgress) {
              return hasSuspenseContext(suspenseContext, 2) && (null === current || null !== current.memoizedState);
            })(suspenseContext, current)
              ? ((nextDidTimeout = !0), (workInProgress.effectTag &= -65))
              : (null !== current && null === current.memoizedState) ||
                (void 0 !== nextProps.fallback &&
                  !0 !== nextProps.unstable_avoidThisFallback &&
                  (suspenseContext = (function addSubtreeSuspenseContext(parentContext, subtreeContext) {
                    return parentContext | subtreeContext;
                  })(suspenseContext, 1))),
            pushSuspenseContext(workInProgress, (suspenseContext = setDefaultShallowSuspenseContext(suspenseContext))),
            null === current)
          ) {
            if ((void 0 !== nextProps.fallback && tryToClaimNextHydratableInstance(workInProgress), nextDidTimeout)) {
              var nextFallbackChildren = nextProps.fallback,
                primaryChildFragment = createFiberFromFragment(null, mode, 0, null);
              if (((primaryChildFragment.return = workInProgress), 0 == (2 & workInProgress.mode))) {
                var progressedPrimaryChild =
                  null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child;
                primaryChildFragment.child = progressedPrimaryChild;
                for (var progressedChild = progressedPrimaryChild; null !== progressedChild; )
                  (progressedChild.return = primaryChildFragment), (progressedChild = progressedChild.sibling);
              }
              var fallbackChildFragment = createFiberFromFragment(
                nextFallbackChildren,
                mode,
                renderExpirationTime,
                null
              );
              return (
                (fallbackChildFragment.return = workInProgress),
                (primaryChildFragment.sibling = fallbackChildFragment),
                (workInProgress.memoizedState = SUSPENDED_MARKER),
                (workInProgress.child = primaryChildFragment),
                fallbackChildFragment
              );
            }
            var nextPrimaryChildren = nextProps.children;
            return (
              (workInProgress.memoizedState = null),
              (workInProgress.child = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime))
            );
          }
          if (null !== current.memoizedState) {
            var currentPrimaryChildFragment = current.child,
              currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            if (nextDidTimeout) {
              var _nextFallbackChildren2 = nextProps.fallback,
                _primaryChildFragment2 = createWorkInProgress(
                  currentPrimaryChildFragment,
                  currentPrimaryChildFragment.pendingProps
                );
              if (((_primaryChildFragment2.return = workInProgress), 0 == (2 & workInProgress.mode))) {
                var _progressedPrimaryChild =
                  null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child;
                if (_progressedPrimaryChild !== currentPrimaryChildFragment.child) {
                  _primaryChildFragment2.child = _progressedPrimaryChild;
                  for (var _progressedChild2 = _progressedPrimaryChild; null !== _progressedChild2; )
                    (_progressedChild2.return = _primaryChildFragment2),
                      (_progressedChild2 = _progressedChild2.sibling);
                }
              }
              if (8 & workInProgress.mode) {
                for (var _treeBaseDuration = 0, _hiddenChild = _primaryChildFragment2.child; null !== _hiddenChild; )
                  (_treeBaseDuration += _hiddenChild.treeBaseDuration), (_hiddenChild = _hiddenChild.sibling);
                _primaryChildFragment2.treeBaseDuration = _treeBaseDuration;
              }
              var _fallbackChildFragment2 = createWorkInProgress(currentFallbackChildFragment, _nextFallbackChildren2);
              return (
                (_fallbackChildFragment2.return = workInProgress),
                (_primaryChildFragment2.sibling = _fallbackChildFragment2),
                (_primaryChildFragment2.childExpirationTime = 0),
                (workInProgress.memoizedState = SUSPENDED_MARKER),
                (workInProgress.child = _primaryChildFragment2),
                _fallbackChildFragment2
              );
            }
            var _nextPrimaryChildren = nextProps.children,
              currentPrimaryChild = currentPrimaryChildFragment.child,
              primaryChild = reconcileChildFibers(
                workInProgress,
                currentPrimaryChild,
                _nextPrimaryChildren,
                renderExpirationTime
              );
            return (workInProgress.memoizedState = null), (workInProgress.child = primaryChild);
          }
          var _currentPrimaryChild = current.child;
          if (nextDidTimeout) {
            var _nextFallbackChildren3 = nextProps.fallback,
              _primaryChildFragment3 = createFiberFromFragment(null, mode, 0, null);
            if (
              ((_primaryChildFragment3.return = workInProgress),
              (_primaryChildFragment3.child = _currentPrimaryChild),
              null !== _currentPrimaryChild && (_currentPrimaryChild.return = _primaryChildFragment3),
              0 == (2 & workInProgress.mode))
            ) {
              var _progressedPrimaryChild2 =
                null !== workInProgress.memoizedState ? workInProgress.child.child : workInProgress.child;
              _primaryChildFragment3.child = _progressedPrimaryChild2;
              for (var _progressedChild3 = _progressedPrimaryChild2; null !== _progressedChild3; )
                (_progressedChild3.return = _primaryChildFragment3), (_progressedChild3 = _progressedChild3.sibling);
            }
            if (8 & workInProgress.mode) {
              for (var _treeBaseDuration2 = 0, _hiddenChild2 = _primaryChildFragment3.child; null !== _hiddenChild2; )
                (_treeBaseDuration2 += _hiddenChild2.treeBaseDuration), (_hiddenChild2 = _hiddenChild2.sibling);
              _primaryChildFragment3.treeBaseDuration = _treeBaseDuration2;
            }
            var _fallbackChildFragment3 = createFiberFromFragment(
              _nextFallbackChildren3,
              mode,
              renderExpirationTime,
              null
            );
            return (
              (_fallbackChildFragment3.return = workInProgress),
              (_primaryChildFragment3.sibling = _fallbackChildFragment3),
              (_fallbackChildFragment3.effectTag |= 2),
              (_primaryChildFragment3.childExpirationTime = 0),
              (workInProgress.memoizedState = SUSPENDED_MARKER),
              (workInProgress.child = _primaryChildFragment3),
              _fallbackChildFragment3
            );
          }
          workInProgress.memoizedState = null;
          var _nextPrimaryChildren2 = nextProps.children;
          return (workInProgress.child = reconcileChildFibers(
            workInProgress,
            _currentPrimaryChild,
            _nextPrimaryChildren2,
            renderExpirationTime
          ));
        }
        function scheduleWorkOnFiber(fiber, renderExpirationTime) {
          fiber.expirationTime < renderExpirationTime && (fiber.expirationTime = renderExpirationTime);
          var alternate = fiber.alternate;
          null !== alternate &&
            alternate.expirationTime < renderExpirationTime &&
            (alternate.expirationTime = renderExpirationTime),
            scheduleWorkOnParentPath(fiber.return, renderExpirationTime);
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isArray = Array.isArray(childSlot),
            isIterable = !isArray && 'function' == typeof getIteratorFn(childSlot);
          if (isArray || isIterable) {
            var type = isArray ? 'array' : 'iterable';
            return (
              error(
                'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>',
                type,
                index,
                type
              ),
              !1
            );
          }
          return !0;
        }
        function initSuspenseListRenderState(
          workInProgress,
          isBackwards,
          tail,
          lastContentRow,
          tailMode,
          lastEffectBeforeRendering
        ) {
          var renderState = workInProgress.memoizedState;
          null === renderState
            ? (workInProgress.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailExpiration: 0,
                tailMode,
                lastEffect: lastEffectBeforeRendering,
              })
            : ((renderState.isBackwards = isBackwards),
              (renderState.rendering = null),
              (renderState.renderingStartTime = 0),
              (renderState.last = lastContentRow),
              (renderState.tail = tail),
              (renderState.tailExpiration = 0),
              (renderState.tailMode = tailMode),
              (renderState.lastEffect = lastEffectBeforeRendering));
        }
        function updateSuspenseListComponent(current, workInProgress, renderExpirationTime) {
          var nextProps = workInProgress.pendingProps,
            revealOrder = nextProps.revealOrder,
            tailMode = nextProps.tail,
            newChildren = nextProps.children;
          !(function validateRevealOrder(revealOrder) {
            if (
              void 0 !== revealOrder &&
              'forwards' !== revealOrder &&
              'backwards' !== revealOrder &&
              'together' !== revealOrder &&
              !didWarnAboutRevealOrder[revealOrder]
            )
              if (((didWarnAboutRevealOrder[revealOrder] = !0), 'string' == typeof revealOrder))
                switch (revealOrder.toLowerCase()) {
                  case 'together':
                  case 'forwards':
                  case 'backwards':
                    error(
                      '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                      revealOrder,
                      revealOrder.toLowerCase()
                    );
                    break;
                  case 'forward':
                  case 'backward':
                    error(
                      '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                      revealOrder,
                      revealOrder.toLowerCase()
                    );
                    break;
                  default:
                    error(
                      '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                      revealOrder
                    );
                }
              else
                error(
                  '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                  revealOrder
                );
          })(revealOrder),
            (function validateTailOptions(tailMode, revealOrder) {
              void 0 === tailMode ||
                didWarnAboutTailOptions[tailMode] ||
                ('collapsed' !== tailMode && 'hidden' !== tailMode
                  ? ((didWarnAboutTailOptions[tailMode] = !0),
                    error(
                      '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
                      tailMode
                    ))
                  : 'forwards' !== revealOrder &&
                    'backwards' !== revealOrder &&
                    ((didWarnAboutTailOptions[tailMode] = !0),
                    error(
                      '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
                      tailMode
                    )));
            })(tailMode, revealOrder),
            (function validateSuspenseListChildren(children, revealOrder) {
              if (('forwards' === revealOrder || 'backwards' === revealOrder) && null != children && !1 !== children)
                if (Array.isArray(children)) {
                  for (var i = 0; i < children.length; i++)
                    if (!validateSuspenseListNestedChild(children[i], i)) return;
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if ('function' == typeof iteratorFn) {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator)
                      for (var step = childrenIterator.next(), _i = 0; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) return;
                        _i++;
                      }
                  } else
                    error(
                      'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                      revealOrder
                    );
                }
            })(newChildren, revealOrder),
            reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);
          var suspenseContext = suspenseStackCursor.current;
          hasSuspenseContext(suspenseContext, 2)
            ? ((suspenseContext = setShallowSuspenseContext(suspenseContext, 2)), (workInProgress.effectTag |= 64))
            : (null !== current &&
                0 != (64 & current.effectTag) &&
                (function propagateSuspenseContextChange(workInProgress, firstChild, renderExpirationTime) {
                  for (var node = firstChild; null !== node; ) {
                    if (13 === node.tag) null !== node.memoizedState && scheduleWorkOnFiber(node, renderExpirationTime);
                    else if (19 === node.tag) scheduleWorkOnFiber(node, renderExpirationTime);
                    else if (null !== node.child) {
                      (node.child.return = node), (node = node.child);
                      continue;
                    }
                    if (node === workInProgress) return;
                    for (; null === node.sibling; ) {
                      if (null === node.return || node.return === workInProgress) return;
                      node = node.return;
                    }
                    (node.sibling.return = node.return), (node = node.sibling);
                  }
                })(workInProgress, workInProgress.child, renderExpirationTime),
              (suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)));
          if ((pushSuspenseContext(workInProgress, suspenseContext), 0 == (2 & workInProgress.mode)))
            workInProgress.memoizedState = null;
          else
            switch (revealOrder) {
              case 'forwards':
                var tail,
                  lastContentRow = (function findLastContentRow(firstChild) {
                    for (var row = firstChild, lastContentRow = null; null !== row; ) {
                      var currentRow = row.alternate;
                      null !== currentRow && null === findFirstSuspended(currentRow) && (lastContentRow = row),
                        (row = row.sibling);
                    }
                    return lastContentRow;
                  })(workInProgress.child);
                null === lastContentRow
                  ? ((tail = workInProgress.child), (workInProgress.child = null))
                  : ((tail = lastContentRow.sibling), (lastContentRow.sibling = null)),
                  initSuspenseListRenderState(
                    workInProgress,
                    !1,
                    tail,
                    lastContentRow,
                    tailMode,
                    workInProgress.lastEffect
                  );
                break;
              case 'backwards':
                var _tail = null,
                  row = workInProgress.child;
                for (workInProgress.child = null; null !== row; ) {
                  var currentRow = row.alternate;
                  if (null !== currentRow && null === findFirstSuspended(currentRow)) {
                    workInProgress.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  (row.sibling = _tail), (_tail = row), (row = nextRow);
                }
                initSuspenseListRenderState(workInProgress, !0, _tail, null, tailMode, workInProgress.lastEffect);
                break;
              case 'together':
                initSuspenseListRenderState(workInProgress, !1, null, null, void 0, workInProgress.lastEffect);
                break;
              default:
                workInProgress.memoizedState = null;
            }
          return workInProgress.child;
        }
        function updateContextProvider(current, workInProgress, renderExpirationTime) {
          var context = workInProgress.type._context,
            newProps = workInProgress.pendingProps,
            oldProps = workInProgress.memoizedProps,
            newValue = newProps.value,
            providerPropTypes = workInProgress.type.propTypes;
          if (
            (providerPropTypes &&
              checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackInDev),
            pushProvider(workInProgress, newValue),
            null !== oldProps)
          ) {
            var changedBits = (function calculateChangedBits(context, newValue, oldValue) {
              if (objectIs(oldValue, newValue)) return 0;
              var changedBits =
                'function' == typeof context._calculateChangedBits
                  ? context._calculateChangedBits(oldValue, newValue)
                  : 1073741823;
              return (
                (1073741823 & changedBits) !== changedBits &&
                  error(
                    'calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s',
                    changedBits
                  ),
                0 | changedBits
              );
            })(context, newValue, oldProps.value);
            if (0 === changedBits) {
              if (oldProps.children === newProps.children && !hasContextChanged())
                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
            } else
              !(function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
                var fiber = workInProgress.child;
                for (null !== fiber && (fiber.return = workInProgress); null !== fiber; ) {
                  var nextFiber = void 0,
                    list = fiber.dependencies;
                  if (null !== list) {
                    nextFiber = fiber.child;
                    for (var dependency = list.firstContext; null !== dependency; ) {
                      if (dependency.context === context && 0 != (dependency.observedBits & changedBits)) {
                        if (1 === fiber.tag) {
                          var update = createUpdate(renderExpirationTime, null);
                          (update.tag = ForceUpdate), enqueueUpdate(fiber, update);
                        }
                        fiber.expirationTime < renderExpirationTime && (fiber.expirationTime = renderExpirationTime);
                        var alternate = fiber.alternate;
                        null !== alternate &&
                          alternate.expirationTime < renderExpirationTime &&
                          (alternate.expirationTime = renderExpirationTime),
                          scheduleWorkOnParentPath(fiber.return, renderExpirationTime),
                          list.expirationTime < renderExpirationTime && (list.expirationTime = renderExpirationTime);
                        break;
                      }
                      dependency = dependency.next;
                    }
                  } else nextFiber = 10 === fiber.tag && fiber.type === workInProgress.type ? null : fiber.child;
                  if (null !== nextFiber) nextFiber.return = fiber;
                  else
                    for (nextFiber = fiber; null !== nextFiber; ) {
                      if (nextFiber === workInProgress) {
                        nextFiber = null;
                        break;
                      }
                      var sibling = nextFiber.sibling;
                      if (null !== sibling) {
                        (sibling.return = nextFiber.return), (nextFiber = sibling);
                        break;
                      }
                      nextFiber = nextFiber.return;
                    }
                  fiber = nextFiber;
                }
              })(workInProgress, context, changedBits, renderExpirationTime);
          }
          return (
            reconcileChildren(current, workInProgress, newProps.children, renderExpirationTime), workInProgress.child
          );
        }
        var appendAllChildren,
          updateHostComponent$1,
          updateHostText$1,
          hasWarnedAboutUsingContextAsConsumer = !1;
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = !0;
        }
        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime) {
          cancelWorkTimer(workInProgress),
            null !== current && (workInProgress.dependencies = current.dependencies),
            stopProfilerTimerIfRunning();
          var updateExpirationTime = workInProgress.expirationTime;
          return (
            0 !== updateExpirationTime && markUnprocessedUpdateTime(updateExpirationTime),
            workInProgress.childExpirationTime < renderExpirationTime
              ? null
              : ((function cloneChildFibers(current, workInProgress) {
                  if (null !== current && workInProgress.child !== current.child)
                    throw Error('Resuming work not yet implemented.');
                  if (null !== workInProgress.child) {
                    var currentChild = workInProgress.child,
                      newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
                    for (
                      workInProgress.child = newChild, newChild.return = workInProgress;
                      null !== currentChild.sibling;

                    )
                      (currentChild = currentChild.sibling),
                        ((newChild = newChild.sibling = createWorkInProgress(
                          currentChild,
                          currentChild.pendingProps
                        )).return = workInProgress);
                    newChild.sibling = null;
                  }
                })(current, workInProgress),
                workInProgress.child)
          );
        }
        function beginWork(current, workInProgress, renderExpirationTime) {
          var updateExpirationTime = workInProgress.expirationTime;
          if (workInProgress._debugNeedsRemount && null !== current)
            return (function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
              var returnFiber = oldWorkInProgress.return;
              if (null === returnFiber) throw new Error('Cannot swap the root fiber.');
              if (
                ((current.alternate = null),
                (oldWorkInProgress.alternate = null),
                (newWorkInProgress.index = oldWorkInProgress.index),
                (newWorkInProgress.sibling = oldWorkInProgress.sibling),
                (newWorkInProgress.return = oldWorkInProgress.return),
                (newWorkInProgress.ref = oldWorkInProgress.ref),
                oldWorkInProgress === returnFiber.child)
              )
                returnFiber.child = newWorkInProgress;
              else {
                var prevSibling = returnFiber.child;
                if (null === prevSibling) throw new Error('Expected parent to have a child.');
                for (; prevSibling.sibling !== oldWorkInProgress; )
                  if (null === (prevSibling = prevSibling.sibling))
                    throw new Error('Expected to find the previous sibling.');
                prevSibling.sibling = newWorkInProgress;
              }
              var last = returnFiber.lastEffect;
              return (
                null !== last
                  ? ((last.nextEffect = current), (returnFiber.lastEffect = current))
                  : (returnFiber.firstEffect = returnFiber.lastEffect = current),
                (current.nextEffect = null),
                (current.effectTag = 8),
                (newWorkInProgress.effectTag |= 2),
                newWorkInProgress
              );
            })(
              current,
              workInProgress,
              createFiberFromTypeAndProps(
                workInProgress.type,
                workInProgress.key,
                workInProgress.pendingProps,
                workInProgress._debugOwner || null,
                workInProgress.mode,
                workInProgress.expirationTime
              )
            );
          if (null !== current) {
            var oldProps = current.memoizedProps,
              newProps = workInProgress.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type)
              didReceiveUpdate = !0;
            else {
              if (updateExpirationTime < renderExpirationTime) {
                switch (((didReceiveUpdate = !1), workInProgress.tag)) {
                  case 3:
                    pushHostRootContext(workInProgress), resetHydrationState();
                    break;
                  case 5:
                    if (
                      (pushHostContext(workInProgress),
                      4 & workInProgress.mode &&
                        1 !== renderExpirationTime &&
                        shouldDeprioritizeSubtree(workInProgress.type, newProps))
                    )
                      return (
                        markSpawnedWork(1),
                        (workInProgress.expirationTime = workInProgress.childExpirationTime = 1),
                        null
                      );
                    break;
                  case 1:
                    isContextProvider(workInProgress.type) && pushContextProvider(workInProgress);
                    break;
                  case 4:
                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                    break;
                  case 10:
                    pushProvider(workInProgress, workInProgress.memoizedProps.value);
                    break;
                  case 12:
                    workInProgress.childExpirationTime >= renderExpirationTime && (workInProgress.effectTag |= 4);
                    break;
                  case 13:
                    if (null !== workInProgress.memoizedState) {
                      var primaryChildExpirationTime = workInProgress.child.childExpirationTime;
                      if (0 !== primaryChildExpirationTime && primaryChildExpirationTime >= renderExpirationTime)
                        return updateSuspenseComponent(current, workInProgress, renderExpirationTime);
                      pushSuspenseContext(
                        workInProgress,
                        setDefaultShallowSuspenseContext(suspenseStackCursor.current)
                      );
                      var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
                      return null !== child ? child.sibling : null;
                    }
                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    break;
                  case 19:
                    var didSuspendBefore = 0 != (64 & current.effectTag),
                      _hasChildWork = workInProgress.childExpirationTime >= renderExpirationTime;
                    if (didSuspendBefore) {
                      if (_hasChildWork)
                        return updateSuspenseListComponent(current, workInProgress, renderExpirationTime);
                      workInProgress.effectTag |= 64;
                    }
                    var renderState = workInProgress.memoizedState;
                    if (
                      (null !== renderState && ((renderState.rendering = null), (renderState.tail = null)),
                      pushSuspenseContext(workInProgress, suspenseStackCursor.current),
                      _hasChildWork)
                    )
                      break;
                    return null;
                }
                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);
              }
              didReceiveUpdate = !1;
            }
          } else didReceiveUpdate = !1;
          switch (((workInProgress.expirationTime = 0), workInProgress.tag)) {
            case 2:
              return (function mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {
                null !== _current &&
                  ((_current.alternate = null), (workInProgress.alternate = null), (workInProgress.effectTag |= 2));
                var context,
                  value,
                  props = workInProgress.pendingProps;
                if (
                  ((context = getMaskedContext(workInProgress, getUnmaskedContext(0, Component, !1))),
                  prepareToReadContext(workInProgress, renderExpirationTime),
                  Component.prototype && 'function' == typeof Component.prototype.render)
                ) {
                  var componentName = getComponentName(Component) || 'Unknown';
                  didWarnAboutBadClass[componentName] ||
                    (error(
                      "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                      componentName,
                      componentName
                    ),
                    (didWarnAboutBadClass[componentName] = !0));
                }
                if (
                  (1 & workInProgress.mode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null),
                  setIsRendering(!0),
                  (ReactCurrentOwner$1.current = workInProgress),
                  (value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime)),
                  setIsRendering(!1),
                  (workInProgress.effectTag |= 1),
                  'object' == typeof value &&
                    null !== value &&
                    'function' == typeof value.render &&
                    void 0 === value.$$typeof)
                ) {
                  var _componentName = getComponentName(Component) || 'Unknown';
                  didWarnAboutModulePatternComponent[_componentName] ||
                    (error(
                      "The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
                      _componentName,
                      _componentName,
                      _componentName
                    ),
                    (didWarnAboutModulePatternComponent[_componentName] = !0)),
                    (workInProgress.tag = 1),
                    (workInProgress.memoizedState = null),
                    (workInProgress.updateQueue = null);
                  var hasContext = !1;
                  isContextProvider(Component)
                    ? ((hasContext = !0), pushContextProvider(workInProgress))
                    : (hasContext = !1),
                    (workInProgress.memoizedState =
                      null !== value.state && void 0 !== value.state ? value.state : null),
                    initializeUpdateQueue(workInProgress);
                  var getDerivedStateFromProps = Component.getDerivedStateFromProps;
                  return (
                    'function' == typeof getDerivedStateFromProps &&
                      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props),
                    adoptClassInstance(workInProgress, value),
                    mountClassInstance(workInProgress, Component, props, renderExpirationTime),
                    finishClassComponent(null, workInProgress, Component, !0, hasContext, renderExpirationTime)
                  );
                }
                return (
                  (workInProgress.tag = 0),
                  1 & workInProgress.mode &&
                    null !== workInProgress.memoizedState &&
                    (value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime)),
                  reconcileChildren(null, workInProgress, value, renderExpirationTime),
                  validateFunctionComponentInDev(workInProgress, Component),
                  workInProgress.child
                );
              })(current, workInProgress, workInProgress.type, renderExpirationTime);
            case 16:
              return mountLazyComponent(
                current,
                workInProgress,
                workInProgress.elementType,
                updateExpirationTime,
                renderExpirationTime
              );
            case 0:
              var _Component = workInProgress.type,
                unresolvedProps = workInProgress.pendingProps;
              return updateFunctionComponent(
                current,
                workInProgress,
                _Component,
                workInProgress.elementType === _Component
                  ? unresolvedProps
                  : resolveDefaultProps(_Component, unresolvedProps),
                renderExpirationTime
              );
            case 1:
              var _Component2 = workInProgress.type,
                _unresolvedProps = workInProgress.pendingProps;
              return updateClassComponent(
                current,
                workInProgress,
                _Component2,
                workInProgress.elementType === _Component2
                  ? _unresolvedProps
                  : resolveDefaultProps(_Component2, _unresolvedProps),
                renderExpirationTime
              );
            case 3:
              return updateHostRoot(current, workInProgress, renderExpirationTime);
            case 5:
              return (function updateHostComponent(current, workInProgress, renderExpirationTime) {
                pushHostContext(workInProgress), null === current && tryToClaimNextHydratableInstance(workInProgress);
                var type = workInProgress.type,
                  nextProps = workInProgress.pendingProps,
                  prevProps = null !== current ? current.memoizedProps : null,
                  nextChildren = nextProps.children;
                return (
                  shouldSetTextContent(type, nextProps)
                    ? (nextChildren = null)
                    : null !== prevProps && shouldSetTextContent(type, prevProps) && (workInProgress.effectTag |= 16),
                  markRef(current, workInProgress),
                  4 & workInProgress.mode && 1 !== renderExpirationTime && shouldDeprioritizeSubtree(0, nextProps)
                    ? (markSpawnedWork(1),
                      (workInProgress.expirationTime = workInProgress.childExpirationTime = 1),
                      null)
                    : (reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime),
                      workInProgress.child)
                );
              })(current, workInProgress, renderExpirationTime);
            case 6:
              return (function updateHostText(current, workInProgress) {
                return null === current && tryToClaimNextHydratableInstance(workInProgress), null;
              })(current, workInProgress);
            case 13:
              return updateSuspenseComponent(current, workInProgress, renderExpirationTime);
            case 4:
              return (function updatePortalComponent(current, workInProgress, renderExpirationTime) {
                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                var nextChildren = workInProgress.pendingProps;
                return (
                  null === current
                    ? (workInProgress.child = reconcileChildFibers(
                        workInProgress,
                        null,
                        nextChildren,
                        renderExpirationTime
                      ))
                    : reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime),
                  workInProgress.child
                );
              })(current, workInProgress, renderExpirationTime);
            case 11:
              var type = workInProgress.type,
                _unresolvedProps2 = workInProgress.pendingProps;
              return updateForwardRef(
                current,
                workInProgress,
                type,
                workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2),
                renderExpirationTime
              );
            case 7:
              return (function updateFragment(current, workInProgress, renderExpirationTime) {
                return (
                  reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderExpirationTime),
                  workInProgress.child
                );
              })(current, workInProgress, renderExpirationTime);
            case 8:
              return (function updateMode(current, workInProgress, renderExpirationTime) {
                return (
                  reconcileChildren(
                    current,
                    workInProgress,
                    workInProgress.pendingProps.children,
                    renderExpirationTime
                  ),
                  workInProgress.child
                );
              })(current, workInProgress, renderExpirationTime);
            case 12:
              return (function updateProfiler(current, workInProgress, renderExpirationTime) {
                return (
                  (workInProgress.effectTag |= 4),
                  reconcileChildren(
                    current,
                    workInProgress,
                    workInProgress.pendingProps.children,
                    renderExpirationTime
                  ),
                  workInProgress.child
                );
              })(current, workInProgress, renderExpirationTime);
            case 10:
              return updateContextProvider(current, workInProgress, renderExpirationTime);
            case 9:
              return (function updateContextConsumer(current, workInProgress, renderExpirationTime) {
                var context = workInProgress.type;
                void 0 === context._context
                  ? context !== context.Consumer &&
                    (hasWarnedAboutUsingContextAsConsumer ||
                      ((hasWarnedAboutUsingContextAsConsumer = !0),
                      error(
                        'Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?'
                      )))
                  : (context = context._context);
                var newProps = workInProgress.pendingProps,
                  render = newProps.children;
                'function' != typeof render &&
                  error(
                    "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                  ),
                  prepareToReadContext(workInProgress, renderExpirationTime);
                var newChildren,
                  newValue = readContext(context, newProps.unstable_observedBits);
                return (
                  (ReactCurrentOwner$1.current = workInProgress),
                  setIsRendering(!0),
                  (newChildren = render(newValue)),
                  setIsRendering(!1),
                  (workInProgress.effectTag |= 1),
                  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime),
                  workInProgress.child
                );
              })(current, workInProgress, renderExpirationTime);
            case 14:
              var _type2 = workInProgress.type,
                _resolvedProps3 = resolveDefaultProps(_type2, workInProgress.pendingProps);
              if (workInProgress.type !== workInProgress.elementType) {
                var outerPropTypes = _type2.propTypes;
                outerPropTypes &&
                  checkPropTypes(
                    outerPropTypes,
                    _resolvedProps3,
                    'prop',
                    getComponentName(_type2),
                    getCurrentFiberStackInDev
                  );
              }
              return updateMemoComponent(
                current,
                workInProgress,
                _type2,
                (_resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3)),
                updateExpirationTime,
                renderExpirationTime
              );
            case 15:
              return updateSimpleMemoComponent(
                current,
                workInProgress,
                workInProgress.type,
                workInProgress.pendingProps,
                updateExpirationTime,
                renderExpirationTime
              );
            case 17:
              var _Component3 = workInProgress.type,
                _unresolvedProps4 = workInProgress.pendingProps;
              return (function mountIncompleteClassComponent(
                _current,
                workInProgress,
                Component,
                nextProps,
                renderExpirationTime
              ) {
                var hasContext;
                return (
                  null !== _current &&
                    ((_current.alternate = null), (workInProgress.alternate = null), (workInProgress.effectTag |= 2)),
                  (workInProgress.tag = 1),
                  isContextProvider(Component)
                    ? ((hasContext = !0), pushContextProvider(workInProgress))
                    : (hasContext = !1),
                  prepareToReadContext(workInProgress, renderExpirationTime),
                  constructClassInstance(workInProgress, Component, nextProps),
                  mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime),
                  finishClassComponent(null, workInProgress, Component, !0, hasContext, renderExpirationTime)
                );
              })(
                current,
                workInProgress,
                _Component3,
                workInProgress.elementType === _Component3
                  ? _unresolvedProps4
                  : resolveDefaultProps(_Component3, _unresolvedProps4),
                renderExpirationTime
              );
            case 19:
              return updateSuspenseListComponent(current, workInProgress, renderExpirationTime);
          }
          throw Error(
            'Unknown unit of work tag (' +
              workInProgress.tag +
              '). This error is likely caused by a bug in React. Please file an issue.'
          );
        }
        function markUpdate(workInProgress) {
          workInProgress.effectTag |= 4;
        }
        function markRef$1(workInProgress) {
          workInProgress.effectTag |= 128;
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          switch (renderState.tailMode) {
            case 'hidden':
              for (var tailNode = renderState.tail, lastTailNode = null; null !== tailNode; )
                null !== tailNode.alternate && (lastTailNode = tailNode), (tailNode = tailNode.sibling);
              null === lastTailNode ? (renderState.tail = null) : (lastTailNode.sibling = null);
              break;
            case 'collapsed':
              for (var _tailNode = renderState.tail, _lastTailNode = null; null !== _tailNode; )
                null !== _tailNode.alternate && (_lastTailNode = _tailNode), (_tailNode = _tailNode.sibling);
              null === _lastTailNode
                ? hasRenderedATailFallback || null === renderState.tail
                  ? (renderState.tail = null)
                  : (renderState.tail.sibling = null)
                : (_lastTailNode.sibling = null);
          }
        }
        function completeWork(current, workInProgress, renderExpirationTime) {
          var newProps = workInProgress.pendingProps;
          switch (workInProgress.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return null;
            case 1:
              return isContextProvider(workInProgress.type) && popContext(workInProgress), null;
            case 3:
              popHostContainer(workInProgress), popTopLevelContextObject(workInProgress);
              var fiberRoot = workInProgress.stateNode;
              if (
                (fiberRoot.pendingContext &&
                  ((fiberRoot.context = fiberRoot.pendingContext), (fiberRoot.pendingContext = null)),
                null === current || null === current.child)
              )
                popHydrationState(workInProgress) && markUpdate(workInProgress);
              return null;
            case 5:
              popHostContext(workInProgress);
              var rootContainerInstance = getRootHostContainer(),
                type = workInProgress.type;
              if (null !== current && null != workInProgress.stateNode)
                updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance),
                  current.ref !== workInProgress.ref && markRef$1(workInProgress);
              else {
                if (!newProps) {
                  if (null === workInProgress.stateNode)
                    throw Error(
                      'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
                    );
                  return null;
                }
                var currentHostContext = getHostContext();
                if (popHydrationState(workInProgress))
                  (function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
                    var updatePayload = hydrateInstance(
                      fiber.stateNode,
                      fiber.type,
                      fiber.memoizedProps,
                      rootContainerInstance,
                      hostContext,
                      fiber
                    );
                    return (fiber.updateQueue = updatePayload), null !== updatePayload;
                  })(workInProgress, rootContainerInstance, currentHostContext) && markUpdate(workInProgress);
                else {
                  var instance = createInstance(
                    type,
                    newProps,
                    rootContainerInstance,
                    currentHostContext,
                    workInProgress
                  );
                  appendAllChildren(instance, workInProgress),
                    (workInProgress.stateNode = instance),
                    (function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
                      return (
                        setInitialProperties(domElement, type, props, rootContainerInstance),
                        shouldAutoFocusHostComponent(type, props)
                      );
                    })(instance, type, newProps, rootContainerInstance) && markUpdate(workInProgress);
                }
                null !== workInProgress.ref && markRef$1(workInProgress);
              }
              return null;
            case 6:
              var newText = newProps;
              if (current && null != workInProgress.stateNode) {
                var oldText = current.memoizedProps;
                updateHostText$1(0, workInProgress, oldText, newText);
              } else {
                if ('string' != typeof newText && null === workInProgress.stateNode)
                  throw Error(
                    'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
                  );
                var _rootContainerInstance = getRootHostContainer(),
                  _currentHostContext = getHostContext();
                popHydrationState(workInProgress)
                  ? prepareToHydrateHostTextInstance(workInProgress) && markUpdate(workInProgress)
                  : (workInProgress.stateNode = createTextInstance(
                      newText,
                      _rootContainerInstance,
                      _currentHostContext,
                      workInProgress
                    ));
              }
              return null;
            case 13:
              popSuspenseContext(workInProgress);
              var nextState = workInProgress.memoizedState;
              if (0 != (64 & workInProgress.effectTag))
                return (workInProgress.expirationTime = renderExpirationTime), workInProgress;
              var nextDidTimeout = null !== nextState,
                prevDidTimeout = !1;
              if (null === current)
                void 0 !== workInProgress.memoizedProps.fallback && popHydrationState(workInProgress);
              else {
                var prevState = current.memoizedState;
                if (((prevDidTimeout = null !== prevState), !nextDidTimeout && null !== prevState)) {
                  var currentFallbackChild = current.child.sibling;
                  if (null !== currentFallbackChild) {
                    var first = workInProgress.firstEffect;
                    null !== first
                      ? ((workInProgress.firstEffect = currentFallbackChild), (currentFallbackChild.nextEffect = first))
                      : ((workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild),
                        (currentFallbackChild.nextEffect = null)),
                      (currentFallbackChild.effectTag = 8);
                  }
                }
              }
              if (nextDidTimeout && !prevDidTimeout)
                if (0 != (2 & workInProgress.mode))
                  (null === current && !0 !== workInProgress.memoizedProps.unstable_avoidThisFallback) ||
                  hasSuspenseContext(suspenseStackCursor.current, 1)
                    ? (function renderDidSuspend() {
                        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3);
                      })()
                    : (function renderDidSuspendDelayIfPossible() {
                        (0 !== workInProgressRootExitStatus && 3 !== workInProgressRootExitStatus) ||
                          (workInProgressRootExitStatus = 4);
                        0 !== workInProgressRootNextUnprocessedUpdateTime &&
                          null !== workInProgressRoot &&
                          (markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime$1),
                          markRootUpdatedAtTime(workInProgressRoot, workInProgressRootNextUnprocessedUpdateTime));
                      })();
              return (nextDidTimeout || prevDidTimeout) && (workInProgress.effectTag |= 4), null;
            case 4:
              return popHostContainer(workInProgress), null;
            case 10:
              return popProvider(workInProgress), null;
            case 17:
              return isContextProvider(workInProgress.type) && popContext(workInProgress), null;
            case 19:
              popSuspenseContext(workInProgress);
              var renderState = workInProgress.memoizedState;
              if (null === renderState) return null;
              var didSuspendAlready = 0 != (64 & workInProgress.effectTag),
                renderedTail = renderState.rendering;
              if (null === renderedTail) {
                if (didSuspendAlready) cutOffTailIfNeeded(renderState, !1);
                else if (
                  !(
                    (function renderHasNotSuspendedYet() {
                      return 0 === workInProgressRootExitStatus;
                    })() &&
                    (null === current || 0 == (64 & current.effectTag))
                  )
                )
                  for (var row = workInProgress.child; null !== row; ) {
                    var suspended = findFirstSuspended(row);
                    if (null !== suspended) {
                      (didSuspendAlready = !0), (workInProgress.effectTag |= 64), cutOffTailIfNeeded(renderState, !1);
                      var newThennables = suspended.updateQueue;
                      return (
                        null !== newThennables &&
                          ((workInProgress.updateQueue = newThennables), (workInProgress.effectTag |= 4)),
                        null === renderState.lastEffect && (workInProgress.firstEffect = null),
                        (workInProgress.lastEffect = renderState.lastEffect),
                        resetChildFibers(workInProgress, renderExpirationTime),
                        pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, 2)),
                        workInProgress.child
                      );
                    }
                    row = row.sibling;
                  }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (null !== _suspended) {
                    (workInProgress.effectTag |= 64), (didSuspendAlready = !0);
                    var _newThennables = _suspended.updateQueue;
                    if (
                      (null !== _newThennables &&
                        ((workInProgress.updateQueue = _newThennables), (workInProgress.effectTag |= 4)),
                      cutOffTailIfNeeded(renderState, !0),
                      null === renderState.tail && 'hidden' === renderState.tailMode && !renderedTail.alternate)
                    ) {
                      var lastEffect = (workInProgress.lastEffect = renderState.lastEffect);
                      return null !== lastEffect && (lastEffect.nextEffect = null), null;
                    }
                  } else if (
                    2 * now() - renderState.renderingStartTime > renderState.tailExpiration &&
                    renderExpirationTime > 1
                  ) {
                    (workInProgress.effectTag |= 64), (didSuspendAlready = !0), cutOffTailIfNeeded(renderState, !1);
                    var nextPriority = renderExpirationTime - 1;
                    (workInProgress.expirationTime = workInProgress.childExpirationTime = nextPriority),
                      markSpawnedWork(nextPriority);
                  }
                }
                if (renderState.isBackwards)
                  (renderedTail.sibling = workInProgress.child), (workInProgress.child = renderedTail);
                else {
                  var previousSibling = renderState.last;
                  null !== previousSibling
                    ? (previousSibling.sibling = renderedTail)
                    : (workInProgress.child = renderedTail),
                    (renderState.last = renderedTail);
                }
              }
              if (null !== renderState.tail) {
                if (0 === renderState.tailExpiration) {
                  renderState.tailExpiration = now() + 500;
                }
                var next = renderState.tail;
                (renderState.rendering = next),
                  (renderState.tail = next.sibling),
                  (renderState.lastEffect = workInProgress.lastEffect),
                  (renderState.renderingStartTime = now()),
                  (next.sibling = null);
                var suspenseContext = suspenseStackCursor.current;
                return (
                  pushSuspenseContext(
                    workInProgress,
                    (suspenseContext = didSuspendAlready
                      ? setShallowSuspenseContext(suspenseContext, 2)
                      : setDefaultShallowSuspenseContext(suspenseContext))
                  ),
                  next
                );
              }
              return null;
          }
          throw Error(
            'Unknown unit of work tag (' +
              workInProgress.tag +
              '). This error is likely caused by a bug in React. Please file an issue.'
          );
        }
        function unwindWork(workInProgress, renderExpirationTime) {
          switch (workInProgress.tag) {
            case 1:
              isContextProvider(workInProgress.type) && popContext(workInProgress);
              var effectTag = workInProgress.effectTag;
              return 4096 & effectTag ? ((workInProgress.effectTag = (-4097 & effectTag) | 64), workInProgress) : null;
            case 3:
              popHostContainer(workInProgress), popTopLevelContextObject(workInProgress);
              var _effectTag = workInProgress.effectTag;
              if (0 != (64 & _effectTag))
                throw Error(
                  'The root failed to unmount after an error. This is likely a bug in React. Please file an issue.'
                );
              return (workInProgress.effectTag = (-4097 & _effectTag) | 64), workInProgress;
            case 5:
              return popHostContext(workInProgress), null;
            case 13:
              popSuspenseContext(workInProgress);
              var _effectTag2 = workInProgress.effectTag;
              return 4096 & _effectTag2
                ? ((workInProgress.effectTag = (-4097 & _effectTag2) | 64), workInProgress)
                : null;
            case 19:
              return popSuspenseContext(workInProgress), null;
            case 4:
              return popHostContainer(workInProgress), null;
            case 10:
              return popProvider(workInProgress), null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(interruptedWork) {
          switch (interruptedWork.tag) {
            case 1:
              var childContextTypes = interruptedWork.type.childContextTypes;
              null != childContextTypes && popContext(interruptedWork);
              break;
            case 3:
              popHostContainer(interruptedWork), popTopLevelContextObject(interruptedWork);
              break;
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 13:
            case 19:
              popSuspenseContext(interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork);
          }
        }
        function createCapturedValue(value, source) {
          return { value, source, stack: getStackByFiberInDevAndProd(source) };
        }
        (appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {
          for (var parentInstance, child, node = workInProgress.child; null !== node; ) {
            if (5 === node.tag || 6 === node.tag)
              (parentInstance = parent), (child = node.stateNode), parentInstance.appendChild(child);
            else if (4 === node.tag);
            else if (null !== node.child) {
              (node.child.return = node), (node = node.child);
              continue;
            }
            if (node === workInProgress) return;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === workInProgress) return;
              node = node.return;
            }
            (node.sibling.return = node.return), (node = node.sibling);
          }
        }),
          (updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {
            var oldProps = current.memoizedProps;
            if (oldProps !== newProps) {
              var updatePayload = (function prepareUpdate(
                domElement,
                type,
                oldProps,
                newProps,
                rootContainerInstance,
                hostContext
              ) {
                var hostContextDev = hostContext;
                if (
                  typeof newProps.children != typeof oldProps.children &&
                  ('string' == typeof newProps.children || 'number' == typeof newProps.children)
                ) {
                  var string = '' + newProps.children,
                    ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                  validateDOMNesting(null, string, ownAncestorInfo);
                }
                return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
              })(workInProgress.stateNode, type, oldProps, newProps, rootContainerInstance, getHostContext());
              (workInProgress.updateQueue = updatePayload), updatePayload && markUpdate(workInProgress);
            }
          }),
          (updateHostText$1 = function (current, workInProgress, oldText, newText) {
            oldText !== newText && markUpdate(workInProgress);
          });
        var didWarnAboutUndefinedSnapshotBeforeUpdate;
        didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
        var PossiblyWeakSet = 'function' == typeof WeakSet ? WeakSet : Set;
        function logError(boundary, errorInfo) {
          var source = errorInfo.source,
            stack = errorInfo.stack;
          null === stack && null !== source && (stack = getStackByFiberInDevAndProd(source));
          var capturedError = {
            componentName: null !== source ? getComponentName(source.type) : null,
            componentStack: null !== stack ? stack : '',
            error: errorInfo.value,
            errorBoundary: null,
            errorBoundaryName: null,
            errorBoundaryFound: !1,
            willRetry: !1,
          };
          null !== boundary &&
            1 === boundary.tag &&
            ((capturedError.errorBoundary = boundary.stateNode),
            (capturedError.errorBoundaryName = getComponentName(boundary.type)),
            (capturedError.errorBoundaryFound = !0),
            (capturedError.willRetry = !0));
          try {
            !(function logCapturedError(capturedError) {
              var error = capturedError.error,
                componentName = capturedError.componentName,
                componentStack = capturedError.componentStack,
                errorBoundaryName = capturedError.errorBoundaryName,
                errorBoundaryFound = capturedError.errorBoundaryFound,
                willRetry = capturedError.willRetry;
              if (null != error && error._suppressLogging) {
                if (errorBoundaryFound && willRetry) return;
                console.error(error);
              }
              var combinedMessage =
                '' +
                (componentName
                  ? 'The above error occurred in the <' + componentName + '> component:'
                  : 'The above error occurred in one of your React components:') +
                componentStack +
                '\n\n' +
                (errorBoundaryFound && errorBoundaryName
                  ? willRetry
                    ? 'React will try to recreate this component tree from scratch using the error boundary you provided, ' +
                      errorBoundaryName +
                      '.'
                    : 'This error was initially handled by the error boundary ' +
                      errorBoundaryName +
                      '.\nRecreating the tree from scratch failed so React will unmount the tree.'
                  : 'Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://fb.me/react-error-boundaries to learn more about error boundaries.');
              console.error(combinedMessage);
            })(capturedError);
          } catch (e) {
            setTimeout(function () {
              throw e;
            });
          }
        }
        var callComponentWillUnmountWithTimer = function (current, instance) {
          startPhaseTimer(current, 'componentWillUnmount'),
            (instance.props = current.memoizedProps),
            (instance.state = current.memoizedState),
            instance.componentWillUnmount(),
            stopPhaseTimer();
        };
        function safelyDetachRef(current) {
          var ref = current.ref;
          null !== ref &&
            ('function' == typeof ref
              ? (invokeGuardedCallback(null, ref, null, null),
                hasCaughtError() && captureCommitPhaseError(current, clearCaughtError()))
              : (ref.current = null));
        }
        function safelyCallDestroy(current, destroy) {
          (invokeGuardedCallback(null, destroy, null), hasCaughtError()) &&
            captureCommitPhaseError(current, clearCaughtError());
        }
        function commitBeforeMutationLifeCycles(current, finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
            case 22:
              return;
            case 1:
              if (256 & finishedWork.effectTag && null !== current) {
                var prevProps = current.memoizedProps,
                  prevState = current.memoizedState;
                startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');
                var instance = finishedWork.stateNode;
                finishedWork.type !== finishedWork.elementType ||
                  didWarnAboutReassigningProps ||
                  (instance.props !== finishedWork.memoizedProps &&
                    error(
                      'Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      getComponentName(finishedWork.type) || 'instance'
                    ),
                  instance.state !== finishedWork.memoizedState &&
                    error(
                      'Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      getComponentName(finishedWork.type) || 'instance'
                    ));
                var snapshot = instance.getSnapshotBeforeUpdate(
                    finishedWork.elementType === finishedWork.type
                      ? prevProps
                      : resolveDefaultProps(finishedWork.type, prevProps),
                    prevState
                  ),
                  didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                void 0 !== snapshot ||
                  didWarnSet.has(finishedWork.type) ||
                  (didWarnSet.add(finishedWork.type),
                  error(
                    '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.',
                    getComponentName(finishedWork.type)
                  )),
                  (instance.__reactInternalSnapshotBeforeUpdate = snapshot),
                  stopPhaseTimer();
              }
              return;
            case 3:
            case 5:
            case 6:
            case 4:
            case 17:
              return;
          }
          throw Error(
            'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
          );
        }
        function commitHookEffectListUnmount(tag, finishedWork) {
          var updateQueue = finishedWork.updateQueue,
            lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next,
              effect = firstEffect;
            do {
              if ((effect.tag & tag) === tag) {
                var destroy = effect.destroy;
                (effect.destroy = void 0), void 0 !== destroy && destroy();
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(tag, finishedWork) {
          var updateQueue = finishedWork.updateQueue,
            lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next,
              effect = firstEffect;
            do {
              if ((effect.tag & tag) === tag) {
                var create = effect.create;
                effect.destroy = create();
                var destroy = effect.destroy;
                if (void 0 !== destroy && 'function' != typeof destroy) {
                  error(
                    'An effect function must not return anything besides a function, which is used for clean-up.%s%s',
                    null === destroy
                      ? ' You returned null. If your effect does not require clean up, return undefined (or nothing).'
                      : 'function' == typeof destroy.then
                      ? "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"
                      : ' You returned: ' + destroy,
                    getStackByFiberInDevAndProd(finishedWork)
                  );
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitPassiveHookEffects(finishedWork) {
          if (0 != (512 & finishedWork.effectTag))
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
              case 22:
                commitHookEffectListUnmount(5, finishedWork), commitHookEffectListMount(5, finishedWork);
            }
        }
        function commitLifeCycles(finishedRoot, current, finishedWork, committedExpirationTime) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
            case 22:
              return void commitHookEffectListMount(3, finishedWork);
            case 1:
              var instance = finishedWork.stateNode;
              if (4 & finishedWork.effectTag)
                if (null === current)
                  startPhaseTimer(finishedWork, 'componentDidMount'),
                    finishedWork.type !== finishedWork.elementType ||
                      didWarnAboutReassigningProps ||
                      (instance.props !== finishedWork.memoizedProps &&
                        error(
                          'Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                          getComponentName(finishedWork.type) || 'instance'
                        ),
                      instance.state !== finishedWork.memoizedState &&
                        error(
                          'Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                          getComponentName(finishedWork.type) || 'instance'
                        )),
                    instance.componentDidMount(),
                    stopPhaseTimer();
                else {
                  var prevProps =
                      finishedWork.elementType === finishedWork.type
                        ? current.memoizedProps
                        : resolveDefaultProps(finishedWork.type, current.memoizedProps),
                    prevState = current.memoizedState;
                  startPhaseTimer(finishedWork, 'componentDidUpdate'),
                    finishedWork.type !== finishedWork.elementType ||
                      didWarnAboutReassigningProps ||
                      (instance.props !== finishedWork.memoizedProps &&
                        error(
                          'Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                          getComponentName(finishedWork.type) || 'instance'
                        ),
                      instance.state !== finishedWork.memoizedState &&
                        error(
                          'Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                          getComponentName(finishedWork.type) || 'instance'
                        )),
                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate),
                    stopPhaseTimer();
                }
              var updateQueue = finishedWork.updateQueue;
              return void (
                null !== updateQueue &&
                (finishedWork.type !== finishedWork.elementType ||
                  didWarnAboutReassigningProps ||
                  (instance.props !== finishedWork.memoizedProps &&
                    error(
                      'Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      getComponentName(finishedWork.type) || 'instance'
                    ),
                  instance.state !== finishedWork.memoizedState &&
                    error(
                      'Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.',
                      getComponentName(finishedWork.type) || 'instance'
                    )),
                commitUpdateQueue(0, updateQueue, instance))
              );
            case 3:
              var _updateQueue = finishedWork.updateQueue;
              if (null !== _updateQueue) {
                var _instance = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 5:
                    case 1:
                      _instance = finishedWork.child.stateNode;
                  }
                commitUpdateQueue(0, _updateQueue, _instance);
              }
              return;
            case 5:
              var _instance2 = finishedWork.stateNode;
              if (null === current && 4 & finishedWork.effectTag)
                !(function commitMount(domElement, type, newProps, internalInstanceHandle) {
                  shouldAutoFocusHostComponent(type, newProps) && domElement.focus();
                })(_instance2, finishedWork.type, finishedWork.memoizedProps);
              return;
            case 6:
            case 4:
              return;
            case 12:
              var onRender = finishedWork.memoizedProps.onRender;
              return void (
                'function' == typeof onRender &&
                onRender(
                  finishedWork.memoizedProps.id,
                  null === current ? 'mount' : 'update',
                  finishedWork.actualDuration,
                  finishedWork.treeBaseDuration,
                  finishedWork.actualStartTime,
                  (function getCommitTime() {
                    return commitTime;
                  })(),
                  finishedRoot.memoizedInteractions
                )
              );
            case 13:
              return void (function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
                if (null === finishedWork.memoizedState) {
                  var current = finishedWork.alternate;
                  if (null !== current) {
                    var prevState = current.memoizedState;
                    if (null !== prevState) {
                      var suspenseInstance = prevState.dehydrated;
                      null !== suspenseInstance &&
                        (function commitHydratedSuspenseInstance(suspenseInstance) {
                          retryIfBlockedOn(suspenseInstance);
                        })(suspenseInstance);
                    }
                  }
                }
              })(0, finishedWork);
            case 19:
            case 17:
            case 20:
            case 21:
              return;
          }
          throw Error(
            'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            var instanceToUse,
              instance = finishedWork.stateNode;
            switch (finishedWork.tag) {
              case 5:
                instanceToUse = instance;
                break;
              default:
                instanceToUse = instance;
            }
            'function' == typeof ref
              ? ref(instanceToUse)
              : (ref.hasOwnProperty('current') ||
                  error(
                    'Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().%s',
                    getComponentName(finishedWork.type),
                    getStackByFiberInDevAndProd(finishedWork)
                  ),
                (ref.current = instanceToUse));
          }
        }
        function commitDetachRef(current) {
          var currentRef = current.ref;
          null !== currentRef && ('function' == typeof currentRef ? currentRef(null) : (currentRef.current = null));
        }
        function commitUnmount(finishedRoot, current, renderPriorityLevel) {
          switch (
            ((function onCommitUnmount(fiber) {
              'function' == typeof onCommitFiberUnmount && onCommitFiberUnmount(fiber);
            })(current),
            current.tag)
          ) {
            case 0:
            case 11:
            case 14:
            case 15:
            case 22:
              var updateQueue = current.updateQueue;
              if (null !== updateQueue) {
                var lastEffect = updateQueue.lastEffect;
                if (null !== lastEffect) {
                  var firstEffect = lastEffect.next;
                  runWithPriority$1(renderPriorityLevel > 97 ? 97 : renderPriorityLevel, function () {
                    var effect = firstEffect;
                    do {
                      var _destroy = effect.destroy;
                      void 0 !== _destroy && safelyCallDestroy(current, _destroy), (effect = effect.next);
                    } while (effect !== firstEffect);
                  });
                }
              }
              return;
            case 1:
              safelyDetachRef(current);
              var instance = current.stateNode;
              return void (
                'function' == typeof instance.componentWillUnmount &&
                (function safelyCallComponentWillUnmount(current, instance) {
                  invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance),
                    hasCaughtError() && captureCommitPhaseError(current, clearCaughtError());
                })(current, instance)
              );
            case 5:
              return void safelyDetachRef(current);
            case 4:
              return void unmountHostComponents(finishedRoot, current, renderPriorityLevel);
            case 20:
            case 18:
            case 21:
              return;
          }
        }
        function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
          for (var node = root; ; )
            if ((commitUnmount(finishedRoot, node, renderPriorityLevel), null === node.child || 4 === node.tag)) {
              if (node === root) return;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === root) return;
                node = node.return;
              }
              (node.sibling.return = node.return), (node = node.sibling);
            } else (node.child.return = node), (node = node.child);
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
        }
        function commitPlacement(finishedWork) {
          var parent,
            isContainer,
            parentFiber = (function getHostParentFiber(fiber) {
              for (var parent = fiber.return; null !== parent; ) {
                if (isHostParent(parent)) return parent;
                parent = parent.return;
              }
              throw Error(
                'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
              );
            })(finishedWork),
            parentStateNode = parentFiber.stateNode;
          switch (parentFiber.tag) {
            case 5:
              (parent = parentStateNode), (isContainer = !1);
              break;
            case 3:
            case 4:
              (parent = parentStateNode.containerInfo), (isContainer = !0);
              break;
            case 20:
            default:
              throw Error(
                'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.'
              );
          }
          16 & parentFiber.effectTag && (resetTextContent(parent), (parentFiber.effectTag &= -17));
          var before = (function getHostSibling(fiber) {
            var node = fiber;
            siblings: for (;;) {
              for (; null === node.sibling; ) {
                if (null === node.return || isHostParent(node.return)) return null;
                node = node.return;
              }
              for (
                node.sibling.return = node.return, node = node.sibling;
                5 !== node.tag && 6 !== node.tag && 18 !== node.tag;

              ) {
                if (2 & node.effectTag) continue siblings;
                if (null === node.child || 4 === node.tag) continue siblings;
                (node.child.return = node), (node = node.child);
              }
              if (!(2 & node.effectTag)) return node.stateNode;
            }
          })(finishedWork);
          isContainer
            ? (function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
                var tag = node.tag,
                  isHost = 5 === tag || 6 === tag;
                if (isHost) {
                  var stateNode = isHost ? node.stateNode : node.stateNode.instance;
                  before
                    ? (function insertInContainerBefore(container, child, beforeChild) {
                        8 === container.nodeType
                          ? container.parentNode.insertBefore(child, beforeChild)
                          : container.insertBefore(child, beforeChild);
                      })(parent, stateNode, before)
                    : (function appendChildToContainer(container, child) {
                        var parentNode;
                        8 === container.nodeType
                          ? (parentNode = container.parentNode).insertBefore(child, container)
                          : (parentNode = container).appendChild(child);
                        var reactRootContainer = container._reactRootContainer;
                        null == reactRootContainer &&
                          null === parentNode.onclick &&
                          trapClickOnNonInteractiveElement(parentNode);
                      })(parent, stateNode);
                } else if (4 === tag);
                else {
                  var child = node.child;
                  if (null !== child) {
                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                    for (var sibling = child.sibling; null !== sibling; )
                      insertOrAppendPlacementNodeIntoContainer(sibling, before, parent), (sibling = sibling.sibling);
                  }
                }
              })(finishedWork, before, parent)
            : (function insertOrAppendPlacementNode(node, before, parent) {
                var tag = node.tag,
                  isHost = 5 === tag || 6 === tag;
                if (isHost) {
                  var stateNode = isHost ? node.stateNode : node.stateNode.instance;
                  before
                    ? (function insertBefore(parentInstance, child, beforeChild) {
                        parentInstance.insertBefore(child, beforeChild);
                      })(parent, stateNode, before)
                    : (function appendChild(parentInstance, child) {
                        parentInstance.appendChild(child);
                      })(parent, stateNode);
                } else if (4 === tag);
                else {
                  var child = node.child;
                  if (null !== child) {
                    insertOrAppendPlacementNode(child, before, parent);
                    for (var sibling = child.sibling; null !== sibling; )
                      insertOrAppendPlacementNode(sibling, before, parent), (sibling = sibling.sibling);
                  }
                }
              })(finishedWork, before, parent);
        }
        function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
          for (
            var currentParent, currentParentIsContainer, container, child, node = current, currentParentIsValid = !1;
            ;

          ) {
            if (!currentParentIsValid) {
              var parent = node.return;
              findParent: for (;;) {
                if (null === parent)
                  throw Error(
                    'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
                  );
                var parentStateNode = parent.stateNode;
                switch (parent.tag) {
                  case 5:
                    (currentParent = parentStateNode), (currentParentIsContainer = !1);
                    break findParent;
                  case 3:
                  case 4:
                    (currentParent = parentStateNode.containerInfo), (currentParentIsContainer = !0);
                    break findParent;
                }
                parent = parent.return;
              }
              currentParentIsValid = !0;
            }
            if (5 === node.tag || 6 === node.tag)
              commitNestedUnmounts(finishedRoot, node, renderPriorityLevel),
                currentParentIsContainer
                  ? ((container = currentParent),
                    (child = node.stateNode),
                    8 === container.nodeType ? container.parentNode.removeChild(child) : container.removeChild(child))
                  : removeChild(currentParent, node.stateNode);
            else if (4 === node.tag) {
              if (null !== node.child) {
                (currentParent = node.stateNode.containerInfo),
                  (currentParentIsContainer = !0),
                  (node.child.return = node),
                  (node = node.child);
                continue;
              }
            } else if ((commitUnmount(finishedRoot, node, renderPriorityLevel), null !== node.child)) {
              (node.child.return = node), (node = node.child);
              continue;
            }
            if (node === current) return;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === current) return;
              4 === (node = node.return).tag && (currentParentIsValid = !1);
            }
            (node.sibling.return = node.return), (node = node.sibling);
          }
        }
        function commitDeletion(finishedRoot, current, renderPriorityLevel) {
          unmountHostComponents(finishedRoot, current, renderPriorityLevel),
            (function detachFiber(current) {
              var alternate = current.alternate;
              (current.return = null),
                (current.child = null),
                (current.memoizedState = null),
                (current.updateQueue = null),
                (current.dependencies = null),
                (current.alternate = null),
                (current.firstEffect = null),
                (current.lastEffect = null),
                (current.pendingProps = null),
                (current.memoizedProps = null),
                (current.stateNode = null),
                null !== alternate && detachFiber(alternate);
            })(current);
        }
        function commitWork(current, finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
            case 22:
              return void commitHookEffectListUnmount(3, finishedWork);
            case 1:
              return;
            case 5:
              var instance = finishedWork.stateNode;
              if (null != instance) {
                var newProps = finishedWork.memoizedProps,
                  oldProps = null !== current ? current.memoizedProps : newProps,
                  type = finishedWork.type,
                  updatePayload = finishedWork.updateQueue;
                (finishedWork.updateQueue = null),
                  null !== updatePayload &&
                    (function commitUpdate(
                      domElement,
                      updatePayload,
                      type,
                      oldProps,
                      newProps,
                      internalInstanceHandle
                    ) {
                      updateFiberProps(domElement, newProps),
                        updateProperties(domElement, updatePayload, type, oldProps, newProps);
                    })(instance, updatePayload, type, oldProps, newProps);
              }
              return;
            case 6:
              if (null === finishedWork.stateNode)
                throw Error(
                  'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'
                );
              var textInstance = finishedWork.stateNode,
                newText = finishedWork.memoizedProps;
              null !== current && current.memoizedProps;
              return void (function commitTextUpdate(textInstance, oldText, newText) {
                textInstance.nodeValue = newText;
              })(textInstance, 0, newText);
            case 3:
              var _root = finishedWork.stateNode;
              return void (
                _root.hydrate &&
                ((_root.hydrate = !1),
                (function commitHydratedContainer(container) {
                  retryIfBlockedOn(container);
                })(_root.containerInfo))
              );
            case 12:
              return;
            case 13:
              return (
                (function commitSuspenseComponent(finishedWork) {
                  var newDidTimeout,
                    newState = finishedWork.memoizedState,
                    primaryChildParent = finishedWork;
                  null === newState
                    ? (newDidTimeout = !1)
                    : ((newDidTimeout = !0),
                      (primaryChildParent = finishedWork.child),
                      (function markCommitTimeOfFallback() {
                        globalMostRecentFallbackTime = now();
                      })());
                  null !== primaryChildParent &&
                    (function hideOrUnhideAllChildren(finishedWork, isHidden) {
                      for (var node = finishedWork; ; ) {
                        if (5 === node.tag) {
                          var instance = node.stateNode;
                          isHidden ? hideInstance(instance) : unhideInstance(node.stateNode, node.memoizedProps);
                        } else if (6 === node.tag) {
                          var _instance3 = node.stateNode;
                          isHidden ? (_instance3.nodeValue = '') : unhideTextInstance(_instance3, node.memoizedProps);
                        } else {
                          if (
                            13 === node.tag &&
                            null !== node.memoizedState &&
                            null === node.memoizedState.dehydrated
                          ) {
                            var fallbackChildFragment = node.child.sibling;
                            (fallbackChildFragment.return = node), (node = fallbackChildFragment);
                            continue;
                          }
                          if (null !== node.child) {
                            (node.child.return = node), (node = node.child);
                            continue;
                          }
                        }
                        if (node === finishedWork) return;
                        for (; null === node.sibling; ) {
                          if (null === node.return || node.return === finishedWork) return;
                          node = node.return;
                        }
                        (node.sibling.return = node.return), (node = node.sibling);
                      }
                    })(primaryChildParent, newDidTimeout);
                })(finishedWork),
                void attachSuspenseRetryListeners(finishedWork)
              );
            case 19:
              return void attachSuspenseRetryListeners(finishedWork);
            case 17:
              return;
          }
          throw Error(
            'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
          );
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var thenables = finishedWork.updateQueue;
          if (null !== thenables) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet()),
              thenables.forEach(function (thenable) {
                var retry = resolveRetryThenable.bind(null, finishedWork, thenable);
                retryCache.has(thenable) ||
                  (!0 !== thenable.__reactDoNotTraceInteractions && (retry = tracing.unstable_wrap(retry)),
                  retryCache.add(thenable),
                  thenable.then(retry, retry));
              });
          }
        }
        function commitResetTextContent(current) {
          resetTextContent(current.stateNode);
        }
        var PossiblyWeakMap$1 = 'function' == typeof WeakMap ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
          var update = createUpdate(expirationTime, null);
          (update.tag = 3), (update.payload = { element: null });
          var error = errorInfo.value;
          return (
            (update.callback = function () {
              onUncaughtError(error), logError(fiber, errorInfo);
            }),
            update
          );
        }
        function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
          var update = createUpdate(expirationTime, null);
          update.tag = 3;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ('function' == typeof getDerivedStateFromError) {
            var error$1 = errorInfo.value;
            update.payload = function () {
              return logError(fiber, errorInfo), getDerivedStateFromError(error$1);
            };
          }
          var inst = fiber.stateNode;
          return (
            null !== inst && 'function' == typeof inst.componentDidCatch
              ? (update.callback = function callback() {
                  markFailedErrorBoundaryForHotReloading(fiber),
                    'function' != typeof getDerivedStateFromError &&
                      (!(function markLegacyErrorBoundaryAsFailed(instance) {
                        null === legacyErrorBoundariesThatAlreadyFailed
                          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([instance]))
                          : legacyErrorBoundariesThatAlreadyFailed.add(instance);
                      })(this),
                      logError(fiber, errorInfo));
                  var error$1 = errorInfo.value,
                    stack = errorInfo.stack;
                  this.componentDidCatch(error$1, { componentStack: null !== stack ? stack : '' }),
                    'function' != typeof getDerivedStateFromError &&
                      fiber.expirationTime !== Sync &&
                      error(
                        '%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.',
                        getComponentName(fiber.type) || 'Unknown'
                      );
                })
              : (update.callback = function () {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }),
            update
          );
        }
        function attachPingListener(root, renderExpirationTime, thenable) {
          var threadIDs,
            pingCache = root.pingCache;
          if (
            (null === pingCache
              ? ((pingCache = root.pingCache = new PossiblyWeakMap$1()),
                (threadIDs = new Set()),
                pingCache.set(thenable, threadIDs))
              : void 0 === (threadIDs = pingCache.get(thenable)) &&
                ((threadIDs = new Set()), pingCache.set(thenable, threadIDs)),
            !threadIDs.has(renderExpirationTime))
          ) {
            threadIDs.add(renderExpirationTime);
            var ping = pingSuspendedRoot.bind(null, root, thenable, renderExpirationTime);
            thenable.then(ping, ping);
          }
        }
        function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
          if (
            ((sourceFiber.effectTag |= 2048),
            (sourceFiber.firstEffect = sourceFiber.lastEffect = null),
            null !== value && 'object' == typeof value && 'function' == typeof value.then)
          ) {
            var thenable = value;
            if (0 == (2 & sourceFiber.mode)) {
              var currentSource = sourceFiber.alternate;
              currentSource
                ? ((sourceFiber.updateQueue = currentSource.updateQueue),
                  (sourceFiber.memoizedState = currentSource.memoizedState),
                  (sourceFiber.expirationTime = currentSource.expirationTime))
                : ((sourceFiber.updateQueue = null), (sourceFiber.memoizedState = null));
            }
            var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, 1),
              _workInProgress = returnFiber;
            do {
              if (13 === _workInProgress.tag && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                var thenables = _workInProgress.updateQueue;
                if (null === thenables) {
                  var updateQueue = new Set();
                  updateQueue.add(thenable), (_workInProgress.updateQueue = updateQueue);
                } else thenables.add(thenable);
                if (0 == (2 & _workInProgress.mode)) {
                  if (((_workInProgress.effectTag |= 64), (sourceFiber.effectTag &= -2981), 1 === sourceFiber.tag))
                    if (null === sourceFiber.alternate) sourceFiber.tag = 17;
                    else {
                      var update = createUpdate(Sync, null);
                      (update.tag = ForceUpdate), enqueueUpdate(sourceFiber, update);
                    }
                  return void (sourceFiber.expirationTime = Sync);
                }
                return (
                  attachPingListener(root, renderExpirationTime, thenable),
                  (_workInProgress.effectTag |= 4096),
                  void (_workInProgress.expirationTime = renderExpirationTime)
                );
              }
              _workInProgress = _workInProgress.return;
            } while (null !== _workInProgress);
            value = new Error(
              (getComponentName(sourceFiber.type) || 'A React component') +
                ' suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.' +
                getStackByFiberInDevAndProd(sourceFiber)
            );
          }
          !(function renderDidError() {
            5 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
          })(),
            (value = createCapturedValue(value, sourceFiber));
          var workInProgress = returnFiber;
          do {
            switch (workInProgress.tag) {
              case 3:
                var _errorInfo = value;
                return (
                  (workInProgress.effectTag |= 4096),
                  (workInProgress.expirationTime = renderExpirationTime),
                  void enqueueCapturedUpdate(
                    workInProgress,
                    createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime)
                  )
                );
              case 1:
                var errorInfo = value,
                  ctor = workInProgress.type,
                  instance = workInProgress.stateNode;
                if (
                  0 == (64 & workInProgress.effectTag) &&
                  ('function' == typeof ctor.getDerivedStateFromError ||
                    (null !== instance &&
                      'function' == typeof instance.componentDidCatch &&
                      !isAlreadyFailedLegacyErrorBoundary(instance)))
                )
                  return (
                    (workInProgress.effectTag |= 4096),
                    (workInProgress.expirationTime = renderExpirationTime),
                    void enqueueCapturedUpdate(
                      workInProgress,
                      createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime)
                    )
                  );
            }
            workInProgress = workInProgress.return;
          } while (null !== workInProgress);
        }
        var ceil = Math.ceil,
          ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
          ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
          IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing,
          executionContext = 0,
          workInProgressRoot = null,
          workInProgress = null,
          renderExpirationTime$1 = 0,
          workInProgressRootExitStatus = 0,
          workInProgressRootFatalError = null,
          workInProgressRootLatestProcessedExpirationTime = Sync,
          workInProgressRootLatestSuspenseTimeout = Sync,
          workInProgressRootCanSuspendUsingConfig = null,
          workInProgressRootNextUnprocessedUpdateTime = 0,
          workInProgressRootHasPendingPing = !1,
          globalMostRecentFallbackTime = 0,
          nextEffect = null,
          hasUncaughtError = !1,
          firstUncaughtError = null,
          legacyErrorBoundariesThatAlreadyFailed = null,
          rootDoesHavePassiveEffects = !1,
          rootWithPendingPassiveEffects = null,
          pendingPassiveEffectsRenderPriority = 90,
          pendingPassiveEffectsExpirationTime = 0,
          rootsWithPendingDiscreteUpdates = null,
          nestedUpdateCount = 0,
          rootWithNestedUpdates = null,
          nestedPassiveUpdateCount = 0,
          interruptedBy = null,
          spawnedWorkDuringRender = null,
          currentEventTime = 0;
        function requestCurrentTimeForUpdate() {
          return 0 != (48 & executionContext)
            ? msToExpirationTime(now())
            : 0 !== currentEventTime
            ? currentEventTime
            : (currentEventTime = msToExpirationTime(now()));
        }
        function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {
          var mode = fiber.mode;
          if (0 == (2 & mode)) return Sync;
          var expirationTime,
            priorityLevel = getCurrentPriorityLevel();
          if (0 == (4 & mode)) return 99 === priorityLevel ? Sync : 1073741822;
          if (0 != (16 & executionContext)) return renderExpirationTime$1;
          if (null !== suspenseConfig)
            expirationTime = (function computeSuspenseExpiration(currentTime, timeoutMs) {
              return computeExpirationBucket(currentTime, timeoutMs, 250);
            })(currentTime, 0 | suspenseConfig.timeoutMs || 5e3);
          else
            switch (priorityLevel) {
              case 99:
                expirationTime = Sync;
                break;
              case 98:
                expirationTime = computeInteractiveExpiration(currentTime);
                break;
              case 97:
              case 96:
                expirationTime = (function computeAsyncExpiration(currentTime) {
                  return computeExpirationBucket(currentTime, 5e3, 250);
                })(currentTime);
                break;
              case 95:
                expirationTime = 2;
                break;
              default:
                throw Error('Expected a valid priority level');
            }
          return (
            null !== workInProgressRoot && expirationTime === renderExpirationTime$1 && (expirationTime -= 1),
            expirationTime
          );
        }
        var scheduleWork = function scheduleUpdateOnFiber(fiber, expirationTime) {
          !(function checkForNestedUpdates() {
            if (nestedUpdateCount > 50)
              throw (
                ((nestedUpdateCount = 0),
                (rootWithNestedUpdates = null),
                Error(
                  'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.'
                ))
              );
            nestedPassiveUpdateCount > 50 &&
              ((nestedPassiveUpdateCount = 0),
              error(
                "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
              ));
          })(),
            (function warnAboutRenderPhaseUpdatesInDEV(fiber) {
              if (isRendering && 0 != (16 & executionContext))
                switch (fiber.tag) {
                  case 0:
                  case 11:
                  case 15:
                    var renderingComponentName = (workInProgress && getComponentName(workInProgress.type)) || 'Unknown',
                      dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey))
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey),
                        error(
                          'Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://fb.me/setstate-in-render',
                          getComponentName(fiber.type) || 'Unknown',
                          renderingComponentName,
                          renderingComponentName
                        );
                    break;
                  case 1:
                    didWarnAboutUpdateInRender ||
                      (error(
                        'Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.'
                      ),
                      (didWarnAboutUpdateInRender = !0));
                }
            })(fiber);
          var root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
          if (null !== root) {
            !(function checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {
              null !== workInProgressRoot &&
                updateExpirationTime > renderExpirationTime$1 &&
                (interruptedBy = fiberThatReceivedUpdate);
            })(fiber, expirationTime),
              (function recordScheduleUpdate() {
                isCommitting && (hasScheduledUpdateInCurrentCommit = !0),
                  null !== currentPhase &&
                    'componentWillMount' !== currentPhase &&
                    'componentWillReceiveProps' !== currentPhase &&
                    (hasScheduledUpdateInCurrentPhase = !0);
              })();
            var priorityLevel = getCurrentPriorityLevel();
            if (
              (expirationTime === Sync
                ? 0 != (8 & executionContext) && 0 == (48 & executionContext)
                  ? (schedulePendingInteractions(root, expirationTime), performSyncWorkOnRoot(root))
                  : (ensureRootIsScheduled(root),
                    schedulePendingInteractions(root, expirationTime),
                    0 === executionContext && flushSyncCallbackQueue())
                : (ensureRootIsScheduled(root), schedulePendingInteractions(root, expirationTime)),
              0 != (4 & executionContext) && (98 === priorityLevel || 99 === priorityLevel))
            )
              if (null === rootsWithPendingDiscreteUpdates)
                rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);
              else {
                var lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);
                (void 0 === lastDiscreteTime || lastDiscreteTime > expirationTime) &&
                  rootsWithPendingDiscreteUpdates.set(root, expirationTime);
              }
          } else
            (function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
              var tag = fiber.tag;
              if (3 !== tag && 1 !== tag && 0 !== tag && 11 !== tag && 14 !== tag && 15 !== tag && 22 !== tag) return;
              var componentName = getComponentName(fiber.type) || 'ReactComponent';
              if (null !== didWarnStateUpdateForUnmountedComponent) {
                if (didWarnStateUpdateForUnmountedComponent.has(componentName)) return;
                didWarnStateUpdateForUnmountedComponent.add(componentName);
              } else didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
              error(
                "Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.%s",
                1 === tag ? 'the componentWillUnmount method' : 'a useEffect cleanup function',
                getStackByFiberInDevAndProd(fiber)
              );
            })(fiber);
        };
        function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
          fiber.expirationTime < expirationTime && (fiber.expirationTime = expirationTime);
          var alternate = fiber.alternate;
          null !== alternate &&
            alternate.expirationTime < expirationTime &&
            (alternate.expirationTime = expirationTime);
          var node = fiber.return,
            root = null;
          if (null === node && 3 === fiber.tag) root = fiber.stateNode;
          else
            for (; null !== node; ) {
              if (
                ((alternate = node.alternate),
                node.childExpirationTime < expirationTime
                  ? ((node.childExpirationTime = expirationTime),
                    null !== alternate &&
                      alternate.childExpirationTime < expirationTime &&
                      (alternate.childExpirationTime = expirationTime))
                  : null !== alternate &&
                    alternate.childExpirationTime < expirationTime &&
                    (alternate.childExpirationTime = expirationTime),
                null === node.return && 3 === node.tag)
              ) {
                root = node.stateNode;
                break;
              }
              node = node.return;
            }
          return (
            null !== root &&
              (workInProgressRoot === root &&
                (markUnprocessedUpdateTime(expirationTime),
                4 === workInProgressRootExitStatus && markRootSuspendedAtTime(root, renderExpirationTime$1)),
              markRootUpdatedAtTime(root, expirationTime)),
            root
          );
        }
        function getNextRootExpirationTimeToWorkOn(root) {
          var lastExpiredTime = root.lastExpiredTime;
          if (0 !== lastExpiredTime) return lastExpiredTime;
          var firstPendingTime = root.firstPendingTime;
          if (!isRootSuspendedAtTime(root, firstPendingTime)) return firstPendingTime;
          var lastPingedTime = root.lastPingedTime,
            nextKnownPendingLevel = root.nextKnownPendingLevel,
            nextLevel = lastPingedTime > nextKnownPendingLevel ? lastPingedTime : nextKnownPendingLevel;
          return nextLevel <= 2 && firstPendingTime !== nextLevel ? 0 : nextLevel;
        }
        function ensureRootIsScheduled(root) {
          if (0 !== root.lastExpiredTime)
            return (
              (root.callbackExpirationTime = Sync),
              (root.callbackPriority = 99),
              void (root.callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root)))
            );
          var expirationTime = getNextRootExpirationTimeToWorkOn(root),
            existingCallbackNode = root.callbackNode;
          if (0 !== expirationTime) {
            var callbackNode,
              priorityLevel = inferPriorityFromExpirationTime(requestCurrentTimeForUpdate(), expirationTime);
            if (null !== existingCallbackNode) {
              var existingCallbackPriority = root.callbackPriority;
              if (root.callbackExpirationTime === expirationTime && existingCallbackPriority >= priorityLevel) return;
              !(function cancelCallback(callbackNode) {
                callbackNode !== fakeCallbackNode && Scheduler_cancelCallback(callbackNode);
              })(existingCallbackNode);
            }
            (root.callbackExpirationTime = expirationTime),
              (root.callbackPriority = priorityLevel),
              (callbackNode =
                expirationTime === Sync
                  ? scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root))
                  : scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root), {
                      timeout: expirationTimeToMs(expirationTime) - now(),
                    })),
              (root.callbackNode = callbackNode);
          } else
            null !== existingCallbackNode &&
              ((root.callbackNode = null), (root.callbackExpirationTime = 0), (root.callbackPriority = 90));
        }
        function performConcurrentWorkOnRoot(root, didTimeout) {
          if (((currentEventTime = 0), didTimeout))
            return markRootExpiredAtTime(root, requestCurrentTimeForUpdate()), ensureRootIsScheduled(root), null;
          var expirationTime = getNextRootExpirationTimeToWorkOn(root);
          if (0 !== expirationTime) {
            var originalCallbackNode = root.callbackNode;
            if (0 != (48 & executionContext)) throw Error('Should not already be working.');
            if (
              (flushPassiveEffects(),
              (root === workInProgressRoot && expirationTime === renderExpirationTime$1) ||
                (prepareFreshStack(root, expirationTime), startWorkOnPendingInteractions(root, expirationTime)),
              null !== workInProgress)
            ) {
              var prevExecutionContext = executionContext;
              executionContext |= 16;
              var prevDispatcher = pushDispatcher(),
                prevInteractions = pushInteractions(root);
              for (startWorkLoopTimer(workInProgress); ; )
                try {
                  workLoopConcurrent();
                  break;
                } catch (thrownValue) {
                  handleError(root, thrownValue);
                }
              if (
                (resetContextDependencies(),
                (executionContext = prevExecutionContext),
                popDispatcher(prevDispatcher),
                popInteractions(prevInteractions),
                1 === workInProgressRootExitStatus)
              ) {
                var fatalError = workInProgressRootFatalError;
                throw (
                  (stopInterruptedWorkLoopTimer(),
                  prepareFreshStack(root, expirationTime),
                  markRootSuspendedAtTime(root, expirationTime),
                  ensureRootIsScheduled(root),
                  fatalError)
                );
              }
              if (null !== workInProgress) stopInterruptedWorkLoopTimer();
              else {
                stopFinishedWorkLoopTimer();
                var finishedWork = (root.finishedWork = root.current.alternate);
                (root.finishedExpirationTime = expirationTime),
                  (function finishConcurrentRender(root, finishedWork, exitStatus, expirationTime) {
                    switch (((workInProgressRoot = null), exitStatus)) {
                      case 0:
                      case 1:
                        throw Error('Root did not complete. This is a bug in React.');
                      case 2:
                        markRootExpiredAtTime(root, expirationTime > 2 ? 2 : expirationTime);
                        break;
                      case 3:
                        markRootSuspendedAtTime(root, expirationTime);
                        var lastSuspendedTime = root.lastSuspendedTime;
                        if (
                          (expirationTime === lastSuspendedTime &&
                            (root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork)),
                          workInProgressRootLatestProcessedExpirationTime === Sync && !IsThisRendererActing.current)
                        ) {
                          var msUntilTimeout = globalMostRecentFallbackTime + 500 - now();
                          if (msUntilTimeout > 10) {
                            if (workInProgressRootHasPendingPing) {
                              var lastPingedTime = root.lastPingedTime;
                              if (0 === lastPingedTime || lastPingedTime >= expirationTime) {
                                (root.lastPingedTime = expirationTime), prepareFreshStack(root, expirationTime);
                                break;
                              }
                            }
                            var nextTime = getNextRootExpirationTimeToWorkOn(root);
                            if (0 !== nextTime && nextTime !== expirationTime) break;
                            if (0 !== lastSuspendedTime && lastSuspendedTime !== expirationTime) {
                              root.lastPingedTime = lastSuspendedTime;
                              break;
                            }
                            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);
                            break;
                          }
                        }
                        commitRoot(root);
                        break;
                      case 4:
                        markRootSuspendedAtTime(root, expirationTime);
                        var _lastSuspendedTime = root.lastSuspendedTime;
                        if (
                          (expirationTime === _lastSuspendedTime &&
                            (root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork)),
                          !IsThisRendererActing.current)
                        ) {
                          if (workInProgressRootHasPendingPing) {
                            var _lastPingedTime = root.lastPingedTime;
                            if (0 === _lastPingedTime || _lastPingedTime >= expirationTime) {
                              (root.lastPingedTime = expirationTime), prepareFreshStack(root, expirationTime);
                              break;
                            }
                          }
                          var _msUntilTimeout,
                            _nextTime = getNextRootExpirationTimeToWorkOn(root);
                          if (0 !== _nextTime && _nextTime !== expirationTime) break;
                          if (0 !== _lastSuspendedTime && _lastSuspendedTime !== expirationTime) {
                            root.lastPingedTime = _lastSuspendedTime;
                            break;
                          }
                          if (workInProgressRootLatestSuspenseTimeout !== Sync)
                            _msUntilTimeout = expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();
                          else if (workInProgressRootLatestProcessedExpirationTime === Sync) _msUntilTimeout = 0;
                          else {
                            var eventTimeMs = (function inferTimeFromExpirationTime(expirationTime) {
                                return expirationTimeToMs(expirationTime) - 5e3;
                              })(workInProgressRootLatestProcessedExpirationTime),
                              currentTimeMs = now(),
                              timeUntilExpirationMs = expirationTimeToMs(expirationTime) - currentTimeMs,
                              timeElapsed = currentTimeMs - eventTimeMs;
                            timeElapsed < 0 && (timeElapsed = 0),
                              (_msUntilTimeout =
                                (function jnd(timeElapsed) {
                                  return timeElapsed < 120
                                    ? 120
                                    : timeElapsed < 480
                                    ? 480
                                    : timeElapsed < 1080
                                    ? 1080
                                    : timeElapsed < 1920
                                    ? 1920
                                    : timeElapsed < 3e3
                                    ? 3e3
                                    : timeElapsed < 4320
                                    ? 4320
                                    : 1960 * ceil(timeElapsed / 1960);
                                })(timeElapsed) - timeElapsed),
                              timeUntilExpirationMs < _msUntilTimeout && (_msUntilTimeout = timeUntilExpirationMs);
                          }
                          if (_msUntilTimeout > 10) {
                            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout);
                            break;
                          }
                        }
                        commitRoot(root);
                        break;
                      case 5:
                        if (
                          !IsThisRendererActing.current &&
                          workInProgressRootLatestProcessedExpirationTime !== Sync &&
                          null !== workInProgressRootCanSuspendUsingConfig
                        ) {
                          var _msUntilTimeout2 = (function computeMsUntilSuspenseLoadingDelay(
                            mostRecentEventTime,
                            committedExpirationTime,
                            suspenseConfig
                          ) {
                            var busyMinDurationMs = 0 | suspenseConfig.busyMinDurationMs;
                            if (busyMinDurationMs <= 0) return 0;
                            var busyDelayMs = 0 | suspenseConfig.busyDelayMs,
                              currentTimeMs = now(),
                              eventTimeMs = (function inferTimeFromExpirationTimeWithSuspenseConfig(
                                expirationTime,
                                suspenseConfig
                              ) {
                                return expirationTimeToMs(expirationTime) - (0 | suspenseConfig.timeoutMs || 5e3);
                              })(mostRecentEventTime, suspenseConfig),
                              timeElapsed = currentTimeMs - eventTimeMs;
                            if (timeElapsed <= busyDelayMs) return 0;
                            return busyDelayMs + busyMinDurationMs - timeElapsed;
                          })(
                            workInProgressRootLatestProcessedExpirationTime,
                            0,
                            workInProgressRootCanSuspendUsingConfig
                          );
                          if (_msUntilTimeout2 > 10) {
                            markRootSuspendedAtTime(root, expirationTime),
                              (root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout2));
                            break;
                          }
                        }
                        commitRoot(root);
                        break;
                      default:
                        throw Error('Unknown root exit status.');
                    }
                  })(root, finishedWork, workInProgressRootExitStatus, expirationTime);
              }
              if ((ensureRootIsScheduled(root), root.callbackNode === originalCallbackNode))
                return performConcurrentWorkOnRoot.bind(null, root);
            }
          }
          return null;
        }
        function performSyncWorkOnRoot(root) {
          var lastExpiredTime = root.lastExpiredTime,
            expirationTime = 0 !== lastExpiredTime ? lastExpiredTime : Sync;
          if (0 != (48 & executionContext)) throw Error('Should not already be working.');
          if (
            (flushPassiveEffects(),
            (root === workInProgressRoot && expirationTime === renderExpirationTime$1) ||
              (prepareFreshStack(root, expirationTime), startWorkOnPendingInteractions(root, expirationTime)),
            null !== workInProgress)
          ) {
            var prevExecutionContext = executionContext;
            executionContext |= 16;
            var prevDispatcher = pushDispatcher(),
              prevInteractions = pushInteractions(root);
            for (startWorkLoopTimer(workInProgress); ; )
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root, thrownValue);
              }
            if (
              (resetContextDependencies(),
              (executionContext = prevExecutionContext),
              popDispatcher(prevDispatcher),
              popInteractions(prevInteractions),
              1 === workInProgressRootExitStatus)
            ) {
              var fatalError = workInProgressRootFatalError;
              throw (
                (stopInterruptedWorkLoopTimer(),
                prepareFreshStack(root, expirationTime),
                markRootSuspendedAtTime(root, expirationTime),
                ensureRootIsScheduled(root),
                fatalError)
              );
            }
            if (null !== workInProgress)
              throw Error(
                'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.'
              );
            stopFinishedWorkLoopTimer(),
              (root.finishedWork = root.current.alternate),
              (root.finishedExpirationTime = expirationTime),
              (function finishSyncRender(root) {
                (workInProgressRoot = null), commitRoot(root);
              })(root),
              ensureRootIsScheduled(root);
          }
          return null;
        }
        function batchedUpdates$1(fn, a) {
          var prevExecutionContext = executionContext;
          executionContext |= 1;
          try {
            return fn(a);
          } finally {
            0 === (executionContext = prevExecutionContext) && flushSyncCallbackQueue();
          }
        }
        function unbatchedUpdates(fn, a) {
          var prevExecutionContext = executionContext;
          (executionContext &= -2), (executionContext |= 8);
          try {
            return fn(a);
          } finally {
            0 === (executionContext = prevExecutionContext) && flushSyncCallbackQueue();
          }
        }
        function flushSync(fn, a) {
          if (0 != (48 & executionContext))
            throw Error(
              'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'
            );
          var prevExecutionContext = executionContext;
          executionContext |= 1;
          try {
            return runWithPriority$1(99, fn.bind(null, a));
          } finally {
            (executionContext = prevExecutionContext), flushSyncCallbackQueue();
          }
        }
        function prepareFreshStack(root, expirationTime) {
          (root.finishedWork = null), (root.finishedExpirationTime = 0);
          var timeoutHandle = root.timeoutHandle;
          if (
            (-1 !== timeoutHandle && ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle)), null !== workInProgress)
          )
            for (var interruptedWork = workInProgress.return; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork), (interruptedWork = interruptedWork.return);
          (workInProgressRoot = root),
            (workInProgress = createWorkInProgress(root.current, null)),
            (renderExpirationTime$1 = expirationTime),
            (workInProgressRootExitStatus = 0),
            (workInProgressRootFatalError = null),
            (workInProgressRootLatestProcessedExpirationTime = Sync),
            (workInProgressRootLatestSuspenseTimeout = Sync),
            (workInProgressRootCanSuspendUsingConfig = null),
            (workInProgressRootNextUnprocessedUpdateTime = 0),
            (workInProgressRootHasPendingPing = !1),
            (spawnedWorkDuringRender = null),
            ReactStrictModeWarnings.discardPendingWarnings();
        }
        function handleError(root, thrownValue) {
          for (;;) {
            try {
              if (
                (resetContextDependencies(),
                resetHooksAfterThrow(),
                resetCurrentFiber(),
                null === workInProgress || null === workInProgress.return)
              )
                return (
                  (workInProgressRootExitStatus = 1),
                  (workInProgressRootFatalError = thrownValue),
                  (workInProgress = null),
                  null
                );
              8 & workInProgress.mode && stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !0),
                throwException(root, workInProgress.return, workInProgress, thrownValue, renderExpirationTime$1),
                (workInProgress = completeUnitOfWork(workInProgress));
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              continue;
            }
            return;
          }
        }
        function pushDispatcher(root) {
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          return (
            (ReactCurrentDispatcher$1.current = ContextOnlyDispatcher),
            null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher
          );
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$1.current = prevDispatcher;
        }
        function pushInteractions(root) {
          var prevInteractions = tracing.__interactionsRef.current;
          return (tracing.__interactionsRef.current = root.memoizedInteractions), prevInteractions;
        }
        function popInteractions(prevInteractions) {
          tracing.__interactionsRef.current = prevInteractions;
        }
        function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {
          expirationTime < workInProgressRootLatestProcessedExpirationTime &&
            expirationTime > 2 &&
            (workInProgressRootLatestProcessedExpirationTime = expirationTime),
            null !== suspenseConfig &&
              expirationTime < workInProgressRootLatestSuspenseTimeout &&
              expirationTime > 2 &&
              ((workInProgressRootLatestSuspenseTimeout = expirationTime),
              (workInProgressRootCanSuspendUsingConfig = suspenseConfig));
        }
        function markUnprocessedUpdateTime(expirationTime) {
          expirationTime > workInProgressRootNextUnprocessedUpdateTime &&
            (workInProgressRootNextUnprocessedUpdateTime = expirationTime);
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) workInProgress = performUnitOfWork(workInProgress);
        }
        function workLoopConcurrent() {
          for (; null !== workInProgress && !shouldYield(); ) workInProgress = performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var next,
            current = unitOfWork.alternate;
          return (
            startWorkTimer(unitOfWork),
            setCurrentFiber(unitOfWork),
            0 != (8 & unitOfWork.mode)
              ? (startProfilerTimer(unitOfWork),
                (next = beginWork$1(current, unitOfWork, renderExpirationTime$1)),
                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0))
              : (next = beginWork$1(current, unitOfWork, renderExpirationTime$1)),
            resetCurrentFiber(),
            (unitOfWork.memoizedProps = unitOfWork.pendingProps),
            null === next && (next = completeUnitOfWork(unitOfWork)),
            (ReactCurrentOwner$2.current = null),
            next
          );
        }
        function completeUnitOfWork(unitOfWork) {
          workInProgress = unitOfWork;
          do {
            var current = workInProgress.alternate,
              returnFiber = workInProgress.return;
            if (0 == (2048 & workInProgress.effectTag)) {
              setCurrentFiber(workInProgress);
              var next = void 0;
              if (
                (0 == (8 & workInProgress.mode)
                  ? (next = completeWork(current, workInProgress, renderExpirationTime$1))
                  : (startProfilerTimer(workInProgress),
                    (next = completeWork(current, workInProgress, renderExpirationTime$1)),
                    stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !1)),
                stopWorkTimer(workInProgress),
                resetCurrentFiber(),
                resetChildExpirationTime(workInProgress),
                null !== next)
              )
                return next;
              if (null !== returnFiber && 0 == (2048 & returnFiber.effectTag))
                null === returnFiber.firstEffect && (returnFiber.firstEffect = workInProgress.firstEffect),
                  null !== workInProgress.lastEffect &&
                    (null !== returnFiber.lastEffect &&
                      (returnFiber.lastEffect.nextEffect = workInProgress.firstEffect),
                    (returnFiber.lastEffect = workInProgress.lastEffect)),
                  workInProgress.effectTag > 1 &&
                    (null !== returnFiber.lastEffect
                      ? (returnFiber.lastEffect.nextEffect = workInProgress)
                      : (returnFiber.firstEffect = workInProgress),
                    (returnFiber.lastEffect = workInProgress));
            } else {
              var _next = unwindWork(workInProgress);
              if (0 != (8 & workInProgress.mode)) {
                stopProfilerTimerIfRunningAndRecordDelta(workInProgress, !1);
                for (var actualDuration = workInProgress.actualDuration, child = workInProgress.child; null !== child; )
                  (actualDuration += child.actualDuration), (child = child.sibling);
                workInProgress.actualDuration = actualDuration;
              }
              if (null !== _next) return stopFailedWorkTimer(workInProgress), (_next.effectTag &= 2047), _next;
              stopWorkTimer(workInProgress),
                null !== returnFiber &&
                  ((returnFiber.firstEffect = returnFiber.lastEffect = null), (returnFiber.effectTag |= 2048));
            }
            var siblingFiber = workInProgress.sibling;
            if (null !== siblingFiber) return siblingFiber;
            workInProgress = returnFiber;
          } while (null !== workInProgress);
          return 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5), null;
        }
        function getRemainingExpirationTime(fiber) {
          var updateExpirationTime = fiber.expirationTime,
            childExpirationTime = fiber.childExpirationTime;
          return updateExpirationTime > childExpirationTime ? updateExpirationTime : childExpirationTime;
        }
        function resetChildExpirationTime(completedWork) {
          if (1 === renderExpirationTime$1 || 1 !== completedWork.childExpirationTime) {
            var newChildExpirationTime = 0;
            if (0 != (8 & completedWork.mode)) {
              for (
                var actualDuration = completedWork.actualDuration,
                  treeBaseDuration = completedWork.selfBaseDuration,
                  shouldBubbleActualDurations =
                    null === completedWork.alternate || completedWork.child !== completedWork.alternate.child,
                  child = completedWork.child;
                null !== child;

              ) {
                var childUpdateExpirationTime = child.expirationTime,
                  childChildExpirationTime = child.childExpirationTime;
                childUpdateExpirationTime > newChildExpirationTime &&
                  (newChildExpirationTime = childUpdateExpirationTime),
                  childChildExpirationTime > newChildExpirationTime &&
                    (newChildExpirationTime = childChildExpirationTime),
                  shouldBubbleActualDurations && (actualDuration += child.actualDuration),
                  (treeBaseDuration += child.treeBaseDuration),
                  (child = child.sibling);
              }
              (completedWork.actualDuration = actualDuration), (completedWork.treeBaseDuration = treeBaseDuration);
            } else
              for (var _child = completedWork.child; null !== _child; ) {
                var _childUpdateExpirationTime = _child.expirationTime,
                  _childChildExpirationTime = _child.childExpirationTime;
                _childUpdateExpirationTime > newChildExpirationTime &&
                  (newChildExpirationTime = _childUpdateExpirationTime),
                  _childChildExpirationTime > newChildExpirationTime &&
                    (newChildExpirationTime = _childChildExpirationTime),
                  (_child = _child.sibling);
              }
            completedWork.childExpirationTime = newChildExpirationTime;
          }
        }
        function commitRoot(root) {
          var renderPriorityLevel = getCurrentPriorityLevel();
          return runWithPriority$1(99, commitRootImpl.bind(null, root, renderPriorityLevel)), null;
        }
        function commitRootImpl(root, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (null !== rootWithPendingPassiveEffects);
          if (
            ((function flushRenderPhaseStrictModeWarningsInDEV() {
              ReactStrictModeWarnings.flushLegacyContextWarning(),
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            })(),
            0 != (48 & executionContext))
          )
            throw Error('Should not already be working.');
          var firstEffect,
            finishedWork = root.finishedWork,
            expirationTime = root.finishedExpirationTime;
          if (null === finishedWork) return null;
          if (((root.finishedWork = null), (root.finishedExpirationTime = 0), finishedWork === root.current))
            throw Error(
              'Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.'
            );
          if (
            ((root.callbackNode = null),
            (root.callbackExpirationTime = 0),
            (root.callbackPriority = 90),
            (root.nextKnownPendingLevel = 0),
            (function startCommitTimer() {
              supportsUserTiming &&
                ((isCommitting = !0),
                (hasScheduledUpdateInCurrentCommit = !1),
                labelsInCurrentCommit.clear(),
                beginMark('(Committing Changes)'));
            })(),
            (function markRootFinishedAtTime(root, finishedExpirationTime, remainingExpirationTime) {
              (root.firstPendingTime = remainingExpirationTime),
                finishedExpirationTime <= root.lastSuspendedTime
                  ? (root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = 0)
                  : finishedExpirationTime <= root.firstSuspendedTime &&
                    (root.firstSuspendedTime = finishedExpirationTime - 1);
              finishedExpirationTime <= root.lastPingedTime && (root.lastPingedTime = 0);
              finishedExpirationTime <= root.lastExpiredTime && (root.lastExpiredTime = 0);
            })(root, expirationTime, getRemainingExpirationTime(finishedWork)),
            root === workInProgressRoot &&
              ((workInProgressRoot = null), (workInProgress = null), (renderExpirationTime$1 = 0)),
            finishedWork.effectTag > 1
              ? null !== finishedWork.lastEffect
                ? ((finishedWork.lastEffect.nextEffect = finishedWork), (firstEffect = finishedWork.firstEffect))
                : (firstEffect = finishedWork)
              : (firstEffect = finishedWork.firstEffect),
            null !== firstEffect)
          ) {
            var prevExecutionContext = executionContext;
            executionContext |= 32;
            var prevInteractions = pushInteractions(root);
            (ReactCurrentOwner$2.current = null),
              startCommitSnapshotEffectsTimer(),
              prepareForCommit(root.containerInfo),
              (nextEffect = firstEffect);
            do {
              if ((invokeGuardedCallback(null, commitBeforeMutationEffects, null), hasCaughtError())) {
                if (null === nextEffect) throw Error('Should be working on an effect.');
                var error = clearCaughtError();
                captureCommitPhaseError(nextEffect, error), (nextEffect = nextEffect.nextEffect);
              }
            } while (null !== nextEffect);
            stopCommitSnapshotEffectsTimer(),
              recordCommitTime(),
              startCommitHostEffectsTimer(),
              (nextEffect = firstEffect);
            do {
              if (
                (invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel), hasCaughtError())
              ) {
                if (null === nextEffect) throw Error('Should be working on an effect.');
                var _error = clearCaughtError();
                captureCommitPhaseError(nextEffect, _error), (nextEffect = nextEffect.nextEffect);
              }
            } while (null !== nextEffect);
            stopCommitHostEffectsTimer(),
              (function resetAfterCommit(containerInfo) {
                restoreSelection(selectionInformation),
                  setEnabled(eventsEnabled),
                  (eventsEnabled = null),
                  (selectionInformation = null);
              })(root.containerInfo),
              (root.current = finishedWork),
              startCommitLifeCyclesTimer(),
              (nextEffect = firstEffect);
            do {
              if ((invokeGuardedCallback(null, commitLayoutEffects, null, root, expirationTime), hasCaughtError())) {
                if (null === nextEffect) throw Error('Should be working on an effect.');
                var _error2 = clearCaughtError();
                captureCommitPhaseError(nextEffect, _error2), (nextEffect = nextEffect.nextEffect);
              }
            } while (null !== nextEffect);
            stopCommitLifeCyclesTimer(),
              (nextEffect = null),
              requestPaint(),
              popInteractions(prevInteractions),
              (executionContext = prevExecutionContext);
          } else
            (root.current = finishedWork),
              startCommitSnapshotEffectsTimer(),
              stopCommitSnapshotEffectsTimer(),
              recordCommitTime(),
              startCommitHostEffectsTimer(),
              stopCommitHostEffectsTimer(),
              startCommitLifeCyclesTimer(),
              stopCommitLifeCyclesTimer();
          !(function stopCommitTimer() {
            if (supportsUserTiming) {
              var warning = null;
              hasScheduledUpdateInCurrentCommit
                ? (warning = 'Lifecycle hook scheduled a cascading update')
                : commitCountInCurrentWorkLoop > 0 && (warning = 'Caused by a cascading update in earlier commit'),
                (hasScheduledUpdateInCurrentCommit = !1),
                commitCountInCurrentWorkLoop++,
                (isCommitting = !1),
                labelsInCurrentCommit.clear(),
                endMark('(Committing Changes)', '(Committing Changes)', warning);
            }
          })();
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects)
            (rootDoesHavePassiveEffects = !1),
              (rootWithPendingPassiveEffects = root),
              (pendingPassiveEffectsExpirationTime = expirationTime),
              (pendingPassiveEffectsRenderPriority = renderPriorityLevel);
          else
            for (nextEffect = firstEffect; null !== nextEffect; ) {
              var nextNextEffect = nextEffect.nextEffect;
              (nextEffect.nextEffect = null), (nextEffect = nextNextEffect);
            }
          var remainingExpirationTime = root.firstPendingTime;
          if (0 !== remainingExpirationTime) {
            if (null !== spawnedWorkDuringRender) {
              var expirationTimes = spawnedWorkDuringRender;
              spawnedWorkDuringRender = null;
              for (var i = 0; i < expirationTimes.length; i++)
                scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);
            }
            schedulePendingInteractions(root, remainingExpirationTime);
          } else legacyErrorBoundariesThatAlreadyFailed = null;
          if (
            (rootDidHavePassiveEffects || finishPendingInteractions(root, expirationTime),
            remainingExpirationTime === Sync
              ? root === rootWithNestedUpdates
                ? nestedUpdateCount++
                : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
              : (nestedUpdateCount = 0),
            (function onCommitRoot(root, expirationTime) {
              'function' == typeof onCommitFiberRoot && onCommitFiberRoot(root, expirationTime);
            })(finishedWork.stateNode, expirationTime),
            ensureRootIsScheduled(root),
            hasUncaughtError)
          ) {
            hasUncaughtError = !1;
            var _error3 = firstUncaughtError;
            throw ((firstUncaughtError = null), _error3);
          }
          return 0 != (8 & executionContext) || flushSyncCallbackQueue(), null;
        }
        function commitBeforeMutationEffects() {
          for (; null !== nextEffect; ) {
            var effectTag = nextEffect.effectTag;
            if (0 != (256 & effectTag))
              setCurrentFiber(nextEffect),
                recordEffect(),
                commitBeforeMutationLifeCycles(nextEffect.alternate, nextEffect),
                resetCurrentFiber();
            0 != (512 & effectTag) &&
              (rootDoesHavePassiveEffects ||
                ((rootDoesHavePassiveEffects = !0),
                scheduleCallback(97, function () {
                  return flushPassiveEffects(), null;
                }))),
              (nextEffect = nextEffect.nextEffect);
          }
        }
        function commitMutationEffects(root, renderPriorityLevel) {
          for (; null !== nextEffect; ) {
            setCurrentFiber(nextEffect);
            var effectTag = nextEffect.effectTag;
            if ((16 & effectTag && commitResetTextContent(nextEffect), 128 & effectTag)) {
              var current = nextEffect.alternate;
              null !== current && commitDetachRef(current);
            }
            switch (1038 & effectTag) {
              case 2:
                commitPlacement(nextEffect), (nextEffect.effectTag &= -3);
                break;
              case 6:
                commitPlacement(nextEffect), (nextEffect.effectTag &= -3), commitWork(nextEffect.alternate, nextEffect);
                break;
              case 1024:
                nextEffect.effectTag &= -1025;
                break;
              case 1028:
                (nextEffect.effectTag &= -1025), commitWork(nextEffect.alternate, nextEffect);
                break;
              case 4:
                commitWork(nextEffect.alternate, nextEffect);
                break;
              case 8:
                commitDeletion(root, nextEffect, renderPriorityLevel);
            }
            recordEffect(), resetCurrentFiber(), (nextEffect = nextEffect.nextEffect);
          }
        }
        function commitLayoutEffects(root, committedExpirationTime) {
          for (; null !== nextEffect; ) {
            setCurrentFiber(nextEffect);
            var effectTag = nextEffect.effectTag;
            if (36 & effectTag) recordEffect(), commitLifeCycles(root, nextEffect.alternate, nextEffect);
            128 & effectTag && (recordEffect(), commitAttachRef(nextEffect)),
              resetCurrentFiber(),
              (nextEffect = nextEffect.nextEffect);
          }
        }
        function flushPassiveEffects() {
          if (90 !== pendingPassiveEffectsRenderPriority) {
            var priorityLevel = pendingPassiveEffectsRenderPriority > 97 ? 97 : pendingPassiveEffectsRenderPriority;
            return (
              (pendingPassiveEffectsRenderPriority = 90), runWithPriority$1(priorityLevel, flushPassiveEffectsImpl)
            );
          }
        }
        function flushPassiveEffectsImpl() {
          if (null === rootWithPendingPassiveEffects) return !1;
          var root = rootWithPendingPassiveEffects,
            expirationTime = pendingPassiveEffectsExpirationTime;
          if (
            ((rootWithPendingPassiveEffects = null),
            (pendingPassiveEffectsExpirationTime = 0),
            0 != (48 & executionContext))
          )
            throw Error('Cannot flush passive effects while already rendering.');
          var prevExecutionContext = executionContext;
          executionContext |= 32;
          for (
            var prevInteractions = pushInteractions(root), _effect2 = root.current.firstEffect;
            null !== _effect2;

          ) {
            if (
              (setCurrentFiber(_effect2),
              invokeGuardedCallback(null, commitPassiveHookEffects, null, _effect2),
              hasCaughtError())
            ) {
              if (null === _effect2) throw Error('Should be working on an effect.');
              captureCommitPhaseError(_effect2, clearCaughtError());
            }
            resetCurrentFiber();
            var nextNextEffect = _effect2.nextEffect;
            (_effect2.nextEffect = null), (_effect2 = nextNextEffect);
          }
          return (
            popInteractions(prevInteractions),
            finishPendingInteractions(root, expirationTime),
            (executionContext = prevExecutionContext),
            flushSyncCallbackQueue(),
            (nestedPassiveUpdateCount = null === rootWithPendingPassiveEffects ? 0 : nestedPassiveUpdateCount + 1),
            !0
          );
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
          return (
            null !== legacyErrorBoundariesThatAlreadyFailed && legacyErrorBoundariesThatAlreadyFailed.has(instance)
          );
        }
        var onUncaughtError = function prepareToThrowUncaughtError(error) {
          hasUncaughtError || ((hasUncaughtError = !0), (firstUncaughtError = error));
        };
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          enqueueUpdate(rootFiber, createRootErrorUpdate(rootFiber, createCapturedValue(error, sourceFiber), Sync));
          var root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);
          null !== root && (ensureRootIsScheduled(root), schedulePendingInteractions(root, Sync));
        }
        function captureCommitPhaseError(sourceFiber, error) {
          if (3 !== sourceFiber.tag)
            for (var fiber = sourceFiber.return; null !== fiber; ) {
              if (3 === fiber.tag) return void captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
              if (1 === fiber.tag) {
                var ctor = fiber.type,
                  instance = fiber.stateNode;
                if (
                  'function' == typeof ctor.getDerivedStateFromError ||
                  ('function' == typeof instance.componentDidCatch && !isAlreadyFailedLegacyErrorBoundary(instance))
                ) {
                  enqueueUpdate(fiber, createClassErrorUpdate(fiber, createCapturedValue(error, sourceFiber), Sync));
                  var root = markUpdateTimeFromFiberToRoot(fiber, Sync);
                  return void (null !== root && (ensureRootIsScheduled(root), schedulePendingInteractions(root, Sync)));
                }
              }
              fiber = fiber.return;
            }
          else captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        }
        function pingSuspendedRoot(root, thenable, suspendedTime) {
          var pingCache = root.pingCache;
          if (
            (null !== pingCache && pingCache.delete(thenable),
            workInProgressRoot !== root || renderExpirationTime$1 !== suspendedTime)
          ) {
            if (isRootSuspendedAtTime(root, suspendedTime)) {
              var lastPingedTime = root.lastPingedTime;
              (0 !== lastPingedTime && lastPingedTime < suspendedTime) ||
                ((root.lastPingedTime = suspendedTime),
                ensureRootIsScheduled(root),
                schedulePendingInteractions(root, suspendedTime));
            }
          } else
            4 === workInProgressRootExitStatus ||
            (3 === workInProgressRootExitStatus &&
              workInProgressRootLatestProcessedExpirationTime === Sync &&
              now() - globalMostRecentFallbackTime < 500)
              ? prepareFreshStack(root, renderExpirationTime$1)
              : (workInProgressRootHasPendingPing = !0);
        }
        function resolveRetryThenable(boundaryFiber, thenable) {
          var retryCache;
          null !== (retryCache = boundaryFiber.stateNode) && retryCache.delete(thenable),
            (function retryTimedOutBoundary(boundaryFiber, retryTime) {
              if (0 === retryTime) {
                retryTime = computeExpirationForFiber(requestCurrentTimeForUpdate(), boundaryFiber, null);
              }
              var root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);
              null !== root && (ensureRootIsScheduled(root), schedulePendingInteractions(root, retryTime));
            })(boundaryFiber, 0);
        }
        function stopFinishedWorkLoopTimer() {
          stopWorkLoopTimer(interruptedBy, !0), (interruptedBy = null);
        }
        function stopInterruptedWorkLoopTimer() {
          stopWorkLoopTimer(interruptedBy, !1), (interruptedBy = null);
        }
        var beginWork$1,
          didWarnStateUpdateForUnmountedComponent = null;
        beginWork$1 = function (current, unitOfWork, expirationTime) {
          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(null, unitOfWork);
          try {
            return beginWork(current, unitOfWork, expirationTime);
          } catch (originalError) {
            if (null !== originalError && 'object' == typeof originalError && 'function' == typeof originalError.then)
              throw originalError;
            if (
              (resetContextDependencies(),
              resetHooksAfterThrow(),
              unwindInterruptedWork(unitOfWork),
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy),
              8 & unitOfWork.mode && startProfilerTimer(unitOfWork),
              invokeGuardedCallback(null, beginWork, null, current, unitOfWork, expirationTime),
              hasCaughtError())
            )
              throw clearCaughtError();
            throw originalError;
          }
        };
        var didWarnAboutUpdateInRenderForAnotherComponent,
          didWarnAboutUpdateInRender = !1;
        didWarnAboutUpdateInRenderForAnotherComponent = new Set();
        var IsThisRendererActing = { current: !1 };
        function warnIfNotScopedWithMatchingAct(fiber) {
          !0 === IsSomeRendererActing.current &&
            !0 !== IsThisRendererActing.current &&
            error(
              "It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from 'react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);%s",
              getStackByFiberInDevAndProd(fiber)
            );
        }
        function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
          0 != (1 & fiber.mode) &&
            !1 === IsSomeRendererActing.current &&
            !1 === IsThisRendererActing.current &&
            error(
              "An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://fb.me/react-wrap-tests-with-act%s",
              getComponentName(fiber.type),
              getStackByFiberInDevAndProd(fiber)
            );
        }
        var warnIfNotCurrentlyActingUpdatesInDev = function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
            0 === executionContext &&
              !1 === IsSomeRendererActing.current &&
              !1 === IsThisRendererActing.current &&
              error(
                "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://fb.me/react-wrap-tests-with-act%s",
                getComponentName(fiber.type),
                getStackByFiberInDevAndProd(fiber)
              );
          },
          didWarnAboutUnmockedScheduler = !1;
        function computeThreadID(root, expirationTime) {
          return 1e3 * expirationTime + root.interactionThreadID;
        }
        function markSpawnedWork(expirationTime) {
          null === spawnedWorkDuringRender
            ? (spawnedWorkDuringRender = [expirationTime])
            : spawnedWorkDuringRender.push(expirationTime);
        }
        function scheduleInteractions(root, expirationTime, interactions) {
          if (interactions.size > 0) {
            var pendingInteractionMap = root.pendingInteractionMap,
              pendingInteractions = pendingInteractionMap.get(expirationTime);
            null != pendingInteractions
              ? interactions.forEach(function (interaction) {
                  pendingInteractions.has(interaction) || interaction.__count++, pendingInteractions.add(interaction);
                })
              : (pendingInteractionMap.set(expirationTime, new Set(interactions)),
                interactions.forEach(function (interaction) {
                  interaction.__count++;
                }));
            var subscriber = tracing.__subscriberRef.current;
            if (null !== subscriber) {
              var threadID = computeThreadID(root, expirationTime);
              subscriber.onWorkScheduled(interactions, threadID);
            }
          }
        }
        function schedulePendingInteractions(root, expirationTime) {
          scheduleInteractions(root, expirationTime, tracing.__interactionsRef.current);
        }
        function startWorkOnPendingInteractions(root, expirationTime) {
          var interactions = new Set();
          if (
            (root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              scheduledExpirationTime >= expirationTime &&
                scheduledInteractions.forEach(function (interaction) {
                  return interactions.add(interaction);
                });
            }),
            (root.memoizedInteractions = interactions),
            interactions.size > 0)
          ) {
            var subscriber = tracing.__subscriberRef.current;
            if (null !== subscriber) {
              var threadID = computeThreadID(root, expirationTime);
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error) {
                scheduleCallback(99, function () {
                  throw error;
                });
              }
            }
          }
        }
        function finishPendingInteractions(root, committedExpirationTime) {
          var subscriber,
            earliestRemainingTimeAfterCommit = root.firstPendingTime;
          try {
            if (null !== (subscriber = tracing.__subscriberRef.current) && root.memoizedInteractions.size > 0) {
              var threadID = computeThreadID(root, committedExpirationTime);
              subscriber.onWorkStopped(root.memoizedInteractions, threadID);
            }
          } catch (error) {
            scheduleCallback(99, function () {
              throw error;
            });
          } finally {
            var pendingInteractionMap = root.pendingInteractionMap;
            pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
              scheduledExpirationTime > earliestRemainingTimeAfterCommit &&
                (pendingInteractionMap.delete(scheduledExpirationTime),
                scheduledInteractions.forEach(function (interaction) {
                  if ((interaction.__count--, null !== subscriber && 0 === interaction.__count))
                    try {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    } catch (error) {
                      scheduleCallback(99, function () {
                        throw error;
                      });
                    }
                }));
            });
          }
        }
        var hasBadMapPolyfill,
          onScheduleFiberRoot = null,
          onCommitFiberRoot = null,
          onCommitFiberUnmount = null,
          hasLoggedError = !1,
          isDevToolsPresent = 'undefined' != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__;
        function injectInternals(internals) {
          if ('undefined' == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return !0;
          if (!hook.supportsFiber)
            return (
              error(
                'The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://fb.me/react-devtools'
              ),
              !0
            );
          try {
            var rendererID = hook.inject(internals);
            'function' == typeof hook.onScheduleFiberRoot &&
              (onScheduleFiberRoot = function (root, children) {
                try {
                  hook.onScheduleFiberRoot(rendererID, root, children);
                } catch (err) {
                  hasLoggedError ||
                    ((hasLoggedError = !0), error('React instrumentation encountered an error: %s', err));
                }
              }),
              (onCommitFiberRoot = function (root, expirationTime) {
                try {
                  var didError = 64 == (64 & root.current.effectTag),
                    priorityLevel = inferPriorityFromExpirationTime(
                      (function getCurrentTime() {
                        return msToExpirationTime(now());
                      })(),
                      expirationTime
                    );
                  hook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
                } catch (err) {
                  hasLoggedError ||
                    ((hasLoggedError = !0), error('React instrumentation encountered an error: %s', err));
                }
              }),
              (onCommitFiberUnmount = function (fiber) {
                try {
                  hook.onCommitFiberUnmount(rendererID, fiber);
                } catch (err) {
                  hasLoggedError ||
                    ((hasLoggedError = !0), error('React instrumentation encountered an error: %s', err));
                }
              });
          } catch (err) {
            error('React instrumentation encountered an error: %s.', err);
          }
          return !0;
        }
        hasBadMapPolyfill = !1;
        try {
          var nonExtensibleObject = Object.preventExtensions({}),
            testMap = new Map([[nonExtensibleObject, null]]),
            testSet = new Set([nonExtensibleObject]);
          testMap.set(0, 0), testSet.add(0);
        } catch (e) {
          hasBadMapPolyfill = !0;
        }
        var debugCounter = 1;
        function FiberNode(tag, pendingProps, key, mode) {
          (this.tag = tag),
            (this.key = key),
            (this.elementType = null),
            (this.type = null),
            (this.stateNode = null),
            (this.return = null),
            (this.child = null),
            (this.sibling = null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = pendingProps),
            (this.memoizedProps = null),
            (this.updateQueue = null),
            (this.memoizedState = null),
            (this.dependencies = null),
            (this.mode = mode),
            (this.effectTag = 0),
            (this.nextEffect = null),
            (this.firstEffect = null),
            (this.lastEffect = null),
            (this.expirationTime = 0),
            (this.childExpirationTime = 0),
            (this.alternate = null),
            (this.actualDuration = Number.NaN),
            (this.actualStartTime = Number.NaN),
            (this.selfBaseDuration = Number.NaN),
            (this.treeBaseDuration = Number.NaN),
            (this.actualDuration = 0),
            (this.actualStartTime = -1),
            (this.selfBaseDuration = 0),
            (this.treeBaseDuration = 0),
            (this._debugID = debugCounter++),
            (this._debugIsCurrentlyTiming = !1),
            (this._debugSource = null),
            (this._debugOwner = null),
            (this._debugNeedsRemount = !1),
            (this._debugHookTypes = null),
            hasBadMapPolyfill || 'function' != typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        var didWarnAboutNestedUpdates,
          didWarnAboutFindNodeInStrictMode,
          createFiber = function (tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !(!prototype || !prototype.isReactComponent);
        }
        function createWorkInProgress(current, pendingProps) {
          var workInProgress = current.alternate;
          null === workInProgress
            ? (((workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode)).elementType =
                current.elementType),
              (workInProgress.type = current.type),
              (workInProgress.stateNode = current.stateNode),
              (workInProgress._debugID = current._debugID),
              (workInProgress._debugSource = current._debugSource),
              (workInProgress._debugOwner = current._debugOwner),
              (workInProgress._debugHookTypes = current._debugHookTypes),
              (workInProgress.alternate = current),
              (current.alternate = workInProgress))
            : ((workInProgress.pendingProps = pendingProps),
              (workInProgress.effectTag = 0),
              (workInProgress.nextEffect = null),
              (workInProgress.firstEffect = null),
              (workInProgress.lastEffect = null),
              (workInProgress.actualDuration = 0),
              (workInProgress.actualStartTime = -1)),
            (workInProgress.childExpirationTime = current.childExpirationTime),
            (workInProgress.expirationTime = current.expirationTime),
            (workInProgress.child = current.child),
            (workInProgress.memoizedProps = current.memoizedProps),
            (workInProgress.memoizedState = current.memoizedState),
            (workInProgress.updateQueue = current.updateQueue);
          var currentDependencies = current.dependencies;
          switch (
            ((workInProgress.dependencies =
              null === currentDependencies
                ? null
                : {
                    expirationTime: currentDependencies.expirationTime,
                    firstContext: currentDependencies.firstContext,
                    responders: currentDependencies.responders,
                  }),
            (workInProgress.sibling = current.sibling),
            (workInProgress.index = current.index),
            (workInProgress.ref = current.ref),
            (workInProgress.selfBaseDuration = current.selfBaseDuration),
            (workInProgress.treeBaseDuration = current.treeBaseDuration),
            (workInProgress._debugNeedsRemount = current._debugNeedsRemount),
            workInProgress.tag)
          ) {
            case 2:
            case 0:
            case 15:
              workInProgress.type = resolveFunctionForHotReloading(current.type);
              break;
            case 1:
              workInProgress.type = resolveClassForHotReloading(current.type);
              break;
            case 11:
              workInProgress.type = resolveForwardRefForHotReloading(current.type);
          }
          return workInProgress;
        }
        function resetWorkInProgress(workInProgress, renderExpirationTime) {
          (workInProgress.effectTag &= 2),
            (workInProgress.nextEffect = null),
            (workInProgress.firstEffect = null),
            (workInProgress.lastEffect = null);
          var current = workInProgress.alternate;
          if (null === current)
            (workInProgress.childExpirationTime = 0),
              (workInProgress.expirationTime = renderExpirationTime),
              (workInProgress.child = null),
              (workInProgress.memoizedProps = null),
              (workInProgress.memoizedState = null),
              (workInProgress.updateQueue = null),
              (workInProgress.dependencies = null),
              (workInProgress.selfBaseDuration = 0),
              (workInProgress.treeBaseDuration = 0);
          else {
            (workInProgress.childExpirationTime = current.childExpirationTime),
              (workInProgress.expirationTime = current.expirationTime),
              (workInProgress.child = current.child),
              (workInProgress.memoizedProps = current.memoizedProps),
              (workInProgress.memoizedState = current.memoizedState),
              (workInProgress.updateQueue = current.updateQueue);
            var currentDependencies = current.dependencies;
            (workInProgress.dependencies =
              null === currentDependencies
                ? null
                : {
                    expirationTime: currentDependencies.expirationTime,
                    firstContext: currentDependencies.firstContext,
                    responders: currentDependencies.responders,
                  }),
              (workInProgress.selfBaseDuration = current.selfBaseDuration),
              (workInProgress.treeBaseDuration = current.treeBaseDuration);
          }
          return workInProgress;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime) {
          var fiber,
            fiberTag = 2,
            resolvedType = type;
          if ('function' == typeof type)
            shouldConstruct(type)
              ? ((fiberTag = 1), (resolvedType = resolveClassForHotReloading(resolvedType)))
              : (resolvedType = resolveFunctionForHotReloading(resolvedType));
          else if ('string' == typeof type) fiberTag = 5;
          else
            getTag: switch (type) {
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);
              case REACT_CONCURRENT_MODE_TYPE:
                (fiberTag = 8), (mode |= 7);
                break;
              case REACT_STRICT_MODE_TYPE:
                (fiberTag = 8), (mode |= 1);
                break;
              case REACT_PROFILER_TYPE:
                return (function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
                  ('string' == typeof pendingProps.id && 'function' == typeof pendingProps.onRender) ||
                    error('Profiler must specify an "id" string and "onRender" function as props');
                  var fiber = createFiber(12, pendingProps, key, 8 | mode);
                  return (
                    (fiber.elementType = REACT_PROFILER_TYPE),
                    (fiber.type = REACT_PROFILER_TYPE),
                    (fiber.expirationTime = expirationTime),
                    fiber
                  );
                })(pendingProps, mode, expirationTime, key);
              case REACT_SUSPENSE_TYPE:
                return (function createFiberFromSuspense(pendingProps, mode, expirationTime, key) {
                  var fiber = createFiber(13, pendingProps, key, mode);
                  return (
                    (fiber.type = REACT_SUSPENSE_TYPE),
                    (fiber.elementType = REACT_SUSPENSE_TYPE),
                    (fiber.expirationTime = expirationTime),
                    fiber
                  );
                })(pendingProps, mode, expirationTime, key);
              case REACT_SUSPENSE_LIST_TYPE:
                return (function createFiberFromSuspenseList(pendingProps, mode, expirationTime, key) {
                  var fiber = createFiber(19, pendingProps, key, mode);
                  return (
                    (fiber.type = REACT_SUSPENSE_LIST_TYPE),
                    (fiber.elementType = REACT_SUSPENSE_LIST_TYPE),
                    (fiber.expirationTime = expirationTime),
                    fiber
                  );
                })(pendingProps, mode, expirationTime, key);
              default:
                if ('object' == typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = 10;
                      break getTag;
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 9;
                      break getTag;
                    case REACT_FORWARD_REF_TYPE:
                      (fiberTag = 11), (resolvedType = resolveForwardRefForHotReloading(resolvedType));
                      break getTag;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break getTag;
                    case REACT_LAZY_TYPE:
                      (fiberTag = 16), (resolvedType = null);
                      break getTag;
                    case REACT_BLOCK_TYPE:
                      fiberTag = 22;
                      break getTag;
                  }
                var info = '';
                (void 0 === type || ('object' == typeof type && null !== type && 0 === Object.keys(type).length)) &&
                  (info +=
                    " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var ownerName = owner ? getComponentName(owner.type) : null;
                throw (
                  (ownerName && (info += '\n\nCheck the render method of `' + ownerName + '`.'),
                  Error(
                    'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ' +
                      (null == type ? type : typeof type) +
                      '.' +
                      info
                  ))
                );
            }
          return (
            ((fiber = createFiber(fiberTag, pendingProps, key, mode)).elementType = type),
            (fiber.type = resolvedType),
            (fiber.expirationTime = expirationTime),
            fiber
          );
        }
        function createFiberFromElement(element, mode, expirationTime) {
          var owner;
          owner = element._owner;
          var fiber = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            owner,
            mode,
            expirationTime
          );
          return (fiber._debugSource = element._source), (fiber._debugOwner = element._owner), fiber;
        }
        function createFiberFromFragment(elements, mode, expirationTime, key) {
          var fiber = createFiber(7, elements, key, mode);
          return (fiber.expirationTime = expirationTime), fiber;
        }
        function createFiberFromText(content, mode, expirationTime) {
          var fiber = createFiber(6, content, null, mode);
          return (fiber.expirationTime = expirationTime), fiber;
        }
        function createFiberFromPortal(portal, mode, expirationTime) {
          var pendingProps = null !== portal.children ? portal.children : [],
            fiber = createFiber(4, pendingProps, portal.key, mode);
          return (
            (fiber.expirationTime = expirationTime),
            (fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation,
            }),
            fiber
          );
        }
        function assignFiberPropertiesInDEV(target, source) {
          return (
            null === target && (target = createFiber(2, null, null, 0)),
            (target.tag = source.tag),
            (target.key = source.key),
            (target.elementType = source.elementType),
            (target.type = source.type),
            (target.stateNode = source.stateNode),
            (target.return = source.return),
            (target.child = source.child),
            (target.sibling = source.sibling),
            (target.index = source.index),
            (target.ref = source.ref),
            (target.pendingProps = source.pendingProps),
            (target.memoizedProps = source.memoizedProps),
            (target.updateQueue = source.updateQueue),
            (target.memoizedState = source.memoizedState),
            (target.dependencies = source.dependencies),
            (target.mode = source.mode),
            (target.effectTag = source.effectTag),
            (target.nextEffect = source.nextEffect),
            (target.firstEffect = source.firstEffect),
            (target.lastEffect = source.lastEffect),
            (target.expirationTime = source.expirationTime),
            (target.childExpirationTime = source.childExpirationTime),
            (target.alternate = source.alternate),
            (target.actualDuration = source.actualDuration),
            (target.actualStartTime = source.actualStartTime),
            (target.selfBaseDuration = source.selfBaseDuration),
            (target.treeBaseDuration = source.treeBaseDuration),
            (target._debugID = source._debugID),
            (target._debugSource = source._debugSource),
            (target._debugOwner = source._debugOwner),
            (target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming),
            (target._debugNeedsRemount = source._debugNeedsRemount),
            (target._debugHookTypes = source._debugHookTypes),
            target
          );
        }
        function FiberRootNode(containerInfo, tag, hydrate) {
          (this.tag = tag),
            (this.current = null),
            (this.containerInfo = containerInfo),
            (this.pendingChildren = null),
            (this.pingCache = null),
            (this.finishedExpirationTime = 0),
            (this.finishedWork = null),
            (this.timeoutHandle = -1),
            (this.context = null),
            (this.pendingContext = null),
            (this.hydrate = hydrate),
            (this.callbackNode = null),
            (this.callbackPriority = 90),
            (this.firstPendingTime = 0),
            (this.firstSuspendedTime = 0),
            (this.lastSuspendedTime = 0),
            (this.nextKnownPendingLevel = 0),
            (this.lastPingedTime = 0),
            (this.lastExpiredTime = 0),
            (this.interactionThreadID = tracing.unstable_getThreadID()),
            (this.memoizedInteractions = new Set()),
            (this.pendingInteractionMap = new Map());
        }
        function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
          var root = new FiberRootNode(containerInfo, tag, hydrate),
            uninitializedFiber = (function createHostRootFiber(tag) {
              var mode;
              return (
                (mode = 2 === tag ? 7 : 1 === tag ? 3 : 0),
                isDevToolsPresent && (mode |= 8),
                createFiber(3, null, null, mode)
              );
            })(tag);
          return (
            (root.current = uninitializedFiber),
            (uninitializedFiber.stateNode = root),
            initializeUpdateQueue(uninitializedFiber),
            root
          );
        }
        function isRootSuspendedAtTime(root, expirationTime) {
          var firstSuspendedTime = root.firstSuspendedTime,
            lastSuspendedTime = root.lastSuspendedTime;
          return (
            0 !== firstSuspendedTime && firstSuspendedTime >= expirationTime && lastSuspendedTime <= expirationTime
          );
        }
        function markRootSuspendedAtTime(root, expirationTime) {
          var firstSuspendedTime = root.firstSuspendedTime,
            lastSuspendedTime = root.lastSuspendedTime;
          firstSuspendedTime < expirationTime && (root.firstSuspendedTime = expirationTime),
            (lastSuspendedTime > expirationTime || 0 === firstSuspendedTime) &&
              (root.lastSuspendedTime = expirationTime),
            expirationTime <= root.lastPingedTime && (root.lastPingedTime = 0),
            expirationTime <= root.lastExpiredTime && (root.lastExpiredTime = 0);
        }
        function markRootUpdatedAtTime(root, expirationTime) {
          expirationTime > root.firstPendingTime && (root.firstPendingTime = expirationTime);
          var firstSuspendedTime = root.firstSuspendedTime;
          0 !== firstSuspendedTime &&
            (expirationTime >= firstSuspendedTime
              ? (root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = 0)
              : expirationTime >= root.lastSuspendedTime && (root.lastSuspendedTime = expirationTime + 1),
            expirationTime > root.nextKnownPendingLevel && (root.nextKnownPendingLevel = expirationTime));
        }
        function markRootExpiredAtTime(root, expirationTime) {
          var lastExpiredTime = root.lastExpiredTime;
          (0 === lastExpiredTime || lastExpiredTime > expirationTime) && (root.lastExpiredTime = expirationTime);
        }
        function updateContainer(element, container, parentComponent, callback) {
          !(function onScheduleRoot(root, children) {
            'function' == typeof onScheduleFiberRoot && onScheduleFiberRoot(root, children);
          })(container, element);
          var current$1 = container.current,
            currentTime = requestCurrentTimeForUpdate();
          'undefined' != typeof jest &&
            (!(function warnIfUnmockedScheduler(fiber) {
              !1 === didWarnAboutUnmockedScheduler &&
                void 0 === Scheduler.unstable_flushAllWithoutAsserting &&
                (2 & fiber.mode || 4 & fiber.mode) &&
                ((didWarnAboutUnmockedScheduler = !0),
                error(
                  "In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: \njest.mock('scheduler', () => require('scheduler/unstable_mock'));\n\nFor more info, visit https://fb.me/react-mock-scheduler"
                ));
            })(current$1),
            warnIfNotScopedWithMatchingAct(current$1));
          var suspenseConfig = requestCurrentSuspenseConfig(),
            expirationTime = computeExpirationForFiber(currentTime, current$1, suspenseConfig),
            context = (function getContextForSubtree(parentComponent) {
              if (!parentComponent) return emptyContextObject;
              var fiber = get(parentComponent),
                parentContext = findCurrentUnmaskedContext(fiber);
              if (1 === fiber.tag) {
                var Component = fiber.type;
                if (isContextProvider(Component)) return processChildContext(fiber, Component, parentContext);
              }
              return parentContext;
            })(parentComponent);
          null === container.context ? (container.context = context) : (container.pendingContext = context),
            isRendering &&
              null !== current &&
              !didWarnAboutNestedUpdates &&
              ((didWarnAboutNestedUpdates = !0),
              error(
                'Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.',
                getComponentName(current.type) || 'Unknown'
              ));
          var update = createUpdate(expirationTime, suspenseConfig);
          return (
            (update.payload = { element }),
            null !== (callback = void 0 === callback ? null : callback) &&
              ('function' != typeof callback &&
                error(
                  'render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
                  callback
                ),
              (update.callback = callback)),
            enqueueUpdate(current$1, update),
            scheduleWork(current$1, expirationTime),
            expirationTime
          );
        }
        function getPublicRootInstance(container) {
          var containerFiber = container.current;
          if (!containerFiber.child) return null;
          switch (containerFiber.child.tag) {
            case 5:
            default:
              return containerFiber.child.stateNode;
          }
        }
        function markRetryTimeImpl(fiber, retryTime) {
          var suspenseState = fiber.memoizedState;
          null !== suspenseState &&
            null !== suspenseState.dehydrated &&
            suspenseState.retryTime < retryTime &&
            (suspenseState.retryTime = retryTime);
        }
        function markRetryTimeIfNotHydrated(fiber, retryTime) {
          markRetryTimeImpl(fiber, retryTime);
          var alternate = fiber.alternate;
          alternate && markRetryTimeImpl(alternate, retryTime);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = (function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) return null;
            for (var node = currentParent; ; ) {
              if (5 === node.tag || 6 === node.tag) return node;
              if (node.child && 4 !== node.tag) (node.child.return = node), (node = node.child);
              else {
                if (node === currentParent) return null;
                for (; !node.sibling; ) {
                  if (!node.return || node.return === currentParent) return null;
                  node = node.return;
                }
                (node.sibling.return = node.return), (node = node.sibling);
              }
            }
            return null;
          })(fiber);
          return null === hostFiber ? null : 20 === hostFiber.tag ? hostFiber.stateNode.instance : hostFiber.stateNode;
        }
        (didWarnAboutNestedUpdates = !1), (didWarnAboutFindNodeInStrictMode = {});
        var shouldSuspendImpl = function (fiber) {
          return !1;
        };
        var overrideHookState,
          overrideProps,
          scheduleUpdate,
          setSuspenseHandler,
          copyWithSetImpl = function (obj, path, idx, value) {
            if (idx >= path.length) return value;
            var key = path[idx],
              updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
            return (updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value)), updated;
          },
          copyWithSet = function (obj, path, value) {
            return copyWithSetImpl(obj, path, 0, value);
          };
        (overrideHookState = function (fiber, id, path, value) {
          for (var currentHook = fiber.memoizedState; null !== currentHook && id > 0; )
            (currentHook = currentHook.next), id--;
          if (null !== currentHook) {
            var newState = copyWithSet(currentHook.memoizedState, path, value);
            (currentHook.memoizedState = newState),
              (currentHook.baseState = newState),
              (fiber.memoizedProps = _assign({}, fiber.memoizedProps)),
              scheduleWork(fiber, Sync);
          }
        }),
          (overrideProps = function (fiber, path, value) {
            (fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value)),
              fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps),
              scheduleWork(fiber, Sync);
          }),
          (scheduleUpdate = function (fiber) {
            scheduleWork(fiber, Sync);
          }),
          (setSuspenseHandler = function (newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          });
        ReactSharedInternals.IsSomeRendererActing;
        function ReactDOMRoot(container, options) {
          this._internalRoot = createRootImpl(container, 2, options);
        }
        function ReactDOMBlockingRoot(container, tag, options) {
          this._internalRoot = createRootImpl(container, tag, options);
        }
        function createRootImpl(container, tag, options) {
          var hydrate = null != options && !0 === options.hydrate,
            root =
              (null != options && options.hydrationOptions,
              (function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
                return createFiberRoot(containerInfo, tag, hydrate);
              })(container, tag, hydrate));
          ((function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          })(root.current, container),
          hydrate && 0 !== tag) &&
            (function eagerlyTrapReplayableEvents(container, document) {
              var listenerMapForDoc = getListenerMapForElement(document);
              discreteReplayableEvents.forEach(function (topLevelType) {
                trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);
              }),
                continuousReplayableEvents.forEach(function (topLevelType) {
                  trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);
                });
            })(0, 9 === container.nodeType ? container : container.ownerDocument);
          return root;
        }
        function isValidContainer(node) {
          return !(
            !node ||
            (1 !== node.nodeType &&
              9 !== node.nodeType &&
              11 !== node.nodeType &&
              (8 !== node.nodeType || ' react-mount-point-unstable ' !== node.nodeValue))
          );
        }
        (ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) {
          var root = this._internalRoot;
          'function' == typeof arguments[1] &&
            error(
              'render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
            );
          var container = root.containerInfo;
          if (8 !== container.nodeType) {
            var hostInstance = findHostInstanceWithNoPortals(root.current);
            hostInstance &&
              hostInstance.parentNode !== container &&
              error(
                "render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container."
              );
          }
          updateContainer(children, root, null, null);
        }),
          (ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () {
            'function' == typeof arguments[0] &&
              error(
                'unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().'
              );
            var root = this._internalRoot,
              container = root.containerInfo;
            updateContainer(null, root, null, function () {
              unmarkContainerAsRoot(container);
            });
          });
        var topLevelUpdateWarnings,
          ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner,
          warnedAboutHydrateAPI = !1;
        function getReactRootElementInContainer(container) {
          return container ? (9 === container.nodeType ? container.documentElement : container.firstChild) : null;
        }
        function legacyCreateRootFromDOMContainer(container, forceHydrate) {
          var shouldHydrate =
            forceHydrate ||
            (function shouldHydrateDueToLegacyHeuristic(container) {
              var rootElement = getReactRootElementInContainer(container);
              return !(!rootElement || 1 !== rootElement.nodeType || !rootElement.hasAttribute('data-reactroot'));
            })(container);
          if (!shouldHydrate)
            for (var rootSibling, warned = !1; (rootSibling = container.lastChild); )
              !warned &&
                1 === rootSibling.nodeType &&
                rootSibling.hasAttribute('data-reactroot') &&
                ((warned = !0),
                error(
                  'render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.'
                )),
                container.removeChild(rootSibling);
          return (
            !shouldHydrate ||
              forceHydrate ||
              warnedAboutHydrateAPI ||
              ((warnedAboutHydrateAPI = !0),
              warn(
                'render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v17. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.'
              )),
            (function createLegacyRoot(container, options) {
              return new ReactDOMBlockingRoot(container, 0, options);
            })(container, shouldHydrate ? { hydrate: !0 } : void 0)
          );
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
          topLevelUpdateWarnings(container),
            (function warnOnInvalidCallback$1(callback, callerName) {
              null !== callback &&
                'function' != typeof callback &&
                error(
                  '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.',
                  callerName,
                  callback
                );
            })(void 0 === callback ? null : callback, 'render');
          var fiberRoot,
            root = container._reactRootContainer;
          if (root) {
            if (((fiberRoot = root._internalRoot), 'function' == typeof callback)) {
              var _originalCallback = callback;
              callback = function () {
                var instance = getPublicRootInstance(fiberRoot);
                _originalCallback.call(instance);
              };
            }
            updateContainer(children, fiberRoot, parentComponent, callback);
          } else {
            if (
              ((root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate)),
              (fiberRoot = root._internalRoot),
              'function' == typeof callback)
            ) {
              var originalCallback = callback;
              callback = function () {
                var instance = getPublicRootInstance(fiberRoot);
                originalCallback.call(instance);
              };
            }
            unbatchedUpdates(function () {
              updateContainer(children, fiberRoot, parentComponent, callback);
            });
          }
          return getPublicRootInstance(fiberRoot);
        }
        function createPortal(children, containerInfo, implementation) {
          var key = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : '' + key,
            children,
            containerInfo,
            implementation,
          };
        }
        topLevelUpdateWarnings = function (container) {
          if (container._reactRootContainer && 8 !== container.nodeType) {
            var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
            hostInstance &&
              hostInstance.parentNode !== container &&
              error(
                'render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.'
              );
          }
          var isRootRenderedBySomeReact = !!container._reactRootContainer,
            rootEl = getReactRootElementInContainer(container);
          !(!rootEl || !getInstanceFromNode$1(rootEl)) &&
            !isRootRenderedBySomeReact &&
            error(
              'render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.'
            ),
            1 === container.nodeType &&
              container.tagName &&
              'BODY' === container.tagName.toUpperCase() &&
              error(
                'render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.'
              );
        };
        !(function setAttemptUserBlockingHydration(fn) {
          attemptUserBlockingHydration = fn;
        })(function attemptUserBlockingHydration$1(fiber) {
          if (13 === fiber.tag) {
            var expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());
            scheduleWork(fiber, expTime), markRetryTimeIfNotHydrated(fiber, expTime);
          }
        }),
          (function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
          })(function attemptContinuousHydration$1(fiber) {
            13 === fiber.tag && (scheduleWork(fiber, 3), markRetryTimeIfNotHydrated(fiber, 3));
          }),
          (function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
          })(function attemptHydrationAtCurrentPriority$1(fiber) {
            if (13 === fiber.tag) {
              var expTime = computeExpirationForFiber(requestCurrentTimeForUpdate(), fiber, null);
              scheduleWork(fiber, expTime), markRetryTimeIfNotHydrated(fiber, expTime);
            }
          });
        var didWarnAboutUnstableCreatePortal = !1;
        function createPortal$1(children, container) {
          var key = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
          if (!isValidContainer(container)) throw Error('Target container is not a DOM element.');
          return createPortal(children, container, null, key);
        }
        ('function' == typeof Map &&
          null != Map.prototype &&
          'function' == typeof Map.prototype.forEach &&
          'function' == typeof Set &&
          null != Set.prototype &&
          'function' == typeof Set.prototype.clear &&
          'function' == typeof Set.prototype.forEach) ||
          error(
            'React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills'
          ),
          (function setRestoreImplementation(impl) {
            restoreImpl = impl;
          })(function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case 'input':
                return void restoreControlledState(domElement, props);
              case 'textarea':
                return void (function restoreControlledState$2(element, props) {
                  updateWrapper$1(element, props);
                })(domElement, props);
              case 'select':
                return void (function restoreControlledState$1(element, props) {
                  var node = element,
                    value = props.value;
                  null != value && updateOptions(node, !!props.multiple, value, !1);
                })(domElement, props);
            }
          }),
          (function setBatchingImplementation(
            _batchedUpdatesImpl,
            _discreteUpdatesImpl,
            _flushDiscreteUpdatesImpl,
            _batchedEventUpdatesImpl
          ) {
            (batchedUpdatesImpl = _batchedUpdatesImpl),
              (discreteUpdatesImpl = _discreteUpdatesImpl),
              (flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl),
              (batchedEventUpdatesImpl = _batchedEventUpdatesImpl);
          })(
            batchedUpdates$1,
            function discreteUpdates$1(fn, a, b, c, d) {
              var prevExecutionContext = executionContext;
              executionContext |= 4;
              try {
                return runWithPriority$1(98, fn.bind(null, a, b, c, d));
              } finally {
                0 === (executionContext = prevExecutionContext) && flushSyncCallbackQueue();
              }
            },
            function flushDiscreteUpdates() {
              0 == (49 & executionContext)
                ? (!(function flushPendingDiscreteUpdates() {
                    if (null !== rootsWithPendingDiscreteUpdates) {
                      var roots = rootsWithPendingDiscreteUpdates;
                      (rootsWithPendingDiscreteUpdates = null),
                        roots.forEach(function (expirationTime, root) {
                          markRootExpiredAtTime(root, expirationTime), ensureRootIsScheduled(root);
                        }),
                        flushSyncCallbackQueue();
                    }
                  })(),
                  flushPassiveEffects())
                : 0 != (16 & executionContext) &&
                  error('unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.');
            },
            function batchedEventUpdates$1(fn, a) {
              var prevExecutionContext = executionContext;
              executionContext |= 2;
              try {
                return fn(a);
              } finally {
                0 === (executionContext = prevExecutionContext) && flushSyncCallbackQueue();
              }
            }
          );
        var Internals = {
          Events: [
            getInstanceFromNode$1,
            getNodeFromInstance$1,
            getFiberCurrentPropsFromNode$1,
            injectEventPluginsByName,
            eventNameDispatchConfigs,
            accumulateTwoPhaseDispatches,
            function accumulateDirectDispatches(events) {
              forEachAccumulated(events, accumulateDirectDispatchesSingle);
            },
            enqueueStateRestore,
            restoreStateIfNeeded,
            dispatchEvent,
            runEventsInBatch,
            flushPassiveEffects,
            IsThisRendererActing,
          ],
        };
        if (
          !(function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance,
              ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals(
              _assign({}, devToolsConfig, {
                overrideHookState,
                overrideProps,
                setSuspenseHandler,
                scheduleUpdate,
                currentDispatcherRef: ReactCurrentDispatcher,
                findHostInstanceByFiber: function (fiber) {
                  var hostFiber = findCurrentHostFiber(fiber);
                  return null === hostFiber ? null : hostFiber.stateNode;
                },
                findFiberByHostInstance: function (instance) {
                  return findFiberByHostInstance ? findFiberByHostInstance(instance) : null;
                },
                findHostInstancesForRefresh,
                scheduleRefresh,
                scheduleRoot,
                setRefreshHandler,
                getCurrentFiber: function () {
                  return current;
                },
              })
            );
          })({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: '16.13.1',
            rendererPackageName: 'react-dom',
          }) &&
          canUseDOM &&
          window.top === window.self &&
          ((navigator.userAgent.indexOf('Chrome') > -1 && -1 === navigator.userAgent.indexOf('Edge')) ||
            navigator.userAgent.indexOf('Firefox') > -1)
        ) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) &&
            console.info(
              '%cDownload the React DevTools for a better development experience: https://fb.me/react-devtools' +
                ('file:' === protocol
                  ? '\nYou might need to use a local HTTP server (instead of file://): https://fb.me/react-devtools-faq'
                  : ''),
              'font-weight:bold'
            );
        }
        (exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals),
          (exports.createPortal = createPortal$1),
          (exports.findDOMNode = function findDOMNode(componentOrElement) {
            var owner = ReactCurrentOwner$3.current;
            return (
              null !== owner &&
                null !== owner.stateNode &&
                (owner.stateNode._warnedAboutRefsInRender ||
                  error(
                    '%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.',
                    getComponentName(owner.type) || 'A component'
                  ),
                (owner.stateNode._warnedAboutRefsInRender = !0)),
              null == componentOrElement
                ? null
                : 1 === componentOrElement.nodeType
                ? componentOrElement
                : (function findHostInstanceWithWarning(component, methodName) {
                    var fiber = get(component);
                    if (void 0 === fiber)
                      throw 'function' == typeof component.render
                        ? Error('Unable to find node on an unmounted component.')
                        : Error('Argument appears to not be a ReactComponent. Keys: ' + Object.keys(component));
                    var hostFiber = findCurrentHostFiber(fiber);
                    if (null === hostFiber) return null;
                    if (1 & hostFiber.mode) {
                      var componentName = getComponentName(fiber.type) || 'Component';
                      didWarnAboutFindNodeInStrictMode[componentName] ||
                        ((didWarnAboutFindNodeInStrictMode[componentName] = !0),
                        1 & fiber.mode
                          ? error(
                              '%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://fb.me/react-strict-mode-find-node%s',
                              methodName,
                              methodName,
                              componentName,
                              getStackByFiberInDevAndProd(hostFiber)
                            )
                          : error(
                              '%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://fb.me/react-strict-mode-find-node%s',
                              methodName,
                              methodName,
                              componentName,
                              getStackByFiberInDevAndProd(hostFiber)
                            ));
                    }
                    return hostFiber.stateNode;
                  })(componentOrElement, 'findDOMNode')
            );
          }),
          (exports.flushSync = flushSync),
          (exports.hydrate = function hydrate(element, container, callback) {
            if (!isValidContainer(container)) throw Error('Target container is not a DOM element.');
            return (
              isContainerMarkedAsRoot(container) &&
                void 0 === container._reactRootContainer &&
                error(
                  'You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?'
                ),
              legacyRenderSubtreeIntoContainer(null, element, container, !0, callback)
            );
          }),
          (exports.render = function render(element, container, callback) {
            if (!isValidContainer(container)) throw Error('Target container is not a DOM element.');
            return (
              isContainerMarkedAsRoot(container) &&
                void 0 === container._reactRootContainer &&
                error(
                  'You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?'
                ),
              legacyRenderSubtreeIntoContainer(null, element, container, !1, callback)
            );
          }),
          (exports.unmountComponentAtNode = function unmountComponentAtNode(container) {
            if (!isValidContainer(container))
              throw Error('unmountComponentAtNode(...): Target container is not a DOM element.');
            if (
              (isContainerMarkedAsRoot(container) &&
                void 0 === container._reactRootContainer &&
                error(
                  'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?'
                ),
              container._reactRootContainer)
            ) {
              var rootEl = getReactRootElementInContainer(container);
              return (
                rootEl &&
                  !getInstanceFromNode$1(rootEl) &&
                  error(
                    "unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React."
                  ),
                unbatchedUpdates(function () {
                  legacyRenderSubtreeIntoContainer(null, null, container, !1, function () {
                    (container._reactRootContainer = null), unmarkContainerAsRoot(container);
                  });
                }),
                !0
              );
            }
            var _rootEl = getReactRootElementInContainer(container),
              hasNonRootReactChild = !(!_rootEl || !getInstanceFromNode$1(_rootEl)),
              isContainerReactRoot =
                1 === container.nodeType &&
                isValidContainer(container.parentNode) &&
                !!container.parentNode._reactRootContainer;
            return (
              hasNonRootReactChild &&
                error(
                  "unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s",
                  isContainerReactRoot
                    ? 'You may have accidentally passed in a React root node instead of its container.'
                    : 'Instead, have the parent component update its state and rerender in order to remove this component.'
                ),
              !1
            );
          }),
          (exports.unstable_batchedUpdates = batchedUpdates$1),
          (exports.unstable_createPortal = function unstable_createPortal(children, container) {
            var key = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            return (
              didWarnAboutUnstableCreatePortal ||
                ((didWarnAboutUnstableCreatePortal = !0),
                warn(
                  'The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the "unstable_" prefix.'
                )),
              createPortal$1(children, container, key)
            );
          }),
          (exports.unstable_renderSubtreeIntoContainer = function renderSubtreeIntoContainer(
            parentComponent,
            element,
            containerNode,
            callback
          ) {
            return (function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
              if (!isValidContainer(containerNode)) throw Error('Target container is not a DOM element.');
              if (
                null == parentComponent ||
                !(function has(key) {
                  return void 0 !== key._reactInternalFiber;
                })(parentComponent)
              )
                throw Error('parentComponent must be a valid React Component');
              return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, !1, callback);
            })(parentComponent, element, containerNode, callback);
          }),
          (exports.version = '16.13.1');
      })();
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = __webpack_require__(86);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      (function () {
        var requestHostCallback, requestHostTimeout, cancelHostTimeout, shouldYieldToHost, requestPaint;
        if ('undefined' == typeof window || 'function' != typeof MessageChannel) {
          var _callback = null,
            _timeoutID = null,
            _flushCallback = function () {
              if (null !== _callback)
                try {
                  var currentTime = exports.unstable_now();
                  _callback(!0, currentTime), (_callback = null);
                } catch (e) {
                  throw (setTimeout(_flushCallback, 0), e);
                }
            },
            initialTime = Date.now();
          (exports.unstable_now = function () {
            return Date.now() - initialTime;
          }),
            (requestHostCallback = function (cb) {
              null !== _callback
                ? setTimeout(requestHostCallback, 0, cb)
                : ((_callback = cb), setTimeout(_flushCallback, 0));
            }),
            (requestHostTimeout = function (cb, ms) {
              _timeoutID = setTimeout(cb, ms);
            }),
            (cancelHostTimeout = function () {
              clearTimeout(_timeoutID);
            }),
            (shouldYieldToHost = function () {
              return !1;
            }),
            (requestPaint = exports.unstable_forceFrameRate = function () {});
        } else {
          var performance = window.performance,
            _Date = window.Date,
            _setTimeout = window.setTimeout,
            _clearTimeout = window.clearTimeout;
          if ('undefined' != typeof console) {
            var requestAnimationFrame = window.requestAnimationFrame,
              cancelAnimationFrame = window.cancelAnimationFrame;
            'function' != typeof requestAnimationFrame &&
              console.error(
                "This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"
              ),
              'function' != typeof cancelAnimationFrame &&
                console.error(
                  "This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"
                );
          }
          if ('object' == typeof performance && 'function' == typeof performance.now)
            exports.unstable_now = function () {
              return performance.now();
            };
          else {
            var _initialTime = _Date.now();
            exports.unstable_now = function () {
              return _Date.now() - _initialTime;
            };
          }
          var isMessageLoopRunning = !1,
            scheduledHostCallback = null,
            taskTimeoutID = -1,
            yieldInterval = 5,
            deadline = 0;
          (shouldYieldToHost = function () {
            return exports.unstable_now() >= deadline;
          }),
            (requestPaint = function () {}),
            (exports.unstable_forceFrameRate = function (fps) {
              fps < 0 || fps > 125
                ? console.error(
                    'forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported'
                  )
                : (yieldInterval = fps > 0 ? Math.floor(1e3 / fps) : 5);
            });
          var channel = new MessageChannel(),
            port = channel.port2;
          (channel.port1.onmessage = function () {
            if (null !== scheduledHostCallback) {
              var currentTime = exports.unstable_now();
              deadline = currentTime + yieldInterval;
              try {
                scheduledHostCallback(!0, currentTime)
                  ? port.postMessage(null)
                  : ((isMessageLoopRunning = !1), (scheduledHostCallback = null));
              } catch (error) {
                throw (port.postMessage(null), error);
              }
            } else isMessageLoopRunning = !1;
          }),
            (requestHostCallback = function (callback) {
              (scheduledHostCallback = callback),
                isMessageLoopRunning || ((isMessageLoopRunning = !0), port.postMessage(null));
            }),
            (requestHostTimeout = function (callback, ms) {
              taskTimeoutID = _setTimeout(function () {
                callback(exports.unstable_now());
              }, ms);
            }),
            (cancelHostTimeout = function () {
              _clearTimeout(taskTimeoutID), (taskTimeoutID = -1);
            });
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node),
            (function siftUp(heap, node, i) {
              var index = i;
              for (;;) {
                var parentIndex = (index - 1) >>> 1,
                  parent = heap[parentIndex];
                if (!(void 0 !== parent && compare(parent, node) > 0)) return;
                (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
              }
            })(heap, node, index);
        }
        function peek(heap) {
          var first = heap[0];
          return void 0 === first ? null : first;
        }
        function pop(heap) {
          var first = heap[0];
          if (void 0 !== first) {
            var last = heap.pop();
            return (
              last !== first &&
                ((heap[0] = last),
                (function siftDown(heap, node, i) {
                  var index = i,
                    length = heap.length;
                  for (; index < length; ) {
                    var leftIndex = 2 * (index + 1) - 1,
                      left = heap[leftIndex],
                      rightIndex = leftIndex + 1,
                      right = heap[rightIndex];
                    if (void 0 !== left && compare(left, node) < 0)
                      void 0 !== right && compare(right, left) < 0
                        ? ((heap[index] = right), (heap[rightIndex] = node), (index = rightIndex))
                        : ((heap[index] = left), (heap[leftIndex] = node), (index = leftIndex));
                    else {
                      if (!(void 0 !== right && compare(right, node) < 0)) return;
                      (heap[index] = right), (heap[rightIndex] = node), (index = rightIndex);
                    }
                  }
                })(heap, last, 0)),
              first
            );
          }
          return null;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        var runIdCounter = 0,
          mainThreadIdCounter = 0,
          sharedProfilingBuffer =
            'function' == typeof SharedArrayBuffer
              ? new SharedArrayBuffer(4 * Int32Array.BYTES_PER_ELEMENT)
              : 'function' == typeof ArrayBuffer
              ? new ArrayBuffer(4 * Int32Array.BYTES_PER_ELEMENT)
              : null,
          profilingState = null !== sharedProfilingBuffer ? new Int32Array(sharedProfilingBuffer) : [];
        (profilingState[0] = 0), (profilingState[3] = 0), (profilingState[1] = 0);
        var eventLogSize = 0,
          eventLogBuffer = null,
          eventLog = null,
          eventLogIndex = 0;
        function logEvent(entries) {
          if (null !== eventLog) {
            var offset = eventLogIndex;
            if ((eventLogIndex += entries.length) + 1 > eventLogSize) {
              if ((eventLogSize *= 2) > 524288)
                return (
                  console.error(
                    "Scheduler Profiling: Event log exceeded maximum size. Don't forget to call `stopLoggingProfilingEvents()`."
                  ),
                  void stopLoggingProfilingEvents()
                );
              var newEventLog = new Int32Array(4 * eventLogSize);
              newEventLog.set(eventLog), (eventLogBuffer = newEventLog.buffer), (eventLog = newEventLog);
            }
            eventLog.set(entries, offset);
          }
        }
        function stopLoggingProfilingEvents() {
          var buffer = eventLogBuffer;
          return (eventLogSize = 0), (eventLogBuffer = null), (eventLog = null), (eventLogIndex = 0), buffer;
        }
        function markTaskStart(task, ms) {
          profilingState[3]++, null !== eventLog && logEvent([1, 1e3 * ms, task.id, task.priorityLevel]);
        }
        function markTaskCompleted(task, ms) {
          (profilingState[0] = 0),
            (profilingState[1] = 0),
            profilingState[3]--,
            null !== eventLog && logEvent([2, 1e3 * ms, task.id]);
        }
        function markTaskYield(task, ms) {
          (profilingState[0] = 0),
            (profilingState[1] = 0),
            (profilingState[2] = 0),
            null !== eventLog && logEvent([6, 1e3 * ms, task.id, runIdCounter]);
        }
        var taskQueue = [],
          timerQueue = [],
          taskIdCounter = 1,
          currentTask = null,
          currentPriorityLevel = 3,
          isPerformingWork = !1,
          isHostCallbackScheduled = !1,
          isHostTimeoutScheduled = !1;
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else {
              if (!(timer.startTime <= currentTime)) return;
              pop(timerQueue),
                (timer.sortIndex = timer.expirationTime),
                push(taskQueue, timer),
                markTaskStart(timer, currentTime),
                (timer.isQueued = !0);
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          if (((isHostTimeoutScheduled = !1), advanceTimers(currentTime), !isHostCallbackScheduled))
            if (null !== peek(taskQueue)) (isHostCallbackScheduled = !0), requestHostCallback(flushWork);
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
        }
        function flushWork(hasTimeRemaining, initialTime) {
          !(function markSchedulerUnsuspended(ms) {
            null !== eventLog && logEvent([8, 1e3 * ms, mainThreadIdCounter]);
          })(initialTime),
            (isHostCallbackScheduled = !1),
            isHostTimeoutScheduled && ((isHostTimeoutScheduled = !1), cancelHostTimeout()),
            (isPerformingWork = !0);
          var previousPriorityLevel = currentPriorityLevel;
          try {
            try {
              return workLoop(hasTimeRemaining, initialTime);
            } catch (error) {
              if (null !== currentTask) {
                var currentTime = exports.unstable_now();
                !(function markTaskErrored(task, ms) {
                  (profilingState[0] = 0),
                    (profilingState[1] = 0),
                    profilingState[3]--,
                    null !== eventLog && logEvent([3, 1e3 * ms, task.id]);
                })(currentTask, currentTime),
                  (currentTask.isQueued = !1);
              }
              throw error;
            }
          } finally {
            (currentTask = null),
              (currentPriorityLevel = previousPriorityLevel),
              (isPerformingWork = !1),
              (function markSchedulerSuspended(ms) {
                mainThreadIdCounter++, null !== eventLog && logEvent([7, 1e3 * ms, mainThreadIdCounter]);
              })(exports.unstable_now());
          }
        }
        function workLoop(hasTimeRemaining, initialTime) {
          var task,
            ms,
            currentTime = initialTime;
          for (
            advanceTimers(currentTime), currentTask = peek(taskQueue);
            null !== currentTask &&
            (!(currentTask.expirationTime > currentTime) || (hasTimeRemaining && !shouldYieldToHost()));

          ) {
            var callback = currentTask.callback;
            if (null !== callback) {
              (currentTask.callback = null), (currentPriorityLevel = currentTask.priorityLevel);
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              (task = currentTask),
                (ms = currentTime),
                runIdCounter++,
                (profilingState[0] = task.priorityLevel),
                (profilingState[1] = task.id),
                (profilingState[2] = runIdCounter),
                null !== eventLog && logEvent([5, 1e3 * ms, task.id, runIdCounter]);
              var continuationCallback = callback(didUserCallbackTimeout);
              (currentTime = exports.unstable_now()),
                'function' == typeof continuationCallback
                  ? ((currentTask.callback = continuationCallback), markTaskYield(currentTask, currentTime))
                  : (markTaskCompleted(currentTask, currentTime),
                    (currentTask.isQueued = !1),
                    currentTask === peek(taskQueue) && pop(taskQueue)),
                advanceTimers(currentTime);
            } else pop(taskQueue);
            currentTask = peek(taskQueue);
          }
          if (null !== currentTask) return !0;
          var firstTimer = peek(timerQueue);
          return null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime), !1;
        }
        function timeoutForPriorityLevel(priorityLevel) {
          switch (priorityLevel) {
            case 1:
              return -1;
            case 2:
              return 250;
            case 5:
              return 1073741823;
            case 4:
              return 1e4;
            case 3:
            default:
              return 5e3;
          }
        }
        var unstable_requestPaint = requestPaint,
          unstable_Profiling = {
            startLoggingProfilingEvents: function startLoggingProfilingEvents() {
              (eventLogSize = 131072),
                (eventLogBuffer = new ArrayBuffer(4 * eventLogSize)),
                (eventLog = new Int32Array(eventLogBuffer)),
                (eventLogIndex = 0);
            },
            stopLoggingProfilingEvents,
            sharedProfilingBuffer,
          };
        (exports.unstable_IdlePriority = 5),
          (exports.unstable_ImmediatePriority = 1),
          (exports.unstable_LowPriority = 4),
          (exports.unstable_NormalPriority = 3),
          (exports.unstable_Profiling = unstable_Profiling),
          (exports.unstable_UserBlockingPriority = 2),
          (exports.unstable_cancelCallback = function unstable_cancelCallback(task) {
            task.isQueued &&
              (!(function markTaskCanceled(task, ms) {
                profilingState[3]--, null !== eventLog && logEvent([4, 1e3 * ms, task.id]);
              })(task, exports.unstable_now()),
              (task.isQueued = !1)),
              (task.callback = null);
          }),
          (exports.unstable_continueExecution = function unstable_continueExecution() {
            isHostCallbackScheduled ||
              isPerformingWork ||
              ((isHostCallbackScheduled = !0), requestHostCallback(flushWork));
          }),
          (exports.unstable_getCurrentPriorityLevel = function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }),
          (exports.unstable_getFirstCallbackNode = function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }),
          (exports.unstable_next = function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case 1:
              case 2:
              case 3:
                priorityLevel = 3;
                break;
              default:
                priorityLevel = currentPriorityLevel;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }),
          (exports.unstable_pauseExecution = function unstable_pauseExecution() {}),
          (exports.unstable_requestPaint = unstable_requestPaint),
          (exports.unstable_runWithPriority = function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                priorityLevel = 3;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }),
          (exports.unstable_scheduleCallback = function unstable_scheduleCallback(priorityLevel, callback, options) {
            var startTime,
              timeout,
              currentTime = exports.unstable_now();
            if ('object' == typeof options && null !== options) {
              var delay = options.delay;
              (startTime = 'number' == typeof delay && delay > 0 ? currentTime + delay : currentTime),
                (timeout =
                  'number' == typeof options.timeout ? options.timeout : timeoutForPriorityLevel(priorityLevel));
            } else (timeout = timeoutForPriorityLevel(priorityLevel)), (startTime = currentTime);
            var expirationTime = startTime + timeout,
              newTask = {
                id: taskIdCounter++,
                callback,
                priorityLevel,
                startTime,
                expirationTime,
                sortIndex: -1,
                isQueued: !1,
              };
            return (
              startTime > currentTime
                ? ((newTask.sortIndex = startTime),
                  push(timerQueue, newTask),
                  null === peek(taskQueue) &&
                    newTask === peek(timerQueue) &&
                    (isHostTimeoutScheduled ? cancelHostTimeout() : (isHostTimeoutScheduled = !0),
                    requestHostTimeout(handleTimeout, startTime - currentTime)))
                : ((newTask.sortIndex = expirationTime),
                  push(taskQueue, newTask),
                  markTaskStart(newTask, currentTime),
                  (newTask.isQueued = !0),
                  isHostCallbackScheduled ||
                    isPerformingWork ||
                    ((isHostCallbackScheduled = !0), requestHostCallback(flushWork))),
              newTask
            );
          }),
          (exports.unstable_shouldYield = function unstable_shouldYield() {
            var currentTime = exports.unstable_now();
            advanceTimers(currentTime);
            var firstTask = peek(taskQueue);
            return (
              (firstTask !== currentTask &&
                null !== currentTask &&
                null !== firstTask &&
                null !== firstTask.callback &&
                firstTask.startTime <= currentTime &&
                firstTask.expirationTime < currentTask.expirationTime) ||
              shouldYieldToHost()
            );
          }),
          (exports.unstable_wrapCallback = function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function () {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          });
      })();
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = __webpack_require__(88);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      (function () {
        var interactionIDCounter = 0,
          threadIDCounter = 0;
        (exports.__interactionsRef = null),
          (exports.__subscriberRef = null),
          (exports.__interactionsRef = { current: new Set() }),
          (exports.__subscriberRef = { current: null });
        var subscribers = null;
        function onInteractionTraced(interaction) {
          var didCatchError = !1,
            caughtError = null;
          if (
            (subscribers.forEach(function (subscriber) {
              try {
                subscriber.onInteractionTraced(interaction);
              } catch (error) {
                didCatchError || ((didCatchError = !0), (caughtError = error));
              }
            }),
            didCatchError)
          )
            throw caughtError;
        }
        function onInteractionScheduledWorkCompleted(interaction) {
          var didCatchError = !1,
            caughtError = null;
          if (
            (subscribers.forEach(function (subscriber) {
              try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              } catch (error) {
                didCatchError || ((didCatchError = !0), (caughtError = error));
              }
            }),
            didCatchError)
          )
            throw caughtError;
        }
        function onWorkScheduled(interactions, threadID) {
          var didCatchError = !1,
            caughtError = null;
          if (
            (subscribers.forEach(function (subscriber) {
              try {
                subscriber.onWorkScheduled(interactions, threadID);
              } catch (error) {
                didCatchError || ((didCatchError = !0), (caughtError = error));
              }
            }),
            didCatchError)
          )
            throw caughtError;
        }
        function onWorkStarted(interactions, threadID) {
          var didCatchError = !1,
            caughtError = null;
          if (
            (subscribers.forEach(function (subscriber) {
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error) {
                didCatchError || ((didCatchError = !0), (caughtError = error));
              }
            }),
            didCatchError)
          )
            throw caughtError;
        }
        function onWorkStopped(interactions, threadID) {
          var didCatchError = !1,
            caughtError = null;
          if (
            (subscribers.forEach(function (subscriber) {
              try {
                subscriber.onWorkStopped(interactions, threadID);
              } catch (error) {
                didCatchError || ((didCatchError = !0), (caughtError = error));
              }
            }),
            didCatchError)
          )
            throw caughtError;
        }
        function onWorkCanceled(interactions, threadID) {
          var didCatchError = !1,
            caughtError = null;
          if (
            (subscribers.forEach(function (subscriber) {
              try {
                subscriber.onWorkCanceled(interactions, threadID);
              } catch (error) {
                didCatchError || ((didCatchError = !0), (caughtError = error));
              }
            }),
            didCatchError)
          )
            throw caughtError;
        }
        (subscribers = new Set()),
          (exports.unstable_clear = function unstable_clear(callback) {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = new Set();
            try {
              return callback();
            } finally {
              exports.__interactionsRef.current = prevInteractions;
            }
          }),
          (exports.unstable_getCurrent = function unstable_getCurrent() {
            return exports.__interactionsRef.current;
          }),
          (exports.unstable_getThreadID = function unstable_getThreadID() {
            return ++threadIDCounter;
          }),
          (exports.unstable_subscribe = function unstable_subscribe(subscriber) {
            subscribers.add(subscriber),
              1 === subscribers.size &&
                (exports.__subscriberRef.current = {
                  onInteractionScheduledWorkCompleted,
                  onInteractionTraced,
                  onWorkCanceled,
                  onWorkScheduled,
                  onWorkStarted,
                  onWorkStopped,
                });
          }),
          (exports.unstable_trace = function unstable_trace(name, timestamp, callback) {
            var threadID = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
              interaction = { __count: 1, id: interactionIDCounter++, name, timestamp },
              prevInteractions = exports.__interactionsRef.current,
              interactions = new Set(prevInteractions);
            interactions.add(interaction), (exports.__interactionsRef.current = interactions);
            var returnValue,
              subscriber = exports.__subscriberRef.current;
            try {
              null !== subscriber && subscriber.onInteractionTraced(interaction);
            } finally {
              try {
                null !== subscriber && subscriber.onWorkStarted(interactions, threadID);
              } finally {
                try {
                  returnValue = callback();
                } finally {
                  exports.__interactionsRef.current = prevInteractions;
                  try {
                    null !== subscriber && subscriber.onWorkStopped(interactions, threadID);
                  } finally {
                    interaction.__count--,
                      null !== subscriber &&
                        0 === interaction.__count &&
                        subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                }
              }
            }
            return returnValue;
          }),
          (exports.unstable_unsubscribe = function unstable_unsubscribe(subscriber) {
            subscribers.delete(subscriber), 0 === subscribers.size && (exports.__subscriberRef.current = null);
          }),
          (exports.unstable_wrap = function unstable_wrap(callback) {
            var threadID = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
              wrappedInteractions = exports.__interactionsRef.current,
              subscriber = exports.__subscriberRef.current;
            null !== subscriber && subscriber.onWorkScheduled(wrappedInteractions, threadID),
              wrappedInteractions.forEach(function (interaction) {
                interaction.__count++;
              });
            var hasRun = !1;
            function wrapped() {
              var prevInteractions = exports.__interactionsRef.current;
              (exports.__interactionsRef.current = wrappedInteractions), (subscriber = exports.__subscriberRef.current);
              try {
                var returnValue;
                try {
                  null !== subscriber && subscriber.onWorkStarted(wrappedInteractions, threadID);
                } finally {
                  try {
                    returnValue = callback.apply(void 0, arguments);
                  } finally {
                    (exports.__interactionsRef.current = prevInteractions),
                      null !== subscriber && subscriber.onWorkStopped(wrappedInteractions, threadID);
                  }
                }
                return returnValue;
              } finally {
                hasRun ||
                  ((hasRun = !0),
                  wrappedInteractions.forEach(function (interaction) {
                    interaction.__count--,
                      null !== subscriber &&
                        0 === interaction.__count &&
                        subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }));
              }
            }
            return (
              (wrapped.cancel = function cancel() {
                subscriber = exports.__subscriberRef.current;
                try {
                  null !== subscriber && subscriber.onWorkCanceled(wrappedInteractions, threadID);
                } finally {
                  wrappedInteractions.forEach(function (interaction) {
                    interaction.__count--,
                      subscriber &&
                        0 === interaction.__count &&
                        subscriber.onInteractionScheduledWorkCompleted(interaction);
                  });
                }
              }),
              wrapped
            );
          });
      })();
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      'undefined' == typeof window
        ? (module.exports = __webpack_require__(46))
        : ((module.exports = __webpack_require__(46)),
          (module.exports.AppContainer.warnAboutHMRDisabled = !0),
          (module.exports.hot.shouldWrapWithAppContainer = !0));
    },
    ,
    ,
    function (module, exports) {
      module.exports = function (originalModule) {
        if (!originalModule.webpackPolyfill) {
          var module = Object.create(originalModule);
          module.children || (module.children = []),
            Object.defineProperty(module, 'loaded', {
              enumerable: !0,
              get: function () {
                return module.l;
              },
            }),
            Object.defineProperty(module, 'id', {
              enumerable: !0,
              get: function () {
                return module.i;
              },
            }),
            Object.defineProperty(module, 'exports', { enumerable: !0 }),
            (module.webpackPolyfill = 1);
        }
        return module;
      };
    },
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      var __assign =
          (this && this.__assign) ||
          function () {
            return (__assign =
              Object.assign ||
              function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++)
                  for (var p in (s = arguments[i])) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
                return t;
              }).apply(this, arguments);
          },
        __spreadArrays =
          (this && this.__spreadArrays) ||
          function () {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
            var r = Array(s),
              k = 0;
            for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
            return r;
          };
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var types_1 = __webpack_require__(23),
        INITIAL_ENTITY_STATE = { data: void 0, lastUpdated: void 0, isFetching: !1, error: void 0 },
        INITIAL_STATE = {};
      function deriveNewData(stateData, payload) {
        var data = payload.data;
        if (!payload.append) return data;
        var newData = (function toArray(obj) {
          return Array.isArray(obj) ? obj : [obj];
        })(data);
        return stateData ? __spreadArrays(stateData, newData) : newData;
      }
      exports.default = function entities(state, action) {
        var _a;
        void 0 === state && (state = INITIAL_STATE);
        var type = action.type,
          entity = action.entity;
        switch (type) {
          case types_1.EntityActionType.Reset:
          case types_1.EntityActionType.Success:
          case types_1.EntityActionType.Failure:
          case types_1.EntityActionType.Request:
            return __assign(
              __assign({}, state),
              (((_a = {})[entity] = (function entityReducer(state, action) {
                void 0 === state && (state = INITIAL_ENTITY_STATE);
                var type = action.type,
                  payload = action.payload;
                switch (type) {
                  case types_1.EntityActionType.Request:
                    return __assign(__assign({}, state), { isFetching: !0, error: void 0 });
                  case types_1.EntityActionType.Success:
                    var newData = deriveNewData(state.data, payload);
                    return __assign(__assign({}, state), {
                      isFetching: !1,
                      lastUpdated: payload.lastUpdated,
                      data: newData,
                      error: void 0,
                    });
                  case types_1.EntityActionType.Failure:
                    return __assign(__assign({}, state), {
                      isFetching: !1,
                      lastUpdated: payload.lastUpdated,
                      data: void 0,
                      error: payload.error,
                    });
                  case types_1.EntityActionType.Reset:
                    return __assign(__assign({}, INITIAL_ENTITY_STATE), { lastUpdated: payload.lastUpdated });
                  default:
                    return state;
                }
              })(state[entity], action)),
              _a)
            );
          case types_1.EntityActionType.Delete:
            var newState = __assign({}, state);
            return delete newState[entity], newState;
          default:
            return state;
        }
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var EntityLifecycle_1 = __importDefault(__webpack_require__(96)),
        validator_1 = __webpack_require__(97),
        actions_1 = __webpack_require__(36);
      exports.default = function (entityName, promise, options) {
        if (!entityName || 'string' != typeof entityName) throw new Error('Missing required entityName');
        if (!promise || !promise.then) throw new Error('Missing required entity promise');
        validator_1.validate(options);
        var lifecycle = new EntityLifecycle_1.default({ entityName, options });
        return function (dispatch, getState) {
          if (!lifecycle.silent) {
            var fetchAction = actions_1.fetchRequestCreator(entityName);
            dispatch(fetchAction());
          }
          return new Promise(function (resolve, reject) {
            promise
              .then(function (data) {
                return resolve(lifecycle.onSuccess(data, dispatch, getState));
              })
              .catch(function (error) {
                return reject(lifecycle.onFailure(error, dispatch, getState));
              });
          });
        };
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var actions_1 = __webpack_require__(36),
        types_1 = __webpack_require__(23),
        EntityLifecycle = (function () {
          function EntityLifecycle(_a) {
            var entityName = _a.entityName,
              options = _a.options;
            (this.entityName = entityName),
              (this.append = (null == options ? void 0 : options.append) || !1),
              (this.silent = (null == options ? void 0 : options.silent) || !1),
              (this.processors = (null == options ? void 0 : options.processors) || {});
          }
          return (
            (EntityLifecycle.prototype.onSuccess = function (data, dispatch, getState) {
              var dispatchedData = this.processStage(types_1.ProcessorType.BeforeSuccess, data, dispatch, getState);
              return (
                dispatch(actions_1.fetchSuccessCreator(this.entityName)(dispatchedData, new Date(), this.append)),
                this.processStage(types_1.ProcessorType.AfterSuccess, dispatchedData, dispatch, getState),
                dispatchedData
              );
            }),
            (EntityLifecycle.prototype.onFailure = function (error, dispatch, getState) {
              var dispatchedError = this.processStage(types_1.ProcessorType.BeforeFailure, error, dispatch, getState);
              return (
                dispatch(actions_1.fetchFailureCreator(this.entityName)(dispatchedError, new Date())),
                this.processStage(types_1.ProcessorType.AfterFailure, dispatchedError, dispatch, getState),
                dispatchedError
              );
            }),
            (EntityLifecycle.prototype.processStage = function (processorType, data, dispatch, getState) {
              if (!processorType) throw new Error('Missing required processorType');
              var processor = this.processors[processorType];
              return processor && 'function' == typeof processor ? processor(data, dispatch, getState) : data;
            }),
            EntityLifecycle
          );
        })();
      exports.default = EntityLifecycle;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }), (exports.validate = void 0);
      var types_1 = __webpack_require__(23);
      exports.validate = function (options) {
        if (options) {
          if (
            'string' == typeof options ||
            'number' == typeof options ||
            'function' == typeof options ||
            Array.isArray(options)
          )
            throw new Error(
              'Options must be an object of type ReduxEntityOptions. See https://github.com/mikechabot/redux-entity#configuration-options'
            );
          Object.keys(options).forEach(function (key) {
            if (!Object.values(types_1.OptionKey).includes(key)) throw new Error('Unexpected top-level option: ' + key);
            var type = typeof options[key],
              value = options[key];
            if (key === types_1.OptionKey.Append && 'boolean' !== type)
              throw new Error('Invalid type for "' + types_1.OptionKey.Append + ', expected "boolean"');
            if (key === types_1.OptionKey.Silent && 'boolean' !== type)
              throw new Error('Invalid type for "' + types_1.OptionKey.Silent + ', expected "boolean"');
            if (key === types_1.OptionKey.Processors) {
              if (!value || Array.isArray(value) || 'object' !== type)
                throw new Error('Invalid type for ' + types_1.OptionKey.Processors + ', expected "object"');
              var processors_1 = value;
              Object.keys(processors_1).forEach(function (processorType) {
                if (!Object.values(types_1.ProcessorType).includes(processorType))
                  throw new Error('Invalid processorType: "' + processorType + '"');
                var processor = processors_1[processorType];
                if ('function' != typeof processor)
                  throw new Error('Expected function for processorType, but found "' + typeof processor + '"');
              });
            }
          });
        }
      };
    },
    ,
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      (function () {
        var hasSymbol = 'function' == typeof Symbol && Symbol.for,
          REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 60103,
          REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 60106,
          REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 60107,
          REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 60108,
          REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 60114,
          REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 60109,
          REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 60110,
          REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 60111,
          REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 60111,
          REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 60112,
          REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 60113,
          REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 60120,
          REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 60115,
          REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 60116,
          REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 60121,
          REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 60117,
          REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 60118,
          REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 60119;
        function typeOf(object) {
          if ('object' == typeof object && null !== object) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE,
          ConcurrentMode = REACT_CONCURRENT_MODE_TYPE,
          ContextConsumer = REACT_CONTEXT_TYPE,
          ContextProvider = REACT_PROVIDER_TYPE,
          Element = REACT_ELEMENT_TYPE,
          ForwardRef = REACT_FORWARD_REF_TYPE,
          Fragment = REACT_FRAGMENT_TYPE,
          Lazy = REACT_LAZY_TYPE,
          Memo = REACT_MEMO_TYPE,
          Portal = REACT_PORTAL_TYPE,
          Profiler = REACT_PROFILER_TYPE,
          StrictMode = REACT_STRICT_MODE_TYPE,
          Suspense = REACT_SUSPENSE_TYPE,
          hasWarnedAboutDeprecatedIsAsyncMode = !1;
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        (exports.AsyncMode = AsyncMode),
          (exports.ConcurrentMode = ConcurrentMode),
          (exports.ContextConsumer = ContextConsumer),
          (exports.ContextProvider = ContextProvider),
          (exports.Element = Element),
          (exports.ForwardRef = ForwardRef),
          (exports.Fragment = Fragment),
          (exports.Lazy = Lazy),
          (exports.Memo = Memo),
          (exports.Portal = Portal),
          (exports.Profiler = Profiler),
          (exports.StrictMode = StrictMode),
          (exports.Suspense = Suspense),
          (exports.isAsyncMode = function isAsyncMode(object) {
            return (
              hasWarnedAboutDeprecatedIsAsyncMode ||
                ((hasWarnedAboutDeprecatedIsAsyncMode = !0),
                console.warn(
                  'The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.'
                )),
              isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE
            );
          }),
          (exports.isConcurrentMode = isConcurrentMode),
          (exports.isContextConsumer = function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }),
          (exports.isContextProvider = function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }),
          (exports.isElement = function isElement(object) {
            return 'object' == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
          }),
          (exports.isForwardRef = function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }),
          (exports.isFragment = function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }),
          (exports.isLazy = function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }),
          (exports.isMemo = function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }),
          (exports.isPortal = function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }),
          (exports.isProfiler = function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }),
          (exports.isStrictMode = function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }),
          (exports.isSuspense = function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }),
          (exports.isValidElementType = function isValidElementType(type) {
            return (
              'string' == typeof type ||
              'function' == typeof type ||
              type === REACT_FRAGMENT_TYPE ||
              type === REACT_CONCURRENT_MODE_TYPE ||
              type === REACT_PROFILER_TYPE ||
              type === REACT_STRICT_MODE_TYPE ||
              type === REACT_SUSPENSE_TYPE ||
              type === REACT_SUSPENSE_LIST_TYPE ||
              ('object' == typeof type &&
                null !== type &&
                (type.$$typeof === REACT_LAZY_TYPE ||
                  type.$$typeof === REACT_MEMO_TYPE ||
                  type.$$typeof === REACT_PROVIDER_TYPE ||
                  type.$$typeof === REACT_CONTEXT_TYPE ||
                  type.$$typeof === REACT_FORWARD_REF_TYPE ||
                  type.$$typeof === REACT_FUNDAMENTAL_TYPE ||
                  type.$$typeof === REACT_RESPONDER_TYPE ||
                  type.$$typeof === REACT_SCOPE_TYPE ||
                  type.$$typeof === REACT_BLOCK_TYPE))
            );
          }),
          (exports.typeOf = typeOf);
      })();
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var ReactIs = __webpack_require__(10),
        assign = __webpack_require__(15),
        ReactPropTypesSecret = __webpack_require__(45),
        checkPropTypes = __webpack_require__(33),
        has = Function.call.bind(Object.prototype.hasOwnProperty),
        printWarning = function () {};
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      (printWarning = function (text) {
        var message = 'Warning: ' + text;
        'undefined' != typeof console && console.error(message);
        try {
          throw new Error(message);
        } catch (x) {}
      }),
        (module.exports = function (isValidElement, throwOnDirectAccess) {
          var ITERATOR_SYMBOL = 'function' == typeof Symbol && Symbol.iterator;
          var ReactPropTypes = {
            array: createPrimitiveTypeChecker('array'),
            bool: createPrimitiveTypeChecker('boolean'),
            func: createPrimitiveTypeChecker('function'),
            number: createPrimitiveTypeChecker('number'),
            object: createPrimitiveTypeChecker('object'),
            string: createPrimitiveTypeChecker('string'),
            symbol: createPrimitiveTypeChecker('symbol'),
            any: (function createAnyTypeChecker() {
              return createChainableTypeChecker(emptyFunctionThatReturnsNull);
            })(),
            arrayOf: function createArrayOfTypeChecker(typeChecker) {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                if ('function' != typeof typeChecker)
                  return new PropTypeError(
                    'Property `' +
                      propFullName +
                      '` of component `' +
                      componentName +
                      '` has invalid PropType notation inside arrayOf.'
                  );
                var propValue = props[propName];
                if (!Array.isArray(propValue))
                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` of type `' +
                      getPropType(propValue) +
                      '` supplied to `' +
                      componentName +
                      '`, expected an array.'
                  );
                for (var i = 0; i < propValue.length; i++) {
                  var error = typeChecker(
                    propValue,
                    i,
                    componentName,
                    location,
                    propFullName + '[' + i + ']',
                    ReactPropTypesSecret
                  );
                  if (error instanceof Error) return error;
                }
                return null;
              });
            },
            element: (function createElementTypeChecker() {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                var propValue = props[propName];
                return isValidElement(propValue)
                  ? null
                  : new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type `' +
                        getPropType(propValue) +
                        '` supplied to `' +
                        componentName +
                        '`, expected a single ReactElement.'
                    );
              });
            })(),
            elementType: (function createElementTypeTypeChecker() {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                var propValue = props[propName];
                return ReactIs.isValidElementType(propValue)
                  ? null
                  : new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` of type `' +
                        getPropType(propValue) +
                        '` supplied to `' +
                        componentName +
                        '`, expected a single ReactElement type.'
                    );
              });
            })(),
            instanceOf: function createInstanceTypeChecker(expectedClass) {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                if (!(props[propName] instanceof expectedClass)) {
                  var expectedClassName = expectedClass.name || '<<anonymous>>';
                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` of type `' +
                      (function getClassName(propValue) {
                        if (!propValue.constructor || !propValue.constructor.name) return '<<anonymous>>';
                        return propValue.constructor.name;
                      })(props[propName]) +
                      '` supplied to `' +
                      componentName +
                      '`, expected instance of `' +
                      expectedClassName +
                      '`.'
                  );
                }
                return null;
              });
            },
            node: (function createNodeChecker() {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                return isNode(props[propName])
                  ? null
                  : new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` supplied to `' +
                        componentName +
                        '`, expected a ReactNode.'
                    );
              });
            })(),
            objectOf: function createObjectOfTypeChecker(typeChecker) {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                if ('function' != typeof typeChecker)
                  return new PropTypeError(
                    'Property `' +
                      propFullName +
                      '` of component `' +
                      componentName +
                      '` has invalid PropType notation inside objectOf.'
                  );
                var propValue = props[propName],
                  propType = getPropType(propValue);
                if ('object' !== propType)
                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` of type `' +
                      propType +
                      '` supplied to `' +
                      componentName +
                      '`, expected an object.'
                  );
                for (var key in propValue)
                  if (has(propValue, key)) {
                    var error = typeChecker(
                      propValue,
                      key,
                      componentName,
                      location,
                      propFullName + '.' + key,
                      ReactPropTypesSecret
                    );
                    if (error instanceof Error) return error;
                  }
                return null;
              });
            },
            oneOf: function createEnumTypeChecker(expectedValues) {
              if (!Array.isArray(expectedValues))
                return (
                  printWarning(
                    arguments.length > 1
                      ? 'Invalid arguments supplied to oneOf, expected an array, got ' +
                          arguments.length +
                          ' arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
                      : 'Invalid argument supplied to oneOf, expected an array.'
                  ),
                  emptyFunctionThatReturnsNull
                );
              function validate(props, propName, componentName, location, propFullName) {
                for (var propValue = props[propName], i = 0; i < expectedValues.length; i++)
                  if (is(propValue, expectedValues[i])) return null;
                var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                  return 'symbol' === getPreciseType(value) ? String(value) : value;
                });
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of value `' +
                    String(propValue) +
                    '` supplied to `' +
                    componentName +
                    '`, expected one of ' +
                    valuesString +
                    '.'
                );
              }
              return createChainableTypeChecker(validate);
            },
            oneOfType: function createUnionTypeChecker(arrayOfTypeCheckers) {
              if (!Array.isArray(arrayOfTypeCheckers))
                return (
                  printWarning('Invalid argument supplied to oneOfType, expected an instance of array.'),
                  emptyFunctionThatReturnsNull
                );
              for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];
                if ('function' != typeof checker)
                  return (
                    printWarning(
                      'Invalid argument supplied to oneOfType. Expected an array of check functions, but received ' +
                        getPostfixForTypeWarning(checker) +
                        ' at index ' +
                        i +
                        '.'
                    ),
                    emptyFunctionThatReturnsNull
                  );
              }
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                  if (
                    null ==
                    (0, arrayOfTypeCheckers[i])(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName,
                      ReactPropTypesSecret
                    )
                  )
                    return null;
                }
                return new PropTypeError(
                  'Invalid ' + location + ' `' + propFullName + '` supplied to `' + componentName + '`.'
                );
              });
            },
            shape: function createShapeTypeChecker(shapeTypes) {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                var propValue = props[propName],
                  propType = getPropType(propValue);
                if ('object' !== propType)
                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` of type `' +
                      propType +
                      '` supplied to `' +
                      componentName +
                      '`, expected `object`.'
                  );
                for (var key in shapeTypes) {
                  var checker = shapeTypes[key];
                  if (checker) {
                    var error = checker(
                      propValue,
                      key,
                      componentName,
                      location,
                      propFullName + '.' + key,
                      ReactPropTypesSecret
                    );
                    if (error) return error;
                  }
                }
                return null;
              });
            },
            exact: function createStrictShapeTypeChecker(shapeTypes) {
              return createChainableTypeChecker(function validate(
                props,
                propName,
                componentName,
                location,
                propFullName
              ) {
                var propValue = props[propName],
                  propType = getPropType(propValue);
                if ('object' !== propType)
                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` of type `' +
                      propType +
                      '` supplied to `' +
                      componentName +
                      '`, expected `object`.'
                  );
                var allKeys = assign({}, props[propName], shapeTypes);
                for (var key in allKeys) {
                  var checker = shapeTypes[key];
                  if (!checker)
                    return new PropTypeError(
                      'Invalid ' +
                        location +
                        ' `' +
                        propFullName +
                        '` key `' +
                        key +
                        '` supplied to `' +
                        componentName +
                        '`.\nBad object: ' +
                        JSON.stringify(props[propName], null, '  ') +
                        '\nValid keys: ' +
                        JSON.stringify(Object.keys(shapeTypes), null, '  ')
                    );
                  var error = checker(
                    propValue,
                    key,
                    componentName,
                    location,
                    propFullName + '.' + key,
                    ReactPropTypesSecret
                  );
                  if (error) return error;
                }
                return null;
              });
            },
          };
          function is(x, y) {
            return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y;
          }
          function PropTypeError(message) {
            (this.message = message), (this.stack = '');
          }
          function createChainableTypeChecker(validate) {
            var manualPropTypeCallCache = {},
              manualPropTypeWarningCount = 0;
            function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
              if (
                ((componentName = componentName || '<<anonymous>>'),
                (propFullName = propFullName || propName),
                secret !== ReactPropTypesSecret)
              ) {
                if (throwOnDirectAccess) {
                  var err = new Error(
                    'Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types'
                  );
                  throw ((err.name = 'Invariant Violation'), err);
                }
                if ('undefined' != typeof console) {
                  var cacheKey = componentName + ':' + propName;
                  !manualPropTypeCallCache[cacheKey] &&
                    manualPropTypeWarningCount < 3 &&
                    (printWarning(
                      'You are manually calling a React.PropTypes validation function for the `' +
                        propFullName +
                        '` prop on `' +
                        componentName +
                        '`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.'
                    ),
                    (manualPropTypeCallCache[cacheKey] = !0),
                    manualPropTypeWarningCount++);
                }
              }
              return null == props[propName]
                ? isRequired
                  ? null === props[propName]
                    ? new PropTypeError(
                        'The ' +
                          location +
                          ' `' +
                          propFullName +
                          '` is marked as required in `' +
                          componentName +
                          '`, but its value is `null`.'
                      )
                    : new PropTypeError(
                        'The ' +
                          location +
                          ' `' +
                          propFullName +
                          '` is marked as required in `' +
                          componentName +
                          '`, but its value is `undefined`.'
                      )
                  : null
                : validate(props, propName, componentName, location, propFullName);
            }
            var chainedCheckType = checkType.bind(null, !1);
            return (chainedCheckType.isRequired = checkType.bind(null, !0)), chainedCheckType;
          }
          function createPrimitiveTypeChecker(expectedType) {
            return createChainableTypeChecker(function validate(
              props,
              propName,
              componentName,
              location,
              propFullName,
              secret
            ) {
              var propValue = props[propName];
              return getPropType(propValue) !== expectedType
                ? new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` of type `' +
                      getPreciseType(propValue) +
                      '` supplied to `' +
                      componentName +
                      '`, expected `' +
                      expectedType +
                      '`.'
                  )
                : null;
            });
          }
          function isNode(propValue) {
            switch (typeof propValue) {
              case 'number':
              case 'string':
              case 'undefined':
                return !0;
              case 'boolean':
                return !propValue;
              case 'object':
                if (Array.isArray(propValue)) return propValue.every(isNode);
                if (null === propValue || isValidElement(propValue)) return !0;
                var iteratorFn = (function getIteratorFn(maybeIterable) {
                  var iteratorFn =
                    maybeIterable &&
                    ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) || maybeIterable['@@iterator']);
                  if ('function' == typeof iteratorFn) return iteratorFn;
                })(propValue);
                if (!iteratorFn) return !1;
                var step,
                  iterator = iteratorFn.call(propValue);
                if (iteratorFn !== propValue.entries) {
                  for (; !(step = iterator.next()).done; ) if (!isNode(step.value)) return !1;
                } else
                  for (; !(step = iterator.next()).done; ) {
                    var entry = step.value;
                    if (entry && !isNode(entry[1])) return !1;
                  }
                return !0;
              default:
                return !1;
            }
          }
          function getPropType(propValue) {
            var propType = typeof propValue;
            return Array.isArray(propValue)
              ? 'array'
              : propValue instanceof RegExp
              ? 'object'
              : (function isSymbol(propType, propValue) {
                  return (
                    'symbol' === propType ||
                    (!!propValue &&
                      ('Symbol' === propValue['@@toStringTag'] ||
                        ('function' == typeof Symbol && propValue instanceof Symbol)))
                  );
                })(propType, propValue)
              ? 'symbol'
              : propType;
          }
          function getPreciseType(propValue) {
            if (null == propValue) return '' + propValue;
            var propType = getPropType(propValue);
            if ('object' === propType) {
              if (propValue instanceof Date) return 'date';
              if (propValue instanceof RegExp) return 'regexp';
            }
            return propType;
          }
          function getPostfixForTypeWarning(value) {
            var type = getPreciseType(value);
            switch (type) {
              case 'array':
              case 'object':
                return 'an ' + type;
              case 'boolean':
              case 'date':
              case 'regexp':
                return 'a ' + type;
              default:
                return type;
            }
          }
          return (
            (PropTypeError.prototype = Error.prototype),
            (ReactPropTypes.checkPropTypes = checkPropTypes),
            (ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache),
            (ReactPropTypes.PropTypes = ReactPropTypes),
            ReactPropTypes
          );
        });
    },
    function (module, exports) {
      module.exports =
        Array.isArray ||
        function (arr) {
          return '[object Array]' == Object.prototype.toString.call(arr);
        };
    },
    function (module, exports, __webpack_require__) {
      var baseGet = __webpack_require__(104);
      module.exports = function get(object, path, defaultValue) {
        var result = null == object ? void 0 : baseGet(object, path);
        return void 0 === result ? defaultValue : result;
      };
    },
    function (module, exports, __webpack_require__) {
      var castPath = __webpack_require__(105),
        toKey = __webpack_require__(139);
      module.exports = function baseGet(object, path) {
        for (var index = 0, length = (path = castPath(path, object)).length; null != object && index < length; )
          object = object[toKey(path[index++])];
        return index && index == length ? object : void 0;
      };
    },
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(24),
        isKey = __webpack_require__(106),
        stringToPath = __webpack_require__(109),
        toString = __webpack_require__(136);
      module.exports = function castPath(value, object) {
        return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value));
      };
    },
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(24),
        isSymbol = __webpack_require__(37),
        reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;
      module.exports = function isKey(value, object) {
        if (isArray(value)) return !1;
        var type = typeof value;
        return (
          !('number' != type && 'symbol' != type && 'boolean' != type && null != value && !isSymbol(value)) ||
          reIsPlainProp.test(value) ||
          !reIsDeepProp.test(value) ||
          (null != object && value in Object(object))
        );
      };
    },
    function (module, exports, __webpack_require__) {
      var Symbol = __webpack_require__(38),
        objectProto = Object.prototype,
        hasOwnProperty = objectProto.hasOwnProperty,
        nativeObjectToString = objectProto.toString,
        symToStringTag = Symbol ? Symbol.toStringTag : void 0;
      module.exports = function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = !0;
        } catch (e) {}
        var result = nativeObjectToString.call(value);
        return unmasked && (isOwn ? (value[symToStringTag] = tag) : delete value[symToStringTag]), result;
      };
    },
    function (module, exports) {
      var nativeObjectToString = Object.prototype.toString;
      module.exports = function objectToString(value) {
        return nativeObjectToString.call(value);
      };
    },
    function (module, exports, __webpack_require__) {
      var memoizeCapped = __webpack_require__(110),
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        reEscapeChar = /\\(\\)?/g,
        stringToPath = memoizeCapped(function (string) {
          var result = [];
          return (
            46 === string.charCodeAt(0) && result.push(''),
            string.replace(rePropName, function (match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
            }),
            result
          );
        });
      module.exports = stringToPath;
    },
    function (module, exports, __webpack_require__) {
      var memoize = __webpack_require__(111);
      module.exports = function memoizeCapped(func) {
        var result = memoize(func, function (key) {
            return 500 === cache.size && cache.clear(), key;
          }),
          cache = result.cache;
        return result;
      };
    },
    function (module, exports, __webpack_require__) {
      var MapCache = __webpack_require__(112);
      function memoize(func, resolver) {
        if ('function' != typeof func || (null != resolver && 'function' != typeof resolver))
          throw new TypeError('Expected a function');
        var memoized = function () {
          var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;
          if (cache.has(key)) return cache.get(key);
          var result = func.apply(this, args);
          return (memoized.cache = cache.set(key, result) || cache), result;
        };
        return (memoized.cache = new (memoize.Cache || MapCache)()), memoized;
      }
      (memoize.Cache = MapCache), (module.exports = memoize);
    },
    function (module, exports, __webpack_require__) {
      var mapCacheClear = __webpack_require__(113),
        mapCacheDelete = __webpack_require__(131),
        mapCacheGet = __webpack_require__(133),
        mapCacheHas = __webpack_require__(134),
        mapCacheSet = __webpack_require__(135);
      function MapCache(entries) {
        var index = -1,
          length = null == entries ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      (MapCache.prototype.clear = mapCacheClear),
        (MapCache.prototype.delete = mapCacheDelete),
        (MapCache.prototype.get = mapCacheGet),
        (MapCache.prototype.has = mapCacheHas),
        (MapCache.prototype.set = mapCacheSet),
        (module.exports = MapCache);
    },
    function (module, exports, __webpack_require__) {
      var Hash = __webpack_require__(114),
        ListCache = __webpack_require__(124),
        Map = __webpack_require__(57);
      module.exports = function mapCacheClear() {
        (this.size = 0), (this.__data__ = { hash: new Hash(), map: new (Map || ListCache)(), string: new Hash() });
      };
    },
    function (module, exports, __webpack_require__) {
      var hashClear = __webpack_require__(115),
        hashDelete = __webpack_require__(120),
        hashGet = __webpack_require__(121),
        hashHas = __webpack_require__(122),
        hashSet = __webpack_require__(123);
      function Hash(entries) {
        var index = -1,
          length = null == entries ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      (Hash.prototype.clear = hashClear),
        (Hash.prototype.delete = hashDelete),
        (Hash.prototype.get = hashGet),
        (Hash.prototype.has = hashHas),
        (Hash.prototype.set = hashSet),
        (module.exports = Hash);
    },
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(26);
      module.exports = function hashClear() {
        (this.__data__ = nativeCreate ? nativeCreate(null) : {}), (this.size = 0);
      };
    },
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(54),
        isMasked = __webpack_require__(117),
        isObject = __webpack_require__(55),
        toSource = __webpack_require__(56),
        reIsHostCtor = /^\[object .+?Constructor\]$/,
        funcProto = Function.prototype,
        objectProto = Object.prototype,
        funcToString = funcProto.toString,
        hasOwnProperty = objectProto.hasOwnProperty,
        reIsNative = RegExp(
          '^' +
            funcToString
              .call(hasOwnProperty)
              .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
              .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
            '$'
        );
      module.exports = function baseIsNative(value) {
        return (
          !(!isObject(value) || isMasked(value)) &&
          (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value))
        );
      };
    },
    function (module, exports, __webpack_require__) {
      var uid,
        coreJsData = __webpack_require__(118),
        maskSrcKey = (uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ''))
          ? 'Symbol(src)_1.' + uid
          : '';
      module.exports = function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      };
    },
    function (module, exports, __webpack_require__) {
      var coreJsData = __webpack_require__(12)['__core-js_shared__'];
      module.exports = coreJsData;
    },
    function (module, exports) {
      module.exports = function getValue(object, key) {
        return null == object ? void 0 : object[key];
      };
    },
    function (module, exports) {
      module.exports = function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        return (this.size -= result ? 1 : 0), result;
      };
    },
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(26),
        hasOwnProperty = Object.prototype.hasOwnProperty;
      module.exports = function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return '__lodash_hash_undefined__' === result ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      };
    },
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(26),
        hasOwnProperty = Object.prototype.hasOwnProperty;
      module.exports = function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
      };
    },
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(26);
      module.exports = function hashSet(key, value) {
        var data = this.__data__;
        return (
          (this.size += this.has(key) ? 0 : 1),
          (data[key] = nativeCreate && void 0 === value ? '__lodash_hash_undefined__' : value),
          this
        );
      };
    },
    function (module, exports, __webpack_require__) {
      var listCacheClear = __webpack_require__(125),
        listCacheDelete = __webpack_require__(126),
        listCacheGet = __webpack_require__(128),
        listCacheHas = __webpack_require__(129),
        listCacheSet = __webpack_require__(130);
      function ListCache(entries) {
        var index = -1,
          length = null == entries ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      (ListCache.prototype.clear = listCacheClear),
        (ListCache.prototype.delete = listCacheDelete),
        (ListCache.prototype.get = listCacheGet),
        (ListCache.prototype.has = listCacheHas),
        (ListCache.prototype.set = listCacheSet),
        (module.exports = ListCache);
    },
    function (module, exports) {
      module.exports = function listCacheClear() {
        (this.__data__ = []), (this.size = 0);
      };
    },
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(27),
        splice = Array.prototype.splice;
      module.exports = function listCacheDelete(key) {
        var data = this.__data__,
          index = assocIndexOf(data, key);
        return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), --this.size, !0);
      };
    },
    function (module, exports) {
      module.exports = function eq(value, other) {
        return value === other || (value != value && other != other);
      };
    },
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(27);
      module.exports = function listCacheGet(key) {
        var data = this.__data__,
          index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      };
    },
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(27);
      module.exports = function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      };
    },
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(27);
      module.exports = function listCacheSet(key, value) {
        var data = this.__data__,
          index = assocIndexOf(data, key);
        return index < 0 ? (++this.size, data.push([key, value])) : (data[index][1] = value), this;
      };
    },
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(28);
      module.exports = function mapCacheDelete(key) {
        var result = getMapData(this, key).delete(key);
        return (this.size -= result ? 1 : 0), result;
      };
    },
    function (module, exports) {
      module.exports = function isKeyable(value) {
        var type = typeof value;
        return 'string' == type || 'number' == type || 'symbol' == type || 'boolean' == type
          ? '__proto__' !== value
          : null === value;
      };
    },
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(28);
      module.exports = function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      };
    },
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(28);
      module.exports = function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      };
    },
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(28);
      module.exports = function mapCacheSet(key, value) {
        var data = getMapData(this, key),
          size = data.size;
        return data.set(key, value), (this.size += data.size == size ? 0 : 1), this;
      };
    },
    function (module, exports, __webpack_require__) {
      var baseToString = __webpack_require__(137);
      module.exports = function toString(value) {
        return null == value ? '' : baseToString(value);
      };
    },
    function (module, exports, __webpack_require__) {
      var Symbol = __webpack_require__(38),
        arrayMap = __webpack_require__(138),
        isArray = __webpack_require__(24),
        isSymbol = __webpack_require__(37),
        symbolProto = Symbol ? Symbol.prototype : void 0,
        symbolToString = symbolProto ? symbolProto.toString : void 0;
      module.exports = function baseToString(value) {
        if ('string' == typeof value) return value;
        if (isArray(value)) return arrayMap(value, baseToString) + '';
        if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : '';
        var result = value + '';
        return '0' == result && 1 / value == -1 / 0 ? '-0' : result;
      };
    },
    function (module, exports) {
      module.exports = function arrayMap(array, iteratee) {
        for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; )
          result[index] = iteratee(array[index], index, array);
        return result;
      };
    },
    function (module, exports, __webpack_require__) {
      var isSymbol = __webpack_require__(37);
      module.exports = function toKey(value) {
        if ('string' == typeof value || isSymbol(value)) return value;
        var result = value + '';
        return '0' == result && 1 / value == -1 / 0 ? '-0' : result;
      };
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      const createAbortError = () => {
          const error = new Error('Delay aborted');
          return (error.name = 'AbortError'), error;
        },
        createDelay = ({ clearTimeout: defaultClear, setTimeout: set, willResolve }) => (
          ms,
          { value, signal } = {}
        ) => {
          if (signal && signal.aborted) return Promise.reject(createAbortError());
          let timeoutId, settle, rejectFn;
          const clear = defaultClear || clearTimeout,
            signalListener = () => {
              clear(timeoutId), rejectFn(createAbortError());
            },
            delayPromise = new Promise((resolve, reject) => {
              (settle = () => {
                signal && signal.removeEventListener('abort', signalListener),
                  willResolve ? resolve(value) : reject(value);
              }),
                (rejectFn = reject),
                (timeoutId = (set || setTimeout)(settle, ms));
            });
          return (
            signal && signal.addEventListener('abort', signalListener, { once: !0 }),
            (delayPromise.clear = () => {
              clear(timeoutId), (timeoutId = null), settle();
            }),
            delayPromise
          );
        },
        delay = createDelay({ willResolve: !0 });
      (delay.reject = createDelay({ willResolve: !1 })),
        (delay.range = (minimum, maximum, options) =>
          delay(
            ((minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum))(minimum, maximum),
            options
          )),
        (delay.createWithTimers = ({ clearTimeout, setTimeout }) => {
          const delay = createDelay({ clearTimeout, setTimeout, willResolve: !0 });
          return (delay.reject = createDelay({ clearTimeout, setTimeout, willResolve: !1 })), delay;
        }),
        (module.exports = delay),
        (module.exports.default = delay);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        Object.defineProperty(exports, 'Tabs', {
          enumerable: !0,
          get: function get() {
            return _components.Tabs;
          },
        }),
        Object.defineProperty(exports, 'Tab', {
          enumerable: !0,
          get: function get() {
            return _components.Tab;
          },
        });
      var _components = __webpack_require__(58);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }), (exports.default = void 0);
      var _react = _interopRequireDefault(__webpack_require__(0)),
        _propTypes = _interopRequireDefault(__webpack_require__(1)),
        _glamorous = __webpack_require__(59),
        _tabService = _interopRequireDefault(__webpack_require__(188)),
        _localStorageService = _interopRequireDefault(__webpack_require__(191)),
        _common = __webpack_require__(40),
        _common2 = __webpack_require__(63);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof(obj) {
        return (_typeof =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function _typeof(obj) {
                return typeof obj;
              }
            : function _typeof(obj) {
                return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              })(obj);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          (descriptor.enumerable = descriptor.enumerable || !1),
            (descriptor.configurable = !0),
            'value' in descriptor && (descriptor.writable = !0),
            Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _possibleConstructorReturn(self, call) {
        return !call || ('object' !== _typeof(call) && 'function' != typeof call)
          ? (function _assertThisInitialized(self) {
              if (void 0 === self)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return self;
            })(self)
          : call;
      }
      function _getPrototypeOf(o) {
        return (_getPrototypeOf = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            })(o);
      }
      function _setPrototypeOf(o, p) {
        return (_setPrototypeOf =
          Object.setPrototypeOf ||
          function _setPrototypeOf(o, p) {
            return (o.__proto__ = p), o;
          })(o, p);
      }
      var Tabs = (function (_React$Component) {
        function Tabs(props) {
          var _this;
          return (
            (function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function');
            })(this, Tabs),
            (_this = _possibleConstructorReturn(this, _getPrototypeOf(Tabs).call(this, props))),
            _tabService.default.detectDescendantTypeMismatches(props.children),
            _tabService.default.detectControlledUncontrolledPropMismatches(
              props.activeKey,
              props.defaultActiveKey,
              props.onSelect,
              props.sticky
            ),
            (_this.state = { theme: _tabService.default.getDerivedTheme(props.theme) }),
            _this
          );
        }
        return (
          (function _inherits(subClass, superClass) {
            if ('function' != typeof superClass && null !== superClass)
              throw new TypeError('Super expression must either be null or a function');
            (subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: { value: subClass, writable: !0, configurable: !0 },
            })),
              superClass && _setPrototypeOf(subClass, superClass);
          })(Tabs, _React$Component),
          (function _createClass(Constructor, protoProps, staticProps) {
            return (
              protoProps && _defineProperties(Constructor.prototype, protoProps),
              staticProps && _defineProperties(Constructor, staticProps),
              Constructor
            );
          })(Tabs, [
            {
              key: 'componentDidMount',
              value: function componentDidMount() {
                var _this$props = this.props,
                  id = _this$props.id,
                  sticky = _this$props.sticky,
                  activeKey = _this$props.activeKey,
                  defaultActiveKey = _this$props.defaultActiveKey;
                if (!(0, _common2.__hasValue)(activeKey)) {
                  var uncontrolledActiveKey = 0;
                  if (
                    ((0, _common2.__hasValue)(defaultActiveKey) && (uncontrolledActiveKey = defaultActiveKey),
                    sticky && _localStorageService.default.getStickyTab(id))
                  )
                    uncontrolledActiveKey = _localStorageService.default.getStickyTab(id).activeKey;
                  this.setState({ uncontrolledActiveKey });
                }
              },
            },
            {
              key: 'componentDidUpdate',
              value: function componentDidUpdate() {
                this._maybeSaveToLocalStorage();
              },
            },
            {
              key: 'componentWillUnmount',
              value: function componentWillUnmount() {
                this._maybeSaveToLocalStorage();
              },
            },
            {
              key: 'render',
              value: function render() {
                var _this$props2 = this.props,
                  children = _this$props2.children,
                  stacked = _this$props2.stacked,
                  style = _this$props2.style,
                  tabs = _tabService.default.buildTabs(children),
                  MenuWrapper = stacked ? _common.MenuList : _common.TabList;
                return _react.default.createElement(
                  _glamorous.ThemeProvider,
                  { theme: this.state.theme },
                  _react.default.createElement(
                    _common.Flex,
                    { id: this._getId(), column: !stacked, flex: 1, style },
                    _react.default.createElement(MenuWrapper, null, this._renderTabLinks(tabs, stacked)),
                    _react.default.createElement(
                      _common.Flex,
                      { overflow: 'hidden', flex: 1, id: 'tab-content-'.concat(this._getId()) },
                      this._renderTabContent(tabs)
                    )
                  )
                );
              },
            },
            {
              key: '_renderTabLinks',
              value: function _renderTabLinks(tabs, stacked) {
                return stacked ? this._renderVerticalTabLinks(tabs) : this._renderHorizontalTabLinks(tabs);
              },
            },
            {
              key: '_renderHorizontalTabLinks',
              value: function _renderHorizontalTabLinks(tabs) {
                return _react.default.createElement(
                  _common.TabUL,
                  null,
                  tabs.map(this._renderTabLink.bind(this, _common.TabLI, _common.TabLink))
                );
              },
            },
            {
              key: '_renderVerticalTabLinks',
              value: function _renderVerticalTabLinks(tabs) {
                return _react.default.createElement(
                  _common.MenuUL,
                  null,
                  tabs.map(this._renderTabLink.bind(this, _common.MenuLI, _common.MenuLink))
                );
              },
            },
            {
              key: '_renderTabLink',
              value: function _renderTabLink(ListItem, Anchor, child, index) {
                var _child$props = child.props,
                  label = _child$props.label,
                  eventKey = _child$props.eventKey,
                  key = (0, _common2.__hasValue)(eventKey) ? eventKey : index,
                  isActive = key === this._getActiveKey();
                return _react.default.createElement(
                  ListItem,
                  {
                    id: ''.concat(this._getId(), '-tab-item-').concat(key),
                    key: index,
                    isActive,
                    onClick: this._handleTabSelect.bind(this, key),
                  },
                  _react.default.createElement(Anchor, { isActive }, label)
                );
              },
            },
            {
              key: '_renderTabContent',
              value: function _renderTabContent(tabs) {
                var _this2 = this;
                return tabs
                  .map(function (tab, index) {
                    var key = (0, _common2.__hasValue)(tab.props.eventKey) ? tab.props.eventKey : index;
                    return key !== _this2._getActiveKey() ? null : _react.default.cloneElement(tab, { key });
                  })
                  .filter(function (tab) {
                    return tab;
                  });
              },
            },
            {
              key: '_handleTabSelect',
              value: function _handleTabSelect(eventKey) {
                this.props.onSelect
                  ? this.props.onSelect(eventKey)
                  : eventKey !== this.state.uncontrolledActiveKey && this.setState({ uncontrolledActiveKey: eventKey });
              },
            },
            {
              key: '_getActiveKey',
              value: function _getActiveKey() {
                return (0, _common2.__hasValue)(this.props.activeKey)
                  ? this.props.activeKey
                  : this.state.uncontrolledActiveKey;
              },
            },
            {
              key: '_getId',
              value: function _getId() {
                return this.props.id || '__tabify__';
              },
            },
            {
              key: '_maybeSaveToLocalStorage',
              value: function _maybeSaveToLocalStorage() {
                this.props.sticky &&
                  _localStorageService.default.setStickyTab(this.props.id, { activeKey: this._getActiveKey() });
              },
            },
          ]),
          Tabs
        );
      })(_react.default.Component);
      Tabs.propTypes = {
        id: _propTypes.default.string,
        defaultActiveKey: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
        activeKey: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
        stacked: _propTypes.default.bool,
        sticky: _propTypes.default.bool,
        onSelect: _propTypes.default.func,
        style: _propTypes.default.object,
        children: _propTypes.default.node.isRequired,
      };
      var _default = Tabs;
      exports.default = _default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }), (exports.StyleSheet = StyleSheet);
      var _objectAssign2 = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(15));
      function last(arr) {
        return arr[arr.length - 1];
      }
      function sheetForTag(tag) {
        if (tag.sheet) return tag.sheet;
        for (var i = 0; i < document.styleSheets.length; i++)
          if (document.styleSheets[i].ownerNode === tag) return document.styleSheets[i];
      }
      var isBrowser = 'undefined' != typeof window,
        oldIE = (function () {
          if (isBrowser) {
            var div = document.createElement('div');
            return (
              (div.innerHTML = '\x3c!--[if lt IE 10]><i></i><![endif]--\x3e'),
              1 === div.getElementsByTagName('i').length
            );
          }
        })();
      function makeStyleTag() {
        var tag = document.createElement('style');
        return (
          (tag.type = 'text/css'),
          tag.setAttribute('data-glamor', ''),
          tag.appendChild(document.createTextNode('')),
          (document.head || document.getElementsByTagName('head')[0]).appendChild(tag),
          tag
        );
      }
      function StyleSheet() {
        var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          _ref$speedy = _ref.speedy,
          speedy = void 0 === _ref$speedy || _ref$speedy,
          _ref$maxLength = _ref.maxLength,
          maxLength = void 0 === _ref$maxLength ? (isBrowser && oldIE ? 4e3 : 65e3) : _ref$maxLength;
        (this.isSpeedy = speedy), (this.sheet = void 0), (this.tags = []), (this.maxLength = maxLength), (this.ctr = 0);
      }
      (0, _objectAssign2.default)(StyleSheet.prototype, {
        getSheet: function getSheet() {
          return sheetForTag(last(this.tags));
        },
        inject: function inject() {
          var _this = this;
          if (this.injected) throw new Error('already injected stylesheet!');
          isBrowser
            ? (this.tags[0] = makeStyleTag())
            : (this.sheet = {
                cssRules: [],
                insertRule: function insertRule(rule) {
                  _this.sheet.cssRules.push({ cssText: rule });
                },
              }),
            (this.injected = !0);
        },
        speedy: function speedy(bool) {
          if (0 !== this.ctr)
            throw new Error(
              'cannot change speedy mode after inserting any rule to sheet. Either call speedy(' +
                bool +
                ') earlier in your app, or call flush() before speedy(' +
                bool +
                ')'
            );
          this.isSpeedy = !!bool;
        },
        _insert: function _insert(rule) {
          try {
            var sheet = this.getSheet();
            sheet.insertRule(rule, -1 !== rule.indexOf('@import') ? 0 : sheet.cssRules.length);
          } catch (e) {
            0;
          }
        },
        insert: function insert(rule) {
          if (isBrowser)
            if (this.isSpeedy && this.getSheet().insertRule) this._insert(rule);
            else if (-1 !== rule.indexOf('@import')) {
              var tag = last(this.tags);
              tag.insertBefore(document.createTextNode(rule), tag.firstChild);
            } else last(this.tags).appendChild(document.createTextNode(rule));
          else this.sheet.insertRule(rule, -1 !== rule.indexOf('@import') ? 0 : this.sheet.cssRules.length);
          return (
            this.ctr++, isBrowser && this.ctr % this.maxLength == 0 && this.tags.push(makeStyleTag()), this.ctr - 1
          );
        },
        delete: function _delete(index) {
          return this.replace(index, '');
        },
        flush: function flush() {
          isBrowser
            ? (this.tags.forEach(function (tag) {
                return tag.parentNode.removeChild(tag);
              }),
              (this.tags = []),
              (this.sheet = null),
              (this.ctr = 0))
            : (this.sheet.cssRules = []),
            (this.injected = !1);
        },
        rules: function rules() {
          if (!isBrowser) return this.sheet.cssRules;
          var arr = [];
          return (
            this.tags.forEach(function (tag) {
              return arr.splice.apply(
                arr,
                [arr.length, 0].concat(
                  (function _toConsumableArray(arr) {
                    if (Array.isArray(arr)) {
                      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                      return arr2;
                    }
                    return Array.from(arr);
                  })(Array.from(sheetForTag(tag).cssRules))
                )
              );
            }),
            arr
          );
        },
      });
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var camelize = __webpack_require__(162),
        msPattern = /^-ms-/;
      module.exports = function camelizeStyleName(string) {
        return camelize(string.replace(msPattern, 'ms-'));
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var _hyphenPattern = /-(.)/g;
      module.exports = function camelize(string) {
        return string.replace(_hyphenPattern, function (_, character) {
          return character.toUpperCase();
        });
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var _CSSProperty2 = _interopRequireDefault(__webpack_require__(164)),
        _warning2 = _interopRequireDefault(__webpack_require__(61));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isUnitlessNumber = _CSSProperty2.default.isUnitlessNumber,
        styleWarnings = {};
      exports.default = function dangerousStyleValue(name, value, component) {
        if (null == value || 'boolean' == typeof value || '' === value) return '';
        if (isNaN(value) || 0 === value || (isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
          return '' + value;
        if ('string' == typeof value) {
          if (component && '0' !== value) {
            var owner = component._currentElement._owner,
              ownerName = owner ? owner.getName() : null;
            ownerName && !styleWarnings[ownerName] && (styleWarnings[ownerName] = {});
            var warned = !1;
            if (ownerName) {
              var warnings = styleWarnings[ownerName];
              (warned = warnings[name]) || (warnings[name] = !0);
            }
            warned ||
              (0, _warning2.default)(
                !1,
                'a `%s` tag (owner: `%s`) was passed a numeric string value for CSS property `%s` (value: `%s`) which will be treated as a unitless number in a future version of React.',
                component._currentElement.type,
                ownerName || 'unknown',
                name,
                value
              );
          }
          value = value.trim();
        }
        return value + 'px';
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var isUnitlessNumber = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridRow: !0,
        gridRowStart: !0,
        gridRowEnd: !0,
        gridColumn: !0,
        gridColumnStart: !0,
        gridColumnEnd: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0,
      };
      var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
      Object.keys(isUnitlessNumber).forEach(function (prop) {
        prefixes.forEach(function (prefix) {
          isUnitlessNumber[
            (function prefixKey(prefix, key) {
              return prefix + key.charAt(0).toUpperCase() + key.substring(1);
            })(prefix, prop)
          ] = isUnitlessNumber[prop];
        });
      });
      var CSSProperty = {
        isUnitlessNumber,
        shorthandPropertyExpansions: {
          background: {
            backgroundAttachment: !0,
            backgroundColor: !0,
            backgroundImage: !0,
            backgroundPositionX: !0,
            backgroundPositionY: !0,
            backgroundRepeat: !0,
          },
          backgroundPosition: { backgroundPositionX: !0, backgroundPositionY: !0 },
          border: { borderWidth: !0, borderStyle: !0, borderColor: !0 },
          borderBottom: { borderBottomWidth: !0, borderBottomStyle: !0, borderBottomColor: !0 },
          borderLeft: { borderLeftWidth: !0, borderLeftStyle: !0, borderLeftColor: !0 },
          borderRight: { borderRightWidth: !0, borderRightStyle: !0, borderRightColor: !0 },
          borderTop: { borderTopWidth: !0, borderTopStyle: !0, borderTopColor: !0 },
          font: { fontStyle: !0, fontVariant: !0, fontWeight: !0, fontSize: !0, lineHeight: !0, fontFamily: !0 },
          outline: { outlineWidth: !0, outlineStyle: !0, outlineColor: !0 },
        },
      };
      exports.default = CSSProperty;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      function makeEmptyFunction(arg) {
        return function () {
          return arg;
        };
      }
      var emptyFunction = function emptyFunction() {};
      (emptyFunction.thatReturns = makeEmptyFunction),
        (emptyFunction.thatReturnsFalse = makeEmptyFunction(!1)),
        (emptyFunction.thatReturnsTrue = makeEmptyFunction(!0)),
        (emptyFunction.thatReturnsNull = makeEmptyFunction(null)),
        (emptyFunction.thatReturnsThis = function () {
          return this;
        }),
        (emptyFunction.thatReturnsArgument = function (arg) {
          return arg;
        }),
        (module.exports = emptyFunction);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var hyphenate = __webpack_require__(167),
        msPattern = /^ms-/;
      module.exports = function hyphenateStyleName(string) {
        return hyphenate(string).replace(msPattern, '-ms-');
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var _uppercasePattern = /([A-Z])/g;
      module.exports = function hyphenate(string) {
        return string.replace(_uppercasePattern, '-$1').toLowerCase();
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = function memoizeStringOnly(callback) {
        var cache = {};
        return function (string) {
          return cache.hasOwnProperty(string) || (cache[string] = callback.call(this, string)), cache[string];
        };
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var _typeof =
        'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
      function cleanObject(object) {
        if (
          (function isFalsy(value) {
            return (
              null == value ||
              !1 === value ||
              ('object' === (void 0 === value ? 'undefined' : _typeof(value)) && 0 === Object.keys(value).length)
            );
          })(object)
        )
          return null;
        if ('object' !== (void 0 === object ? 'undefined' : _typeof(object))) return object;
        for (var acc = {}, keys = Object.keys(object), hasFalsy = !1, i = 0; i < keys.length; i++) {
          var value = object[keys[i]],
            filteredValue = clean(value);
          (null !== filteredValue && filteredValue === value) || (hasFalsy = !0),
            null !== filteredValue && (acc[keys[i]] = filteredValue);
        }
        return 0 === Object.keys(acc).length ? null : hasFalsy ? acc : object;
      }
      function clean(input) {
        return Array.isArray(input)
          ? (function cleanArray(rules) {
              var hasFalsy = !1,
                filtered = [];
              return (
                rules.forEach(function (rule) {
                  var filteredRule = clean(rule);
                  (null !== filteredRule && filteredRule === rule) || (hasFalsy = !0),
                    null !== filteredRule && filtered.push(filteredRule);
                }),
                0 == filtered.length ? null : hasFalsy ? filtered : rules
              );
            })(input)
          : cleanObject(input);
      }
      exports.default = clean;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var _extends =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
          return target;
        };
      (exports.PluginSet = PluginSet),
        (exports.fallbacks = function fallbacks(node) {
          if (
            Object.keys(node.style)
              .map(function (x) {
                return Array.isArray(node.style[x]);
              })
              .indexOf(!0) >= 0
          ) {
            var style = node.style,
              flattened = Object.keys(style).reduce(function (o, key) {
                return (
                  (o[key] = Array.isArray(style[key])
                    ? style[key].join('; ' + (0, _CSSPropertyOperations.processStyleName)(key) + ': ')
                    : style[key]),
                  o
                );
              }, {});
            return (0, _objectAssign2.default)({}, node, { style: flattened });
          }
          return node;
        }),
        (exports.contentWrap = function contentWrap(node) {
          if (node.style.content) {
            var cont = node.style.content;
            return contentValues.indexOf(cont) >= 0 || /^(attr|calc|counters?|url)\(/.test(cont)
              ? node
              : cont.charAt(0) !== cont.charAt(cont.length - 1) || ('"' !== cont.charAt(0) && "'" !== cont.charAt(0))
              ? _extends({}, node, { style: _extends({}, node.style, { content: '"' + cont + '"' }) })
              : node;
          }
          return node;
        }),
        (exports.prefixes = function prefixes(node) {
          return (0, _objectAssign2.default)({}, node, { style: (0, _prefixer2.default)(_extends({}, node.style)) });
        });
      var _objectAssign2 = _interopRequireDefault(__webpack_require__(15)),
        _CSSPropertyOperations = __webpack_require__(60),
        _prefixer2 = _interopRequireDefault(__webpack_require__(171));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function PluginSet(initial) {
        this.fns = initial || [];
      }
      (0, _objectAssign2.default)(PluginSet.prototype, {
        add: function add() {
          for (var _this = this, _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++)
            fns[_key] = arguments[_key];
          fns.forEach(function (fn) {
            _this.fns.indexOf(fn) >= 0 || (_this.fns = [fn].concat(_this.fns));
          });
        },
        remove: function remove(fn) {
          this.fns = this.fns.filter(function (x) {
            return x !== fn;
          });
        },
        clear: function clear() {
          this.fns = [];
        },
        transform: function transform(o) {
          return this.fns.reduce(function (o, fn) {
            return fn(o);
          }, o);
        },
      });
      var contentValues = [
        'normal',
        'none',
        'counter',
        'open-quote',
        'close-quote',
        'no-open-quote',
        'no-close-quote',
        'initial',
        'inherit',
      ];
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function prefixer(style) {
          for (var property in style) {
            var value = style[property],
              processedValue = (0, _prefixValue2.default)(plugins, property, value, style, prefixMap);
            processedValue && (style[property] = processedValue),
              (0, _prefixProperty2.default)(prefixMap, property, style);
          }
          return style;
        });
      var _staticData2 = _interopRequireDefault(__webpack_require__(172)),
        _prefixProperty2 = _interopRequireDefault(__webpack_require__(173)),
        _prefixValue2 = _interopRequireDefault(__webpack_require__(174)),
        _cursor2 = _interopRequireDefault(__webpack_require__(175)),
        _crossFade2 = _interopRequireDefault(__webpack_require__(176)),
        _filter2 = _interopRequireDefault(__webpack_require__(177)),
        _flex2 = _interopRequireDefault(__webpack_require__(178)),
        _flexboxOld2 = _interopRequireDefault(__webpack_require__(179)),
        _gradient2 = _interopRequireDefault(__webpack_require__(180)),
        _imageSet2 = _interopRequireDefault(__webpack_require__(181)),
        _position2 = _interopRequireDefault(__webpack_require__(182)),
        _sizing2 = _interopRequireDefault(__webpack_require__(183)),
        _transition2 = _interopRequireDefault(__webpack_require__(184));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var plugins = [
          _crossFade2.default,
          _cursor2.default,
          _filter2.default,
          _flexboxOld2.default,
          _gradient2.default,
          _imageSet2.default,
          _position2.default,
          _sizing2.default,
          _transition2.default,
          _flex2.default,
        ],
        prefixMap = _staticData2.default.prefixMap;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 });
      var w = ['Webkit'],
        m = ['Moz'],
        ms = ['ms'],
        wm = ['Webkit', 'Moz'],
        wms = ['Webkit', 'ms'],
        wmms = ['Webkit', 'Moz', 'ms'];
      (exports.default = {
        plugins: [],
        prefixMap: {
          appearance: wm,
          userSelect: wmms,
          textEmphasisPosition: w,
          textEmphasis: w,
          textEmphasisStyle: w,
          textEmphasisColor: w,
          boxDecorationBreak: w,
          clipPath: w,
          maskImage: w,
          maskMode: w,
          maskRepeat: w,
          maskPosition: w,
          maskClip: w,
          maskOrigin: w,
          maskSize: w,
          maskComposite: w,
          mask: w,
          maskBorderSource: w,
          maskBorderMode: w,
          maskBorderSlice: w,
          maskBorderWidth: w,
          maskBorderOutset: w,
          maskBorderRepeat: w,
          maskBorder: w,
          maskType: w,
          textDecorationStyle: w,
          textDecorationSkip: w,
          textDecorationLine: w,
          textDecorationColor: w,
          filter: w,
          fontFeatureSettings: w,
          breakAfter: wmms,
          breakBefore: wmms,
          breakInside: wmms,
          columnCount: wm,
          columnFill: wm,
          columnGap: wm,
          columnRule: wm,
          columnRuleColor: wm,
          columnRuleStyle: wm,
          columnRuleWidth: wm,
          columns: wm,
          columnSpan: wm,
          columnWidth: wm,
          writingMode: wms,
          flex: w,
          flexBasis: w,
          flexDirection: w,
          flexGrow: w,
          flexFlow: w,
          flexShrink: w,
          flexWrap: w,
          alignContent: w,
          alignItems: w,
          alignSelf: w,
          justifyContent: w,
          order: w,
          transform: w,
          transformOrigin: w,
          transformOriginX: w,
          transformOriginY: w,
          backfaceVisibility: w,
          perspective: w,
          perspectiveOrigin: w,
          transformStyle: w,
          transformOriginZ: w,
          animation: w,
          animationDelay: w,
          animationDirection: w,
          animationFillMode: w,
          animationDuration: w,
          animationIterationCount: w,
          animationName: w,
          animationPlayState: w,
          animationTimingFunction: w,
          backdropFilter: w,
          fontKerning: w,
          scrollSnapType: wms,
          scrollSnapPointsX: wms,
          scrollSnapPointsY: wms,
          scrollSnapDestination: wms,
          scrollSnapCoordinate: wms,
          shapeImageThreshold: w,
          shapeImageMargin: w,
          shapeImageOutside: w,
          hyphens: wmms,
          flowInto: wms,
          flowFrom: wms,
          regionFragment: wms,
          textAlignLast: m,
          tabSize: m,
          wrapFlow: ms,
          wrapThrough: ms,
          wrapMargin: ms,
          gridTemplateColumns: ms,
          gridTemplateRows: ms,
          gridTemplateAreas: ms,
          gridTemplate: ms,
          gridAutoColumns: ms,
          gridAutoRows: ms,
          gridAutoFlow: ms,
          grid: ms,
          gridRowStart: ms,
          gridColumnStart: ms,
          gridRowEnd: ms,
          gridRow: ms,
          gridColumn: ms,
          gridColumnEnd: ms,
          gridColumnGap: ms,
          gridRowGap: ms,
          gridArea: ms,
          gridGap: ms,
          textSizeAdjust: wms,
          borderImage: w,
          borderImageOutset: w,
          borderImageRepeat: w,
          borderImageSlice: w,
          borderImageSource: w,
          borderImageWidth: w,
          transitionDelay: w,
          transitionDuration: w,
          transitionProperty: w,
          transitionTimingFunction: w,
        },
      }),
        (module.exports = exports.default);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function prefixProperty(prefixProperties, property, style) {
          if (prefixProperties.hasOwnProperty(property))
            for (var requiredPrefixes = prefixProperties[property], i = 0, len = requiredPrefixes.length; i < len; ++i)
              style[requiredPrefixes[i] + (0, _capitalizeString2.default)(property)] = style[property];
        });
      var _capitalizeString2 = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(62));
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function prefixValue(plugins, property, value, style, metaData) {
          for (var i = 0, len = plugins.length; i < len; ++i) {
            var processedValue = plugins[i](property, value, style, metaData);
            if (processedValue) return processedValue;
          }
        }),
        (module.exports = exports.default);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function cursor(property, value) {
          if ('cursor' === property && values.hasOwnProperty(value))
            return prefixes.map(function (prefix) {
              return prefix + value;
            });
        });
      var prefixes = ['-webkit-', '-moz-', ''],
        values = { 'zoom-in': !0, 'zoom-out': !0, grab: !0, grabbing: !0 };
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function crossFade(property, value) {
          if ('string' == typeof value && !(0, _isPrefixedValue2.default)(value) && value.indexOf('cross-fade(') > -1)
            return prefixes.map(function (prefix) {
              return value.replace(/cross-fade\(/g, prefix + 'cross-fade(');
            });
        });
      var _isPrefixedValue2 = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(18));
      var prefixes = ['-webkit-', ''];
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function filter(property, value) {
          if ('string' == typeof value && !(0, _isPrefixedValue2.default)(value) && value.indexOf('filter(') > -1)
            return prefixes.map(function (prefix) {
              return value.replace(/filter\(/g, prefix + 'filter(');
            });
        });
      var _isPrefixedValue2 = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(18));
      var prefixes = ['-webkit-', ''];
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function flex(property, value) {
          if ('display' === property && values.hasOwnProperty(value)) return values[value];
        });
      var values = {
        flex: ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex'],
        'inline-flex': [
          '-webkit-inline-box',
          '-moz-inline-box',
          '-ms-inline-flexbox',
          '-webkit-inline-flex',
          'inline-flex',
        ],
      };
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function flexboxOld(property, value, style) {
          'flexDirection' === property &&
            'string' == typeof value &&
            (value.indexOf('column') > -1
              ? (style.WebkitBoxOrient = 'vertical')
              : (style.WebkitBoxOrient = 'horizontal'),
            value.indexOf('reverse') > -1
              ? (style.WebkitBoxDirection = 'reverse')
              : (style.WebkitBoxDirection = 'normal'));
          alternativeProps.hasOwnProperty(property) &&
            (style[alternativeProps[property]] = alternativeValues[value] || value);
        });
      var alternativeValues = {
          'space-around': 'justify',
          'space-between': 'justify',
          'flex-start': 'start',
          'flex-end': 'end',
          'wrap-reverse': 'multiple',
          wrap: 'multiple',
        },
        alternativeProps = {
          alignItems: 'WebkitBoxAlign',
          justifyContent: 'WebkitBoxPack',
          flexWrap: 'WebkitBoxLines',
        };
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function gradient(property, value) {
          if ('string' == typeof value && !(0, _isPrefixedValue2.default)(value) && values.test(value))
            return prefixes.map(function (prefix) {
              return prefix + value;
            });
        });
      var _isPrefixedValue2 = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(18));
      var prefixes = ['-webkit-', '-moz-', ''],
        values = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/;
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function imageSet(property, value) {
          if ('string' == typeof value && !(0, _isPrefixedValue2.default)(value) && value.indexOf('image-set(') > -1)
            return prefixes.map(function (prefix) {
              return value.replace(/image-set\(/g, prefix + 'image-set(');
            });
        });
      var _isPrefixedValue2 = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(18));
      var prefixes = ['-webkit-', ''];
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function position(property, value) {
          if ('position' === property && 'sticky' === value) return ['-webkit-sticky', 'sticky'];
        }),
        (module.exports = exports.default);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function sizing(property, value) {
          if (properties.hasOwnProperty(property) && values.hasOwnProperty(value))
            return prefixes.map(function (prefix) {
              return prefix + value;
            });
        });
      var prefixes = ['-webkit-', '-moz-', ''],
        properties = {
          maxHeight: !0,
          maxWidth: !0,
          width: !0,
          height: !0,
          columnWidth: !0,
          minWidth: !0,
          minHeight: !0,
        },
        values = {
          'min-content': !0,
          'max-content': !0,
          'fill-available': !0,
          'fit-content': !0,
          'contain-floats': !0,
        };
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function transition(property, value, style, propertyPrefixMap) {
          if ('string' == typeof value && properties.hasOwnProperty(property)) {
            var outputValue = (function prefixValue(value, propertyPrefixMap) {
                if ((0, _isPrefixedValue2.default)(value)) return value;
                for (
                  var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g), i = 0, len = multipleValues.length;
                  i < len;
                  ++i
                ) {
                  var singleValue = multipleValues[i],
                    values = [singleValue];
                  for (var property in propertyPrefixMap) {
                    var dashCaseProperty = (0, _hyphenateProperty2.default)(property);
                    if (singleValue.indexOf(dashCaseProperty) > -1 && 'order' !== dashCaseProperty)
                      for (var prefixes = propertyPrefixMap[property], j = 0, pLen = prefixes.length; j < pLen; ++j)
                        values.unshift(
                          singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty)
                        );
                  }
                  multipleValues[i] = values.join(',');
                }
                return multipleValues.join(',');
              })(value, propertyPrefixMap),
              webkitOutput = outputValue
                .split(/,(?![^()]*(?:\([^()]*\))?\))/g)
                .filter(function (val) {
                  return !/-moz-|-ms-/.test(val);
                })
                .join(',');
            if (property.indexOf('Webkit') > -1) return webkitOutput;
            var mozOutput = outputValue
              .split(/,(?![^()]*(?:\([^()]*\))?\))/g)
              .filter(function (val) {
                return !/-webkit-|-ms-/.test(val);
              })
              .join(',');
            return property.indexOf('Moz') > -1
              ? mozOutput
              : ((style['Webkit' + (0, _capitalizeString2.default)(property)] = webkitOutput),
                (style['Moz' + (0, _capitalizeString2.default)(property)] = mozOutput),
                outputValue);
          }
        });
      var _hyphenateProperty2 = _interopRequireDefault(__webpack_require__(185)),
        _isPrefixedValue2 = _interopRequireDefault(__webpack_require__(18)),
        _capitalizeString2 = _interopRequireDefault(__webpack_require__(62));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var properties = {
          transition: !0,
          transitionProperty: !0,
          WebkitTransition: !0,
          WebkitTransitionProperty: !0,
          MozTransition: !0,
          MozTransitionProperty: !0,
        },
        prefixMapping = { Webkit: '-webkit-', Moz: '-moz-', ms: '-ms-' };
      module.exports = exports.default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function hyphenateProperty(property) {
          return (0, _hyphenateStyleName2.default)(property);
        });
      var _hyphenateStyleName2 = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(186));
      module.exports = exports.default;
    },
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.r(__webpack_exports__);
      var uppercasePattern = /[A-Z]/g,
        msPattern = /^ms-/,
        cache = {};
      function toHyphenLower(match) {
        return '-' + match.toLowerCase();
      }
      __webpack_exports__.default = function hyphenateStyleName(name) {
        if (cache.hasOwnProperty(name)) return cache[name];
        var hName = name.replace(uppercasePattern, toHyphenLower);
        return (cache[name] = msPattern.test(hName) ? '-' + hName : hName);
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      function UInt32(str, pos) {
        return (
          str.charCodeAt(pos++) +
          (str.charCodeAt(pos++) << 8) +
          (str.charCodeAt(pos++) << 16) +
          (str.charCodeAt(pos) << 24)
        );
      }
      function UInt16(str, pos) {
        return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8);
      }
      function Umul32(n, m) {
        return ((65535 & (n |= 0)) * (m |= 0) + ((((n >>> 16) * m) & 65535) << 16)) | 0;
      }
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.default = function doHash(str, seed) {
          var m = 1540483477,
            h = seed ^ str.length,
            length = str.length,
            currentIndex = 0;
          for (; length >= 4; ) {
            var k = UInt32(str, currentIndex);
            (k = Umul32(k, m)),
              (k = Umul32((k ^= k >>> 24), m)),
              (h = Umul32(h, m)),
              (h ^= k),
              (currentIndex += 4),
              (length -= 4);
          }
          switch (length) {
            case 3:
              (h ^= UInt16(str, currentIndex)), (h = Umul32((h ^= str.charCodeAt(currentIndex + 2) << 16), m));
              break;
            case 2:
              h = Umul32((h ^= UInt16(str, currentIndex)), m);
              break;
            case 1:
              h = Umul32((h ^= str.charCodeAt(currentIndex)), m);
          }
          return (h = Umul32((h ^= h >>> 13), m)), (h ^= h >>> 15) >>> 0;
        });
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }), (exports.default = void 0);
      var _common = __webpack_require__(40),
        _common2 = __webpack_require__(63),
        svc = {},
        _default = (svc = {
          buildTabs: function buildTabs(children) {
            return (Array.isArray(children) ? children : [children]).filter(function (tab) {
              if (!tab) return !1;
              var hide = tab.props.hide;
              return 'function' == typeof hide ? !hide() : !0 !== hide;
            });
          },
          getDerivedTheme: function getDerivedTheme(theme) {
            if (!theme || (0, _common2.__isEmpty)(theme)) return _common.DEFAULT_THEME;
            var derivedTheme = {};
            return (
              !theme.tabs || (0, _common2.__isEmpty)(theme.tabs)
                ? (derivedTheme.tabs = _common.DEFAULT_THEME.tabs)
                : (derivedTheme.tabs = svc._getDerivedTabsTheme(theme.tabs, _common.DEFAULT_THEME.tabs)),
              !theme.menu || (0, _common2.__isEmpty)(theme.menu)
                ? (derivedTheme.menu = _common.DEFAULT_THEME.menu)
                : (derivedTheme.menu = svc._getDerivedMenuTheme(theme.menu, _common.DEFAULT_THEME.menu)),
              derivedTheme
            );
          },
          _getDerivedTabsTheme: function _getDerivedTabsTheme(tabs, theme) {
            var active = tabs.active,
              hover = tabs.hover;
            return {
              color: (0, _common2.__valOrDefault)(function () {
                return tabs.color;
              }, theme.color),
              borderBottomColor: (0, _common2.__valOrDefault)(function () {
                return tabs.borderBottomColor;
              }, theme.borderBottomColor),
              active: {
                borderBottomColor: (0, _common2.__valOrDefault)(function () {
                  return active.borderBottomColor;
                }, theme.active.borderBottomColor),
                color: (0, _common2.__valOrDefault)(function () {
                  return active.color;
                }, theme.active.color),
              },
              hover: {
                borderBottomColor: (0, _common2.__valOrDefault)(function () {
                  return hover.borderBottomColor;
                }, theme.hover.borderBottomColor),
                color: (0, _common2.__valOrDefault)(function () {
                  return hover.color;
                }, theme.hover.color),
              },
            };
          },
          _getDerivedMenuTheme: function _getDerivedMenuTheme(menu, theme) {
            var active = menu.active,
              hover = menu.hover;
            return {
              color: (0, _common2.__valOrDefault)(function () {
                return menu.color;
              }, theme.color),
              borderRight: (0, _common2.__valOrDefault)(function () {
                return menu.borderRight;
              }, theme.borderRight),
              active: {
                backgroundColor: (0, _common2.__valOrDefault)(function () {
                  return active.backgroundColor;
                }, theme.active.backgroundColor),
                color: (0, _common2.__valOrDefault)(function () {
                  return active.color;
                }, theme.active.color),
              },
              hover: {
                backgroundColor: (0, _common2.__valOrDefault)(function () {
                  return hover.backgroundColor;
                }, theme.hover.backgroundColor),
                color: (0, _common2.__valOrDefault)(function () {
                  return hover.color;
                }, theme.hover.color),
              },
            };
          },
          detectDescendantTypeMismatches: function detectDescendantTypeMismatches(children) {
            var tabs = svc.buildTabs(children),
              typeMismatches = (0, _common2.__getTypeMismatches)(tabs);
            if (typeMismatches.length > 0)
              throw (
                ((0, _common2.__logTypeMismatches)(typeMismatches), new Error('Descendant type mismatches detected'))
              );
          },
          detectControlledUncontrolledPropMismatches: function detectControlledUncontrolledPropMismatches(
            activeKey,
            defaultActiveKey,
            onSelect,
            sticky
          ) {
            if ((0, _common2.__hasValues)(activeKey, defaultActiveKey))
              throw new Error(
                'Mixing controlled and uncontrolled props. Specify an "activeKey" or a "defaultActiveKey", but not both'
              );
            if ((0, _common2.__hasValues)(onSelect, defaultActiveKey))
              throw new Error(
                'Mixing controlled and uncontrolled props. If specifying an "onSelect" function, use "activeKey" instead of "defaultActiveKey'
              );
            if ((0, _common2.__hasValue)(onSelect) && !(0, _common2.__hasValue)(activeKey))
              throw new Error(
                'Mixing controlled and uncontrolled props. If specifying an "onSelect" function, you must pass an "activeKey'
              );
            if ((0, _common2.__hasValues)(sticky, activeKey))
              throw new Error(
                'Mixing controlled and uncontrolled props. Cannot specify "sticky" and "activeKey". Only uncontrolled components can maintain internal stickiness.'
              );
          },
        });
      exports.default = _default;
    },
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(190);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      function _toConsumableArray(arr) {
        return (
          (function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
              for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
              return arr2;
            }
          })(arr) ||
          (function _iterableToArray(iter) {
            if (Symbol.iterator in Object(iter) || '[object Arguments]' === Object.prototype.toString.call(iter))
              return Array.from(iter);
          })(arr) ||
          (function _nonIterableSpread() {
            throw new TypeError('Invalid attempt to spread non-iterable instance');
          })()
        );
      }
      var Maybe = function Maybe(val) {
        this.__value = val;
      };
      (Maybe.of = function (val) {
        try {
          return new Maybe('function' == typeof val ? val() : val);
        } catch (error) {
          return new Maybe(void 0);
        }
      }),
        (Maybe.prototype.join = function () {
          return this.__value;
        }),
        (Maybe.prototype.isJust = function () {
          return !this.isNothing();
        }),
        (Maybe.prototype.isNothing = function () {
          return null === this.__value || void 0 === this.__value;
        }),
        (Maybe.prototype.orElse = function (defaultValue) {
          return this.isNothing() ? Maybe.of(defaultValue) : this;
        }),
        (Maybe.prototype.prop = function (property) {
          return this.map(function (value) {
            return value[property];
          });
        }),
        (Maybe.prototype.props = function () {
          for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++)
            properties[_key] = arguments[_key];
          if (0 === properties.length) return Maybe.of(void 0);
          var maybeValue = this.prop(properties.shift());
          return properties.length > 0 ? maybeValue.props.apply(maybeValue, properties) : maybeValue;
        }),
        (Maybe.prototype.path = function (path) {
          return (function isValidPath(path) {
            return null != path && 'string' == typeof path && path.length > 0;
          })(path)
            ? this.props.apply(this, _toConsumableArray(path.split('.')))
            : Maybe.of(void 0);
        }),
        (Maybe.prototype.map = function (transform) {
          if ('function' != typeof transform) throw new Error('transform must be a function');
          return this.isNothing() ? Maybe.of(void 0) : Maybe.of(transform(this.join()));
        }),
        (Maybe.prototype.chain = function (fn) {
          return this.map(fn).join();
        }),
        (module.exports = Maybe);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }), (exports.default = void 0);
      var _isStorageAvailable = (function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      })(__webpack_require__(192));
      var storage,
        _noop = function _noop() {},
        STICKY_PREFIX_TAB = 'TAB__';
      (0, _isStorageAvailable.default)()
        ? (storage = window.localStorage)
        : ((storage = { clear: _noop, getItem: _noop, key: _noop, removeItem: _noop, setItem: _noop }),
          console.warn('LocalStorage not supported. Sticky settings will not work.'));
      var _default = {
        setStickyTab: function setStickyTab(key, value) {
          this.set(STICKY_PREFIX_TAB + key, value);
        },
        getStickyTab: function getStickyTab(key) {
          return this.get(STICKY_PREFIX_TAB + key);
        },
        set: function set(key, value) {
          try {
            storage.setItem('__react-tabify__' + key, JSON.stringify(value));
          } catch (error) {
            console.warn(error);
          }
        },
        get: function get(key) {
          var value = storage.getItem('__react-tabify__' + key);
          if (value) return JSON.parse(value);
        },
      };
      exports.default = _default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }), (exports.default = void 0);
      var ERROR_TYPE_QUOTA_EXCEEDED_ERROR = 'QuotaExceededError',
        ERROR_TYPE_NS_ERROR_DOM_QUOTA_REACHED = 'NS_ERROR_DOM_QUOTA_REACHED',
        ERROR_CODE_NOT_FIREFOX = 22,
        ERROR_CODE_FIREFOX = 1014;
      var _default = function isStorageAvailable() {
        var storage,
          type = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'localStorage';
        try {
          storage = window[type];
          var x = '__storage_test__';
          return storage.setItem(x, x), storage.removeItem(x), !0;
        } catch (e) {
          return (
            e instanceof DOMException &&
            (e.code === ERROR_CODE_NOT_FIREFOX ||
              e.code === ERROR_CODE_FIREFOX ||
              e.name === ERROR_TYPE_QUOTA_EXCEEDED_ERROR ||
              e.name === ERROR_TYPE_NS_ERROR_DOM_QUOTA_REACHED) &&
            0 !== storage.length
          );
        }
      };
      exports.default = _default;
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }), (exports.default = void 0);
      var _react = _interopRequireDefault(__webpack_require__(0)),
        _propTypes = _interopRequireDefault(__webpack_require__(1)),
        _common = __webpack_require__(40);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function Tab(_ref) {
        var id = _ref.id,
          style = _ref.style,
          children = _ref.children;
        return _react.default.createElement(_common.TabDiv, { id, style }, children);
      }
      Tab.propTypes = {
        id: _propTypes.default.string,
        label: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.node]),
        children: _propTypes.default.node,
        style: _propTypes.default.object,
        hide: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.func]),
        eventKey: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      };
      var _default = Tab;
      exports.default = _default;
    },
    ,
    ,
    ,
    ,
    ,
    function (module, exports, __webpack_require__) {
      var baseKeys = __webpack_require__(200),
        getTag = __webpack_require__(203),
        isArguments = __webpack_require__(208),
        isArray = __webpack_require__(24),
        isArrayLike = __webpack_require__(210),
        isBuffer = __webpack_require__(211),
        isPrototype = __webpack_require__(64),
        isTypedArray = __webpack_require__(213),
        hasOwnProperty = Object.prototype.hasOwnProperty;
      module.exports = function isEmpty(value) {
        if (null == value) return !0;
        if (
          isArrayLike(value) &&
          (isArray(value) ||
            'string' == typeof value ||
            'function' == typeof value.splice ||
            isBuffer(value) ||
            isTypedArray(value) ||
            isArguments(value))
        )
          return !value.length;
        var tag = getTag(value);
        if ('[object Map]' == tag || '[object Set]' == tag) return !value.size;
        if (isPrototype(value)) return !baseKeys(value).length;
        for (var key in value) if (hasOwnProperty.call(value, key)) return !1;
        return !0;
      };
    },
    function (module, exports, __webpack_require__) {
      var isPrototype = __webpack_require__(64),
        nativeKeys = __webpack_require__(201),
        hasOwnProperty = Object.prototype.hasOwnProperty;
      module.exports = function baseKeys(object) {
        if (!isPrototype(object)) return nativeKeys(object);
        var result = [];
        for (var key in Object(object)) hasOwnProperty.call(object, key) && 'constructor' != key && result.push(key);
        return result;
      };
    },
    function (module, exports, __webpack_require__) {
      var nativeKeys = __webpack_require__(202)(Object.keys, Object);
      module.exports = nativeKeys;
    },
    function (module, exports) {
      module.exports = function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg));
        };
      };
    },
    function (module, exports, __webpack_require__) {
      var DataView = __webpack_require__(204),
        Map = __webpack_require__(57),
        Promise = __webpack_require__(205),
        Set = __webpack_require__(206),
        WeakMap = __webpack_require__(207),
        baseGetTag = __webpack_require__(17),
        toSource = __webpack_require__(56),
        dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap),
        getTag = baseGetTag;
      ((DataView && '[object DataView]' != getTag(new DataView(new ArrayBuffer(1)))) ||
        (Map && '[object Map]' != getTag(new Map())) ||
        (Promise && '[object Promise]' != getTag(Promise.resolve())) ||
        (Set && '[object Set]' != getTag(new Set())) ||
        (WeakMap && '[object WeakMap]' != getTag(new WeakMap()))) &&
        (getTag = function (value) {
          var result = baseGetTag(value),
            Ctor = '[object Object]' == result ? value.constructor : void 0,
            ctorString = Ctor ? toSource(Ctor) : '';
          if (ctorString)
            switch (ctorString) {
              case dataViewCtorString:
                return '[object DataView]';
              case mapCtorString:
                return '[object Map]';
              case promiseCtorString:
                return '[object Promise]';
              case setCtorString:
                return '[object Set]';
              case weakMapCtorString:
                return '[object WeakMap]';
            }
          return result;
        }),
        (module.exports = getTag);
    },
    function (module, exports, __webpack_require__) {
      var DataView = __webpack_require__(16)(__webpack_require__(12), 'DataView');
      module.exports = DataView;
    },
    function (module, exports, __webpack_require__) {
      var Promise = __webpack_require__(16)(__webpack_require__(12), 'Promise');
      module.exports = Promise;
    },
    function (module, exports, __webpack_require__) {
      var Set = __webpack_require__(16)(__webpack_require__(12), 'Set');
      module.exports = Set;
    },
    function (module, exports, __webpack_require__) {
      var WeakMap = __webpack_require__(16)(__webpack_require__(12), 'WeakMap');
      module.exports = WeakMap;
    },
    function (module, exports, __webpack_require__) {
      var baseIsArguments = __webpack_require__(209),
        isObjectLike = __webpack_require__(25),
        objectProto = Object.prototype,
        hasOwnProperty = objectProto.hasOwnProperty,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        isArguments = baseIsArguments(
          (function () {
            return arguments;
          })()
        )
          ? baseIsArguments
          : function (value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, 'callee') &&
                !propertyIsEnumerable.call(value, 'callee')
              );
            };
      module.exports = isArguments;
    },
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(17),
        isObjectLike = __webpack_require__(25);
      module.exports = function baseIsArguments(value) {
        return isObjectLike(value) && '[object Arguments]' == baseGetTag(value);
      };
    },
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(54),
        isLength = __webpack_require__(65);
      module.exports = function isArrayLike(value) {
        return null != value && isLength(value.length) && !isFunction(value);
      };
    },
    function (module, exports, __webpack_require__) {
      (function (module) {
        var root = __webpack_require__(12),
          stubFalse = __webpack_require__(212),
          freeExports = exports && !exports.nodeType && exports,
          freeModule = freeExports && 'object' == typeof module && module && !module.nodeType && module,
          Buffer = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0,
          isBuffer = (Buffer ? Buffer.isBuffer : void 0) || stubFalse;
        module.exports = isBuffer;
      }.call(this, __webpack_require__(66)(module)));
    },
    function (module, exports) {
      module.exports = function stubFalse() {
        return !1;
      };
    },
    function (module, exports, __webpack_require__) {
      var baseIsTypedArray = __webpack_require__(214),
        baseUnary = __webpack_require__(215),
        nodeUtil = __webpack_require__(216),
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray,
        isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    },
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(17),
        isLength = __webpack_require__(65),
        isObjectLike = __webpack_require__(25),
        typedArrayTags = {};
      (typedArrayTags['[object Float32Array]'] = typedArrayTags['[object Float64Array]'] = typedArrayTags[
        '[object Int8Array]'
      ] = typedArrayTags['[object Int16Array]'] = typedArrayTags['[object Int32Array]'] = typedArrayTags[
        '[object Uint8Array]'
      ] = typedArrayTags['[object Uint8ClampedArray]'] = typedArrayTags['[object Uint16Array]'] = typedArrayTags[
        '[object Uint32Array]'
      ] = !0),
        (typedArrayTags['[object Arguments]'] = typedArrayTags['[object Array]'] = typedArrayTags[
          '[object ArrayBuffer]'
        ] = typedArrayTags['[object Boolean]'] = typedArrayTags['[object DataView]'] = typedArrayTags[
          '[object Date]'
        ] = typedArrayTags['[object Error]'] = typedArrayTags['[object Function]'] = typedArrayTags[
          '[object Map]'
        ] = typedArrayTags['[object Number]'] = typedArrayTags['[object Object]'] = typedArrayTags[
          '[object RegExp]'
        ] = typedArrayTags['[object Set]'] = typedArrayTags['[object String]'] = typedArrayTags[
          '[object WeakMap]'
        ] = !1),
        (module.exports = function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        });
    },
    function (module, exports) {
      module.exports = function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      };
    },
    function (module, exports, __webpack_require__) {
      (function (module) {
        var freeGlobal = __webpack_require__(53),
          freeExports = exports && !exports.nodeType && exports,
          freeModule = freeExports && 'object' == typeof module && module && !module.nodeType && module,
          freeProcess = freeModule && freeModule.exports === freeExports && freeGlobal.process,
          nodeUtil = (function () {
            try {
              var types = freeModule && freeModule.require && freeModule.require('util').types;
              return types || (freeProcess && freeProcess.binding && freeProcess.binding('util'));
            } catch (e) {}
          })();
        module.exports = nodeUtil;
      }.call(this, __webpack_require__(66)(module)));
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(227);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8),
        bind = __webpack_require__(67),
        Axios = __webpack_require__(228),
        mergeConfig = __webpack_require__(73);
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig),
          instance = bind(Axios.prototype.request, context);
        return utils.extend(instance, Axios.prototype, context), utils.extend(instance, context), instance;
      }
      var axios = createInstance(__webpack_require__(70));
      (axios.Axios = Axios),
        (axios.create = function create(instanceConfig) {
          return createInstance(mergeConfig(axios.defaults, instanceConfig));
        }),
        (axios.Cancel = __webpack_require__(74)),
        (axios.CancelToken = __webpack_require__(242)),
        (axios.isCancel = __webpack_require__(69)),
        (axios.all = function all(promises) {
          return Promise.all(promises);
        }),
        (axios.spread = __webpack_require__(243)),
        (module.exports = axios),
        (module.exports.default = axios);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8),
        buildURL = __webpack_require__(68),
        InterceptorManager = __webpack_require__(229),
        dispatchRequest = __webpack_require__(230),
        mergeConfig = __webpack_require__(73);
      function Axios(instanceConfig) {
        (this.defaults = instanceConfig),
          (this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() });
      }
      (Axios.prototype.request = function request(config) {
        'string' == typeof config ? ((config = arguments[1] || {}).url = arguments[0]) : (config = config || {}),
          (config = mergeConfig(this.defaults, config)).method
            ? (config.method = config.method.toLowerCase())
            : this.defaults.method
            ? (config.method = this.defaults.method.toLowerCase())
            : (config.method = 'get');
        var chain = [dispatchRequest, void 0],
          promise = Promise.resolve(config);
        for (
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            chain.unshift(interceptor.fulfilled, interceptor.rejected);
          }),
            this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
              chain.push(interceptor.fulfilled, interceptor.rejected);
            });
          chain.length;

        )
          promise = promise.then(chain.shift(), chain.shift());
        return promise;
      }),
        (Axios.prototype.getUri = function getUri(config) {
          return (
            (config = mergeConfig(this.defaults, config)),
            buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '')
          );
        }),
        utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
          Axios.prototype[method] = function (url, config) {
            return this.request(utils.merge(config || {}, { method, url }));
          };
        }),
        utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
          Axios.prototype[method] = function (url, data, config) {
            return this.request(utils.merge(config || {}, { method, url, data }));
          };
        }),
        (module.exports = Axios);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8);
      function InterceptorManager() {
        this.handlers = [];
      }
      (InterceptorManager.prototype.use = function use(fulfilled, rejected) {
        return this.handlers.push({ fulfilled, rejected }), this.handlers.length - 1;
      }),
        (InterceptorManager.prototype.eject = function eject(id) {
          this.handlers[id] && (this.handlers[id] = null);
        }),
        (InterceptorManager.prototype.forEach = function forEach(fn) {
          utils.forEach(this.handlers, function forEachHandler(h) {
            null !== h && fn(h);
          });
        }),
        (module.exports = InterceptorManager);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8),
        transformData = __webpack_require__(231),
        isCancel = __webpack_require__(69),
        defaults = __webpack_require__(70);
      function throwIfCancellationRequested(config) {
        config.cancelToken && config.cancelToken.throwIfRequested();
      }
      module.exports = function dispatchRequest(config) {
        return (
          throwIfCancellationRequested(config),
          (config.headers = config.headers || {}),
          (config.data = transformData(config.data, config.headers, config.transformRequest)),
          (config.headers = utils.merge(
            config.headers.common || {},
            config.headers[config.method] || {},
            config.headers
          )),
          utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(
            method
          ) {
            delete config.headers[method];
          }),
          (config.adapter || defaults.adapter)(config).then(
            function onAdapterResolution(response) {
              return (
                throwIfCancellationRequested(config),
                (response.data = transformData(response.data, response.headers, config.transformResponse)),
                response
              );
            },
            function onAdapterRejection(reason) {
              return (
                isCancel(reason) ||
                  (throwIfCancellationRequested(config),
                  reason &&
                    reason.response &&
                    (reason.response.data = transformData(
                      reason.response.data,
                      reason.response.headers,
                      config.transformResponse
                    ))),
                Promise.reject(reason)
              );
            }
          )
        );
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8);
      module.exports = function transformData(data, headers, fns) {
        return (
          utils.forEach(fns, function transform(fn) {
            data = fn(data, headers);
          }),
          data
        );
      };
    },
    function (module, exports) {
      var cachedSetTimeout,
        cachedClearTimeout,
        process = (module.exports = {});
      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
          return (cachedSetTimeout = setTimeout), setTimeout(fun, 0);
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      !(function () {
        try {
          cachedSetTimeout = 'function' == typeof setTimeout ? setTimeout : defaultSetTimout;
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          cachedClearTimeout = 'function' == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      var currentQueue,
        queue = [],
        draining = !1,
        queueIndex = -1;
      function cleanUpNextTick() {
        draining &&
          currentQueue &&
          ((draining = !1),
          currentQueue.length ? (queue = currentQueue.concat(queue)) : (queueIndex = -1),
          queue.length && drainQueue());
      }
      function drainQueue() {
        if (!draining) {
          var timeout = runTimeout(cleanUpNextTick);
          draining = !0;
          for (var len = queue.length; len; ) {
            for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
            (queueIndex = -1), (len = queue.length);
          }
          (currentQueue = null),
            (draining = !1),
            (function runClearTimeout(marker) {
              if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
              if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
                return (cachedClearTimeout = clearTimeout), clearTimeout(marker);
              try {
                return cachedClearTimeout(marker);
              } catch (e) {
                try {
                  return cachedClearTimeout.call(null, marker);
                } catch (e) {
                  return cachedClearTimeout.call(this, marker);
                }
              }
            })(timeout);
        }
      }
      function Item(fun, array) {
        (this.fun = fun), (this.array = array);
      }
      function noop() {}
      (process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
        queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
      }),
        (Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (process.title = 'browser'),
        (process.browser = !0),
        (process.env = {}),
        (process.argv = []),
        (process.version = ''),
        (process.versions = {}),
        (process.on = noop),
        (process.addListener = noop),
        (process.once = noop),
        (process.off = noop),
        (process.removeListener = noop),
        (process.removeAllListeners = noop),
        (process.emit = noop),
        (process.prependListener = noop),
        (process.prependOnceListener = noop),
        (process.listeners = function (name) {
          return [];
        }),
        (process.binding = function (name) {
          throw new Error('process.binding is not supported');
        }),
        (process.cwd = function () {
          return '/';
        }),
        (process.chdir = function (dir) {
          throw new Error('process.chdir is not supported');
        }),
        (process.umask = function () {
          return 0;
        });
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8);
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          name !== normalizedName &&
            name.toUpperCase() === normalizedName.toUpperCase() &&
            ((headers[normalizedName] = value), delete headers[name]);
        });
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var createError = __webpack_require__(72);
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        !validateStatus || validateStatus(response.status)
          ? resolve(response)
          : reject(
              createError(
                'Request failed with status code ' + response.status,
                response.config,
                null,
                response.request,
                response
              )
            );
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = function enhanceError(error, config, code, request, response) {
        return (
          (error.config = config),
          code && (error.code = code),
          (error.request = request),
          (error.response = response),
          (error.isAxiosError = !0),
          (error.toJSON = function () {
            return {
              message: this.message,
              name: this.name,
              description: this.description,
              number: this.number,
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              config: this.config,
              code: this.code,
            };
          }),
          error
        );
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var isAbsoluteURL = __webpack_require__(237),
        combineURLs = __webpack_require__(238);
      module.exports = function buildFullPath(baseURL, requestedURL) {
        return baseURL && !isAbsoluteURL(requestedURL) ? combineURLs(baseURL, requestedURL) : requestedURL;
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8),
        ignoreDuplicateOf = [
          'age',
          'authorization',
          'content-length',
          'content-type',
          'etag',
          'expires',
          'from',
          'host',
          'if-modified-since',
          'if-unmodified-since',
          'last-modified',
          'location',
          'max-forwards',
          'proxy-authorization',
          'referer',
          'retry-after',
          'user-agent',
        ];
      module.exports = function parseHeaders(headers) {
        var key,
          val,
          i,
          parsed = {};
        return headers
          ? (utils.forEach(headers.split('\n'), function parser(line) {
              if (
                ((i = line.indexOf(':')),
                (key = utils.trim(line.substr(0, i)).toLowerCase()),
                (val = utils.trim(line.substr(i + 1))),
                key)
              ) {
                if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) return;
                parsed[key] =
                  'set-cookie' === key
                    ? (parsed[key] ? parsed[key] : []).concat([val])
                    : parsed[key]
                    ? parsed[key] + ', ' + val
                    : val;
              }
            }),
            parsed)
          : parsed;
      };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8);
      module.exports = utils.isStandardBrowserEnv()
        ? (function standardBrowserEnv() {
            var originURL,
              msie = /(msie|trident)/i.test(navigator.userAgent),
              urlParsingNode = document.createElement('a');
            function resolveURL(url) {
              var href = url;
              return (
                msie && (urlParsingNode.setAttribute('href', href), (href = urlParsingNode.href)),
                urlParsingNode.setAttribute('href', href),
                {
                  href: urlParsingNode.href,
                  protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                  host: urlParsingNode.host,
                  search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                  hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                  hostname: urlParsingNode.hostname,
                  port: urlParsingNode.port,
                  pathname:
                    '/' === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : '/' + urlParsingNode.pathname,
                }
              );
            }
            return (
              (originURL = resolveURL(window.location.href)),
              function isURLSameOrigin(requestURL) {
                var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
                return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
              }
            );
          })()
        : function isURLSameOrigin() {
            return !0;
          };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var utils = __webpack_require__(8);
      module.exports = utils.isStandardBrowserEnv()
        ? (function standardBrowserEnv() {
            return {
              write: function write(name, value, expires, path, domain, secure) {
                var cookie = [];
                cookie.push(name + '=' + encodeURIComponent(value)),
                  utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString()),
                  utils.isString(path) && cookie.push('path=' + path),
                  utils.isString(domain) && cookie.push('domain=' + domain),
                  !0 === secure && cookie.push('secure'),
                  (document.cookie = cookie.join('; '));
              },
              read: function read(name) {
                var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
                return match ? decodeURIComponent(match[3]) : null;
              },
              remove: function remove(name) {
                this.write(name, '', Date.now() - 864e5);
              },
            };
          })()
        : {
            write: function write() {},
            read: function read() {
              return null;
            },
            remove: function remove() {},
          };
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      var Cancel = __webpack_require__(74);
      function CancelToken(executor) {
        if ('function' != typeof executor) throw new TypeError('executor must be a function.');
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        executor(function cancel(message) {
          token.reason || ((token.reason = new Cancel(message)), resolvePromise(token.reason));
        });
      }
      (CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) throw this.reason;
      }),
        (CancelToken.source = function source() {
          var cancel;
          return {
            token: new CancelToken(function executor(c) {
              cancel = c;
            }),
            cancel,
          };
        }),
        (module.exports = CancelToken);
    },
    function (module, exports, __webpack_require__) {
      'use strict';
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    },
    ,
    ,
    ,
    ,
    function (module, exports, __webpack_require__) {
      'use strict';
      var extendStatics,
        __extends =
          (this && this.__extends) ||
          ((extendStatics = function (d, b) {
            return (extendStatics =
              Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array &&
                function (d, b) {
                  d.__proto__ = b;
                }) ||
              function (d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
              })(d, b);
          }),
          function (d, b) {
            function __() {
              this.constructor = d;
            }
            extendStatics(d, b),
              (d.prototype = null === b ? Object.create(b) : ((__.prototype = b.prototype), new __()));
          }),
        __assign =
          (this && this.__assign) ||
          function () {
            return (__assign =
              Object.assign ||
              function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++)
                  for (var p in (s = arguments[i])) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
                return t;
              }).apply(this, arguments);
          },
        __rest =
          (this && this.__rest) ||
          function (s, e) {
            var t = {};
            for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
            if (null != s && 'function' == typeof Object.getOwnPropertySymbols) {
              var i = 0;
              for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && (t[p[i]] = s[p[i]]);
            }
            return t;
          },
        __importStar =
          (this && this.__importStar) ||
          function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) for (var k in mod) Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
            return (result.default = mod), result;
          },
        PropTypes = __importStar(__webpack_require__(1)),
        React = __importStar(__webpack_require__(0));
      function getStyle(name, theme, styles) {
        var value = (function getStyleValue(name, theme, styles) {
          var extra = styles[name + 'Style'] || '',
            style = (theme && theme[name]) || '';
          return extra ? extra + ';' + style : style;
        })(name, theme, styles);
        return value ? ' style="' + value + '"' : '';
      }
      var xssmap = { '"': '&quot;', "'": '&apos;', '&': '&amp;', '>': '&gt;', '<': '&lt' };
      var JSONPretty = (function (_super) {
        function JSONPretty() {
          return (null !== _super && _super.apply(this, arguments)) || this;
        }
        return (
          __extends(JSONPretty, _super),
          (JSONPretty.prototype.render = function () {
            var s,
              _a = this.props,
              json = _a.json,
              data = _a.data,
              replacer = _a.replacer,
              space = _a.space,
              themeClassName = _a.themeClassName,
              theme = _a.theme,
              onJSONPrettyError = _a.onJSONPrettyError,
              onError = _a.onError,
              silent = _a.silent,
              mainStyle = _a.mainStyle,
              keyStyle = _a.keyStyle,
              valueStyle = _a.valueStyle,
              stringStyle = _a.stringStyle,
              booleanStyle = _a.booleanStyle,
              errorStyle = _a.errorStyle,
              rest = __rest(_a, [
                'json',
                'data',
                'replacer',
                'space',
                'themeClassName',
                'theme',
                'onJSONPrettyError',
                'onError',
                'silent',
                'mainStyle',
                'keyStyle',
                'valueStyle',
                'stringStyle',
                'booleanStyle',
                'errorStyle',
              ]),
              styles = { mainStyle, keyStyle, valueStyle, stringStyle, booleanStyle, errorStyle },
              obj = data || json;
            if ('string' == typeof obj)
              try {
                obj = JSON.parse(obj);
              } catch (e) {
                return (
                  silent || console.warn('[react-json-pretty]: ' + e.message),
                  onJSONPrettyError && onJSONPrettyError(e),
                  !onJSONPrettyError &&
                    onError &&
                    (onError(e),
                    console.warn('JSONPretty#onError is deprecated, please use JSONPretty#onJSONPrettyError instead')),
                  React.createElement(
                    'div',
                    __assign({}, rest, {
                      dangerouslySetInnerHTML: {
                        __html:
                          '<pre class="__json-pretty-error__"' +
                          getStyle('error', theme, styles) +
                          '>' +
                          ((s = obj),
                          (s
                            ? s.replace(/<|>|&|"|'/g, function (m) {
                                return xssmap[m];
                              })
                            : s) + '</pre>'),
                      },
                    })
                  )
                );
              }
            return React.createElement(
              'div',
              __assign({}, rest, {
                dangerouslySetInnerHTML: {
                  __html:
                    '<pre class="' +
                    themeClassName +
                    '"' +
                    getStyle('main', theme, styles) +
                    '>' +
                    this._pretty(theme, obj, replacer, +space, styles) +
                    '</pre>',
                },
              })
            );
          }),
          (JSONPretty.prototype._pretty = function (theme, obj, replacer, space, styles) {
            var text = JSON.stringify(obj, 'function' == typeof replacer ? replacer : null, isNaN(space) ? 2 : space);
            return text
              ? text
                  .replace(/&/g, '&amp;')
                  .replace(/\\"([^,])/g, '\\&quot;$1')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(
                    /^( *)("[^"]+": )?("[^"]*"|[\w.+-]*)?([,[{]|\[\s*\],?|\{\s*\},?)?$/gm,
                    this._replace.bind(null, theme, styles)
                  )
              : text;
          }),
          (JSONPretty.prototype._replace = function (theme, styles, match, ind, key, val, tra) {
            var keySpan = '<span class="__json-key__"' + getStyle('key', theme, styles) + '>',
              valSpan = '<span class="__json-value__"' + getStyle('value', theme, styles) + '>',
              strSpan = '<span class="__json-string__"' + getStyle('string', theme, styles) + '>',
              booSpan = '<span class="__json-boolean__"' + getStyle('boolean', theme, styles) + '>',
              sps = ind || '';
            return (
              key && (sps = sps + '"' + keySpan + key.replace(/^"|":\s$/g, '') + '</span>": '),
              val &&
                (sps =
                  'true' === val || 'false' === val
                    ? sps + booSpan + val + '</span>'
                    : sps + ('"' === val[0] ? strSpan : valSpan) + val + '</span>'),
              sps + (tra || '')
            );
          }),
          (JSONPretty.propTypes = {
            data: PropTypes.any,
            json: PropTypes.any,
            replacer: PropTypes.func,
            silent: PropTypes.bool,
            space: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            theme: PropTypes.object,
            themeClassName: PropTypes.string,
            onJSONPrettyError: PropTypes.func,
          }),
          (JSONPretty.defaultProps = { data: '', json: '', silent: !0, space: 2, themeClassName: '__json-pretty__' }),
          JSONPretty
        );
      })(React.Component);
      module.exports = JSONPretty;
    },
    ,
    ,
    ,
    function (module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function toInteger(dirtyNumber) {
        if (null === dirtyNumber || !0 === dirtyNumber || !1 === dirtyNumber) return NaN;
        var number = Number(dirtyNumber);
        return isNaN(number) ? number : number < 0 ? Math.ceil(number) : Math.floor(number);
      }
      function requiredArgs(required, args) {
        if (args.length < required)
          throw new TypeError(
            required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present'
          );
      }
      function toDate(argument) {
        requiredArgs(1, arguments);
        var argStr = Object.prototype.toString.call(argument);
        return argument instanceof Date || ('object' == typeof argument && '[object Date]' === argStr)
          ? new Date(argument.getTime())
          : 'number' == typeof argument || '[object Number]' === argStr
          ? new Date(argument)
          : (('string' != typeof argument && '[object String]' !== argStr) ||
              'undefined' == typeof console ||
              (console.warn(
                "Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"
              ),
              console.warn(new Error().stack)),
            new Date(NaN));
      }
      function addDays(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          amount = toInteger(dirtyAmount);
        return isNaN(amount) ? new Date(NaN) : amount ? (date.setDate(date.getDate() + amount), date) : date;
      }
      function addMonths(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          amount = toInteger(dirtyAmount);
        if (isNaN(amount)) return new Date(NaN);
        if (!amount) return date;
        var dayOfMonth = date.getDate(),
          endOfDesiredMonth = new Date(date.getTime());
        endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
        var daysInMonth = endOfDesiredMonth.getDate();
        return dayOfMonth >= daysInMonth
          ? endOfDesiredMonth
          : (date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth), date);
      }
      function add(dirtyDate, duration) {
        if ((requiredArgs(2, arguments), !duration || 'object' != typeof duration)) return new Date(NaN);
        var years = 'years' in duration ? toInteger(duration.years) : 0,
          months = 'months' in duration ? toInteger(duration.months) : 0,
          weeks = 'weeks' in duration ? toInteger(duration.weeks) : 0,
          days = 'days' in duration ? toInteger(duration.days) : 0,
          hours = 'hours' in duration ? toInteger(duration.hours) : 0,
          minutes = 'minutes' in duration ? toInteger(duration.minutes) : 0,
          seconds = 'seconds' in duration ? toInteger(duration.seconds) : 0,
          date = toDate(dirtyDate),
          dateWithMonths = months || years ? addMonths(date, months + 12 * years) : date,
          dateWithDays = days || weeks ? addDays(dateWithMonths, days + 7 * weeks) : dateWithMonths,
          minutesToAdd = minutes + 60 * hours,
          secondsToAdd = seconds + 60 * minutesToAdd,
          msToAdd = 1e3 * secondsToAdd,
          finalDate = new Date(dateWithDays.getTime() + msToAdd);
        return finalDate;
      }
      function isWeekend(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          day = date.getDay();
        return 0 === day || 6 === day;
      }
      function isSunday(dirtyDate) {
        return requiredArgs(1, arguments), 0 === toDate(dirtyDate).getDay();
      }
      function isSaturday(dirtyDate) {
        return requiredArgs(1, arguments), 6 === toDate(dirtyDate).getDay();
      }
      function addBusinessDays(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          startedOnWeekend = isWeekend(date),
          amount = toInteger(dirtyAmount);
        if (isNaN(amount)) return new Date(NaN);
        var hours = date.getHours(),
          sign = amount < 0 ? -1 : 1,
          fullWeeks = toInteger(amount / 5);
        date.setDate(date.getDate() + 7 * fullWeeks);
        for (var restDays = Math.abs(amount % 5); restDays > 0; )
          date.setDate(date.getDate() + sign), isWeekend(date) || (restDays -= 1);
        return (
          startedOnWeekend &&
            isWeekend(date) &&
            0 !== amount &&
            (isSaturday(date) && date.setDate(date.getDate() + (sign < 0 ? 2 : -1)),
            isSunday(date) && date.setDate(date.getDate() + (sign < 0 ? 1 : -2))),
          date.setHours(hours),
          date
        );
      }
      function addMilliseconds(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var timestamp = toDate(dirtyDate).getTime(),
          amount = toInteger(dirtyAmount);
        return new Date(timestamp + amount);
      }
      __webpack_require__.r(__webpack_exports__),
        __webpack_require__.d(__webpack_exports__, 'add', function () {
          return add;
        }),
        __webpack_require__.d(__webpack_exports__, 'addBusinessDays', function () {
          return addBusinessDays;
        }),
        __webpack_require__.d(__webpack_exports__, 'addDays', function () {
          return addDays;
        }),
        __webpack_require__.d(__webpack_exports__, 'addHours', function () {
          return addHours;
        }),
        __webpack_require__.d(__webpack_exports__, 'addISOWeekYears', function () {
          return addISOWeekYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'addMilliseconds', function () {
          return addMilliseconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'addMinutes', function () {
          return addMinutes;
        }),
        __webpack_require__.d(__webpack_exports__, 'addMonths', function () {
          return addMonths;
        }),
        __webpack_require__.d(__webpack_exports__, 'addQuarters', function () {
          return addQuarters;
        }),
        __webpack_require__.d(__webpack_exports__, 'addSeconds', function () {
          return addSeconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'addWeeks', function () {
          return addWeeks;
        }),
        __webpack_require__.d(__webpack_exports__, 'addYears', function () {
          return addYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'areIntervalsOverlapping', function () {
          return areIntervalsOverlapping;
        }),
        __webpack_require__.d(__webpack_exports__, 'closestIndexTo', function () {
          return closestIndexTo;
        }),
        __webpack_require__.d(__webpack_exports__, 'closestTo', function () {
          return closestTo;
        }),
        __webpack_require__.d(__webpack_exports__, 'compareAsc', function () {
          return compareAsc;
        }),
        __webpack_require__.d(__webpack_exports__, 'compareDesc', function () {
          return compareDesc;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInBusinessDays', function () {
          return differenceInBusinessDays;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInCalendarDays', function () {
          return differenceInCalendarDays;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInCalendarISOWeekYears', function () {
          return differenceInCalendarISOWeekYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInCalendarISOWeeks', function () {
          return differenceInCalendarISOWeeks;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInCalendarMonths', function () {
          return differenceInCalendarMonths;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInCalendarQuarters', function () {
          return differenceInCalendarQuarters;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInCalendarWeeks', function () {
          return differenceInCalendarWeeks;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInCalendarYears', function () {
          return differenceInCalendarYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInDays', function () {
          return differenceInDays;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInHours', function () {
          return differenceInHours;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInISOWeekYears', function () {
          return differenceInISOWeekYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInMilliseconds', function () {
          return differenceInMilliseconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInMinutes', function () {
          return differenceInMinutes;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInMonths', function () {
          return differenceInMonths;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInQuarters', function () {
          return differenceInQuarters;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInSeconds', function () {
          return differenceInSeconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInWeeks', function () {
          return differenceInWeeks;
        }),
        __webpack_require__.d(__webpack_exports__, 'differenceInYears', function () {
          return differenceInYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachDayOfInterval', function () {
          return eachDayOfInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachHourOfInterval', function () {
          return eachHourOfInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachMonthOfInterval', function () {
          return eachMonthOfInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachQuarterOfInterval', function () {
          return eachQuarterOfInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachWeekOfInterval', function () {
          return eachWeekOfInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachWeekendOfInterval', function () {
          return eachWeekendOfInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachWeekendOfMonth', function () {
          return eachWeekendOfMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachWeekendOfYear', function () {
          return eachWeekendOfYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'eachYearOfInterval', function () {
          return eachYearOfInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfDay', function () {
          return endOfDay;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfDecade', function () {
          return endOfDecade;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfHour', function () {
          return endOfHour;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfISOWeek', function () {
          return endOfISOWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfISOWeekYear', function () {
          return endOfISOWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfMinute', function () {
          return endOfMinute;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfMonth', function () {
          return endOfMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfQuarter', function () {
          return endOfQuarter;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfSecond', function () {
          return endOfSecond;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfToday', function () {
          return endOfToday;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfTomorrow', function () {
          return endOfTomorrow;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfWeek', function () {
          return endOfWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfYear', function () {
          return endOfYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'endOfYesterday', function () {
          return endOfYesterday;
        }),
        __webpack_require__.d(__webpack_exports__, 'format', function () {
          return format_format;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatDistance', function () {
          return formatDistance_formatDistance;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatDistanceStrict', function () {
          return formatDistanceStrict;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatDistanceToNow', function () {
          return formatDistanceToNow;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatDistanceToNowStrict', function () {
          return formatDistanceToNowStrict;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatDuration', function () {
          return formatDuration;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatISO', function () {
          return formatISO;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatISO9075', function () {
          return formatISO9075;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatISODuration', function () {
          return formatISODuration;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatRFC3339', function () {
          return formatRFC3339;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatRFC7231', function () {
          return formatRFC7231;
        }),
        __webpack_require__.d(__webpack_exports__, 'formatRelative', function () {
          return formatRelative_formatRelative;
        }),
        __webpack_require__.d(__webpack_exports__, 'fromUnixTime', function () {
          return fromUnixTime;
        }),
        __webpack_require__.d(__webpack_exports__, 'getDate', function () {
          return getDate;
        }),
        __webpack_require__.d(__webpack_exports__, 'getDay', function () {
          return getDay;
        }),
        __webpack_require__.d(__webpack_exports__, 'getDayOfYear', function () {
          return getDayOfYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'getDaysInMonth', function () {
          return getDaysInMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'getDaysInYear', function () {
          return getDaysInYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'getDecade', function () {
          return getDecade;
        }),
        __webpack_require__.d(__webpack_exports__, 'getHours', function () {
          return getHours;
        }),
        __webpack_require__.d(__webpack_exports__, 'getISODay', function () {
          return getISODay;
        }),
        __webpack_require__.d(__webpack_exports__, 'getISOWeek', function () {
          return getISOWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'getISOWeekYear', function () {
          return getISOWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'getISOWeeksInYear', function () {
          return getISOWeeksInYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'getMilliseconds', function () {
          return getMilliseconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'getMinutes', function () {
          return getMinutes;
        }),
        __webpack_require__.d(__webpack_exports__, 'getMonth', function () {
          return getMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'getOverlappingDaysInIntervals', function () {
          return getOverlappingDaysInIntervals;
        }),
        __webpack_require__.d(__webpack_exports__, 'getQuarter', function () {
          return getQuarter;
        }),
        __webpack_require__.d(__webpack_exports__, 'getSeconds', function () {
          return getSeconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'getTime', function () {
          return getTime;
        }),
        __webpack_require__.d(__webpack_exports__, 'getUnixTime', function () {
          return getUnixTime;
        }),
        __webpack_require__.d(__webpack_exports__, 'getWeek', function () {
          return getWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'getWeekOfMonth', function () {
          return getWeekOfMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'getWeekYear', function () {
          return getWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'getWeeksInMonth', function () {
          return getWeeksInMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'getYear', function () {
          return getYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'intervalToDuration', function () {
          return intervalToDuration;
        }),
        __webpack_require__.d(__webpack_exports__, 'isAfter', function () {
          return isAfter;
        }),
        __webpack_require__.d(__webpack_exports__, 'isBefore', function () {
          return isBefore;
        }),
        __webpack_require__.d(__webpack_exports__, 'isDate', function () {
          return isDate;
        }),
        __webpack_require__.d(__webpack_exports__, 'isEqual', function () {
          return isEqual;
        }),
        __webpack_require__.d(__webpack_exports__, 'isExists', function () {
          return isExists;
        }),
        __webpack_require__.d(__webpack_exports__, 'isFirstDayOfMonth', function () {
          return isFirstDayOfMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'isFriday', function () {
          return isFriday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isFuture', function () {
          return isFuture;
        }),
        __webpack_require__.d(__webpack_exports__, 'isLastDayOfMonth', function () {
          return isLastDayOfMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'isLeapYear', function () {
          return isLeapYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'isMatch', function () {
          return isMatch;
        }),
        __webpack_require__.d(__webpack_exports__, 'isMonday', function () {
          return isMonday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isPast', function () {
          return isPast;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameDay', function () {
          return isSameDay;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameHour', function () {
          return isSameHour;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameISOWeek', function () {
          return isSameISOWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameISOWeekYear', function () {
          return isSameISOWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameMinute', function () {
          return isSameMinute;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameMonth', function () {
          return isSameMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameQuarter', function () {
          return isSameQuarter;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameSecond', function () {
          return isSameSecond;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameWeek', function () {
          return isSameWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSameYear', function () {
          return isSameYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSaturday', function () {
          return isSaturday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isSunday', function () {
          return isSunday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisHour', function () {
          return isThisHour;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisISOWeek', function () {
          return isThisISOWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisMinute', function () {
          return isThisMinute;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisMonth', function () {
          return isThisMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisQuarter', function () {
          return isThisQuarter;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisSecond', function () {
          return isThisSecond;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisWeek', function () {
          return isThisWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThisYear', function () {
          return isThisYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'isThursday', function () {
          return isThursday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isToday', function () {
          return isToday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isTomorrow', function () {
          return isTomorrow;
        }),
        __webpack_require__.d(__webpack_exports__, 'isTuesday', function () {
          return isTuesday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isValid', function () {
          return isValid;
        }),
        __webpack_require__.d(__webpack_exports__, 'isWednesday', function () {
          return isWednesday;
        }),
        __webpack_require__.d(__webpack_exports__, 'isWeekend', function () {
          return isWeekend;
        }),
        __webpack_require__.d(__webpack_exports__, 'isWithinInterval', function () {
          return isWithinInterval;
        }),
        __webpack_require__.d(__webpack_exports__, 'isYesterday', function () {
          return isYesterday;
        }),
        __webpack_require__.d(__webpack_exports__, 'lastDayOfDecade', function () {
          return lastDayOfDecade;
        }),
        __webpack_require__.d(__webpack_exports__, 'lastDayOfISOWeek', function () {
          return lastDayOfISOWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'lastDayOfISOWeekYear', function () {
          return lastDayOfISOWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'lastDayOfMonth', function () {
          return lastDayOfMonth_lastDayOfMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'lastDayOfQuarter', function () {
          return lastDayOfQuarter;
        }),
        __webpack_require__.d(__webpack_exports__, 'lastDayOfWeek', function () {
          return lastDayOfWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'lastDayOfYear', function () {
          return lastDayOfYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'lightFormat', function () {
          return lightFormat;
        }),
        __webpack_require__.d(__webpack_exports__, 'max', function () {
          return max;
        }),
        __webpack_require__.d(__webpack_exports__, 'min', function () {
          return min;
        }),
        __webpack_require__.d(__webpack_exports__, 'parse', function () {
          return parse;
        }),
        __webpack_require__.d(__webpack_exports__, 'parseISO', function () {
          return parseISO;
        }),
        __webpack_require__.d(__webpack_exports__, 'parseJSON', function () {
          return parseJSON;
        }),
        __webpack_require__.d(__webpack_exports__, 'roundToNearestMinutes', function () {
          return roundToNearestMinutes;
        }),
        __webpack_require__.d(__webpack_exports__, 'set', function () {
          return set;
        }),
        __webpack_require__.d(__webpack_exports__, 'setDate', function () {
          return setDate;
        }),
        __webpack_require__.d(__webpack_exports__, 'setDay', function () {
          return setDay;
        }),
        __webpack_require__.d(__webpack_exports__, 'setDayOfYear', function () {
          return setDayOfYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'setHours', function () {
          return setHours;
        }),
        __webpack_require__.d(__webpack_exports__, 'setISODay', function () {
          return setISODay;
        }),
        __webpack_require__.d(__webpack_exports__, 'setISOWeek', function () {
          return setISOWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'setISOWeekYear', function () {
          return setISOWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'setMilliseconds', function () {
          return setMilliseconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'setMinutes', function () {
          return setMinutes;
        }),
        __webpack_require__.d(__webpack_exports__, 'setMonth', function () {
          return setMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'setQuarter', function () {
          return setQuarter;
        }),
        __webpack_require__.d(__webpack_exports__, 'setSeconds', function () {
          return setSeconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'setWeek', function () {
          return setWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'setWeekYear', function () {
          return setWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'setYear', function () {
          return setYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfDay', function () {
          return startOfDay;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfDecade', function () {
          return startOfDecade;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfHour', function () {
          return startOfHour;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfISOWeek', function () {
          return startOfISOWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfISOWeekYear', function () {
          return startOfISOWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfMinute', function () {
          return startOfMinute;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfMonth', function () {
          return startOfMonth;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfQuarter', function () {
          return startOfQuarter;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfSecond', function () {
          return startOfSecond;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfToday', function () {
          return startOfToday;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfTomorrow', function () {
          return startOfTomorrow;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfWeek', function () {
          return startOfWeek;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfWeekYear', function () {
          return startOfWeekYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfYear', function () {
          return startOfYear;
        }),
        __webpack_require__.d(__webpack_exports__, 'startOfYesterday', function () {
          return startOfYesterday;
        }),
        __webpack_require__.d(__webpack_exports__, 'sub', function () {
          return sub;
        }),
        __webpack_require__.d(__webpack_exports__, 'subBusinessDays', function () {
          return subBusinessDays;
        }),
        __webpack_require__.d(__webpack_exports__, 'subDays', function () {
          return subDays;
        }),
        __webpack_require__.d(__webpack_exports__, 'subHours', function () {
          return subHours;
        }),
        __webpack_require__.d(__webpack_exports__, 'subISOWeekYears', function () {
          return subISOWeekYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'subMilliseconds', function () {
          return subMilliseconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'subMinutes', function () {
          return subMinutes;
        }),
        __webpack_require__.d(__webpack_exports__, 'subMonths', function () {
          return subMonths;
        }),
        __webpack_require__.d(__webpack_exports__, 'subQuarters', function () {
          return subQuarters;
        }),
        __webpack_require__.d(__webpack_exports__, 'subSeconds', function () {
          return subSeconds;
        }),
        __webpack_require__.d(__webpack_exports__, 'subWeeks', function () {
          return subWeeks;
        }),
        __webpack_require__.d(__webpack_exports__, 'subYears', function () {
          return subYears;
        }),
        __webpack_require__.d(__webpack_exports__, 'toDate', function () {
          return toDate;
        }),
        __webpack_require__.d(__webpack_exports__, 'maxTime', function () {
          return maxTime;
        }),
        __webpack_require__.d(__webpack_exports__, 'minTime', function () {
          return minTime;
        });
      function addHours(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMilliseconds(dirtyDate, 36e5 * amount);
      }
      function startOfWeek(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        var date = toDate(dirtyDate),
          day = date.getDay(),
          diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
        return date.setDate(date.getDate() - diff), date.setHours(0, 0, 0, 0), date;
      }
      function startOfISOWeek(dirtyDate) {
        return requiredArgs(1, arguments), startOfWeek(dirtyDate, { weekStartsOn: 1 });
      }
      function getISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear(),
          fourthOfJanuaryOfNextYear = new Date(0);
        fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4), fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
        var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear),
          fourthOfJanuaryOfThisYear = new Date(0);
        fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4), fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
        var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
        return date.getTime() >= startOfNextYear.getTime()
          ? year + 1
          : date.getTime() >= startOfThisYear.getTime()
          ? year
          : year - 1;
      }
      function startOfISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var year = getISOWeekYear(dirtyDate),
          fourthOfJanuary = new Date(0);
        fourthOfJanuary.setFullYear(year, 0, 4), fourthOfJanuary.setHours(0, 0, 0, 0);
        var date = startOfISOWeek(fourthOfJanuary);
        return date;
      }
      function getDateMillisecondsPart(date) {
        return date.getTime() % 6e4;
      }
      function getTimezoneOffsetInMilliseconds(dirtyDate) {
        var date = new Date(dirtyDate.getTime()),
          baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
        return (
          date.setSeconds(0, 0),
          6e4 * baseTimezoneOffset +
            (baseTimezoneOffset > 0 ? (6e4 + getDateMillisecondsPart(date)) % 6e4 : getDateMillisecondsPart(date))
        );
      }
      function startOfDay(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setHours(0, 0, 0, 0), date;
      }
      function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var startOfDayLeft = startOfDay(dirtyDateLeft),
          startOfDayRight = startOfDay(dirtyDateRight),
          timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft),
          timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
        return Math.round((timestampLeft - timestampRight) / 864e5);
      }
      function setISOWeekYear(dirtyDate, dirtyISOWeekYear) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          isoWeekYear = toInteger(dirtyISOWeekYear),
          diff = differenceInCalendarDays(date, startOfISOWeekYear(date)),
          fourthOfJanuary = new Date(0);
        return (
          fourthOfJanuary.setFullYear(isoWeekYear, 0, 4),
          fourthOfJanuary.setHours(0, 0, 0, 0),
          (date = startOfISOWeekYear(fourthOfJanuary)).setDate(date.getDate() + diff),
          date
        );
      }
      function addISOWeekYears(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return setISOWeekYear(dirtyDate, getISOWeekYear(dirtyDate) + amount);
      }
      function addMinutes(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMilliseconds(dirtyDate, 6e4 * amount);
      }
      function addQuarters(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount),
          months = 3 * amount;
        return addMonths(dirtyDate, months);
      }
      function addSeconds(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMilliseconds(dirtyDate, 1e3 * amount);
      }
      function addWeeks(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount),
          days = 7 * amount;
        return addDays(dirtyDate, days);
      }
      function addYears(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMonths(dirtyDate, 12 * amount);
      }
      function areIntervalsOverlapping(dirtyIntervalLeft, dirtyIntervalRight) {
        var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        requiredArgs(2, arguments);
        var intervalLeft = dirtyIntervalLeft || {},
          intervalRight = dirtyIntervalRight || {},
          leftStartTime = toDate(intervalLeft.start).getTime(),
          leftEndTime = toDate(intervalLeft.end).getTime(),
          rightStartTime = toDate(intervalRight.start).getTime(),
          rightEndTime = toDate(intervalRight.end).getTime();
        if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) throw new RangeError('Invalid interval');
        return options.inclusive
          ? leftStartTime <= rightEndTime && rightStartTime <= leftEndTime
          : leftStartTime < rightEndTime && rightStartTime < leftEndTime;
      }
      function closestIndexTo(dirtyDateToCompare, dirtyDatesArray) {
        requiredArgs(2, arguments);
        var dateToCompare = toDate(dirtyDateToCompare);
        if (isNaN(dateToCompare)) return NaN;
        var result,
          minDistance,
          timeToCompare = dateToCompare.getTime();
        return (
          (null == dirtyDatesArray
            ? []
            : 'function' == typeof dirtyDatesArray.forEach
            ? dirtyDatesArray
            : Array.prototype.slice.call(dirtyDatesArray)
          ).forEach(function (dirtyDate, index) {
            var currentDate = toDate(dirtyDate);
            if (isNaN(currentDate)) return (result = NaN), void (minDistance = NaN);
            var distance = Math.abs(timeToCompare - currentDate.getTime());
            (null == result || distance < minDistance) && ((result = index), (minDistance = distance));
          }),
          result
        );
      }
      function closestTo(dirtyDateToCompare, dirtyDatesArray) {
        requiredArgs(2, arguments);
        var dateToCompare = toDate(dirtyDateToCompare);
        if (isNaN(dateToCompare)) return new Date(NaN);
        var result,
          minDistance,
          timeToCompare = dateToCompare.getTime();
        return (
          (null == dirtyDatesArray
            ? []
            : 'function' == typeof dirtyDatesArray.forEach
            ? dirtyDatesArray
            : Array.prototype.slice.call(dirtyDatesArray)
          ).forEach(function (dirtyDate) {
            var currentDate = toDate(dirtyDate);
            if (isNaN(currentDate)) return (result = new Date(NaN)), void (minDistance = NaN);
            var distance = Math.abs(timeToCompare - currentDate.getTime());
            (null == result || distance < minDistance) && ((result = currentDate), (minDistance = distance));
          }),
          result
        );
      }
      function compareAsc(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          diff = dateLeft.getTime() - dateRight.getTime();
        return diff < 0 ? -1 : diff > 0 ? 1 : diff;
      }
      function compareDesc(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          diff = dateLeft.getTime() - dateRight.getTime();
        return diff > 0 ? -1 : diff < 0 ? 1 : diff;
      }
      function isValid(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return !isNaN(date);
      }
      function isSameDay(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeftStartOfDay = startOfDay(dirtyDateLeft),
          dateRightStartOfDay = startOfDay(dirtyDateRight);
        return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
      }
      function differenceInBusinessDays(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight);
        if (!isValid(dateLeft) || !isValid(dateRight)) return new Date(NaN);
        var calendarDifference = differenceInCalendarDays(dateLeft, dateRight),
          sign = calendarDifference < 0 ? -1 : 1,
          weeks = toInteger(calendarDifference / 7),
          result = 5 * weeks;
        for (dateRight = addDays(dateRight, 7 * weeks); !isSameDay(dateLeft, dateRight); )
          (result += isWeekend(dateRight) ? 0 : sign), (dateRight = addDays(dateRight, sign));
        return 0 === result ? 0 : result;
      }
      function differenceInCalendarISOWeekYears(dirtyDateLeft, dirtyDateRight) {
        return requiredArgs(2, arguments), getISOWeekYear(dirtyDateLeft) - getISOWeekYear(dirtyDateRight);
      }
      function differenceInCalendarISOWeeks(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var startOfISOWeekLeft = startOfISOWeek(dirtyDateLeft),
          startOfISOWeekRight = startOfISOWeek(dirtyDateRight),
          timestampLeft = startOfISOWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfISOWeekLeft),
          timestampRight = startOfISOWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfISOWeekRight);
        return Math.round((timestampLeft - timestampRight) / 6048e5);
      }
      function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          yearDiff = dateLeft.getFullYear() - dateRight.getFullYear(),
          monthDiff = dateLeft.getMonth() - dateRight.getMonth();
        return 12 * yearDiff + monthDiff;
      }
      function getQuarter(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          quarter = Math.floor(date.getMonth() / 3) + 1;
        return quarter;
      }
      function differenceInCalendarQuarters(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          yearDiff = dateLeft.getFullYear() - dateRight.getFullYear(),
          quarterDiff = getQuarter(dateLeft) - getQuarter(dateRight);
        return 4 * yearDiff + quarterDiff;
      }
      function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, dirtyOptions) {
        requiredArgs(2, arguments);
        var startOfWeekLeft = startOfWeek(dirtyDateLeft, dirtyOptions),
          startOfWeekRight = startOfWeek(dirtyDateRight, dirtyOptions),
          timestampLeft = startOfWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekLeft),
          timestampRight = startOfWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekRight);
        return Math.round((timestampLeft - timestampRight) / 6048e5);
      }
      function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight);
        return dateLeft.getFullYear() - dateRight.getFullYear();
      }
      function compareLocalAsc(dateLeft, dateRight) {
        var diff =
          dateLeft.getFullYear() - dateRight.getFullYear() ||
          dateLeft.getMonth() - dateRight.getMonth() ||
          dateLeft.getDate() - dateRight.getDate() ||
          dateLeft.getHours() - dateRight.getHours() ||
          dateLeft.getMinutes() - dateRight.getMinutes() ||
          dateLeft.getSeconds() - dateRight.getSeconds() ||
          dateLeft.getMilliseconds() - dateRight.getMilliseconds();
        return diff < 0 ? -1 : diff > 0 ? 1 : diff;
      }
      function differenceInDays(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          sign = compareLocalAsc(dateLeft, dateRight),
          difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
        dateLeft.setDate(dateLeft.getDate() - sign * difference);
        var isLastDayNotFull = compareLocalAsc(dateLeft, dateRight) === -sign,
          result = sign * (difference - isLastDayNotFull);
        return 0 === result ? 0 : result;
      }
      function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight);
        return dateLeft.getTime() - dateRight.getTime();
      }
      function differenceInHours(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 36e5;
        return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
      }
      function subISOWeekYears(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addISOWeekYears(dirtyDate, -amount);
      }
      function differenceInISOWeekYears(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          sign = compareAsc(dateLeft, dateRight),
          difference = Math.abs(differenceInCalendarISOWeekYears(dateLeft, dateRight)),
          isLastISOWeekYearNotFull =
            compareAsc((dateLeft = subISOWeekYears(dateLeft, sign * difference)), dateRight) === -sign,
          result = sign * (difference - isLastISOWeekYearNotFull);
        return 0 === result ? 0 : result;
      }
      function differenceInMinutes(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 6e4;
        return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
      }
      function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          sign = compareAsc(dateLeft, dateRight),
          difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
        dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
        var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign,
          result = sign * (difference - isLastMonthNotFull);
        return 0 === result ? 0 : result;
      }
      function differenceInQuarters(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var diff = differenceInMonths(dirtyDateLeft, dirtyDateRight) / 3;
        return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
      }
      function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1e3;
        return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
      }
      function differenceInWeeks(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var diff = differenceInDays(dirtyDateLeft, dirtyDateRight) / 7;
        return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
      }
      function differenceInYears(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight),
          sign = compareAsc(dateLeft, dateRight),
          difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
        dateLeft.setFullYear('1584'), dateRight.setFullYear('1584');
        var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign,
          result = sign * (difference - isLastYearNotFull);
        return 0 === result ? 0 : result;
      }
      function eachDayOfInterval(dirtyInterval, options) {
        requiredArgs(1, arguments);
        var interval = dirtyInterval || {},
          startDate = toDate(interval.start),
          endDate = toDate(interval.end),
          endTime = endDate.getTime();
        if (!(startDate.getTime() <= endTime)) throw new RangeError('Invalid interval');
        var dates = [],
          currentDate = startDate;
        currentDate.setHours(0, 0, 0, 0);
        var step = options && 'step' in options ? Number(options.step) : 1;
        if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');
        for (; currentDate.getTime() <= endTime; )
          dates.push(toDate(currentDate)),
            currentDate.setDate(currentDate.getDate() + step),
            currentDate.setHours(0, 0, 0, 0);
        return dates;
      }
      function eachHourOfInterval(dirtyInterval, options) {
        requiredArgs(1, arguments);
        var interval = dirtyInterval || {},
          startDate = toDate(interval.start),
          endDate = toDate(interval.end),
          startTime = startDate.getTime(),
          endTime = endDate.getTime();
        if (!(startTime <= endTime)) throw new RangeError('Invalid interval');
        var dates = [],
          currentDate = startDate;
        currentDate.setMinutes(0, 0, 0);
        var step = options && 'step' in options ? Number(options.step) : 1;
        if (step < 1 || isNaN(step)) throw new RangeError('`options.step` must be a number greater than 1');
        for (; currentDate.getTime() <= endTime; )
          dates.push(toDate(currentDate)), (currentDate = addHours(currentDate, step));
        return dates;
      }
      function eachMonthOfInterval(dirtyInterval) {
        requiredArgs(1, arguments);
        var interval = dirtyInterval || {},
          startDate = toDate(interval.start),
          endDate = toDate(interval.end),
          endTime = endDate.getTime();
        if (!(startDate.getTime() <= endTime)) throw new RangeError('Invalid interval');
        var dates = [],
          currentDate = startDate;
        for (currentDate.setHours(0, 0, 0, 0), currentDate.setDate(1); currentDate.getTime() <= endTime; )
          dates.push(toDate(currentDate)), currentDate.setMonth(currentDate.getMonth() + 1);
        return dates;
      }
      function startOfQuarter(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          currentMonth = date.getMonth(),
          month = currentMonth - (currentMonth % 3);
        return date.setMonth(month, 1), date.setHours(0, 0, 0, 0), date;
      }
      function eachQuarterOfInterval(dirtyInterval) {
        requiredArgs(1, arguments);
        var interval = dirtyInterval || {},
          startDate = toDate(interval.start),
          endDate = toDate(interval.end),
          endTime = endDate.getTime();
        if (!(startDate.getTime() <= endTime)) throw new RangeError('Invalid interval');
        var startDateQuarter = startOfQuarter(startDate),
          endDateQuarter = startOfQuarter(endDate);
        endTime = endDateQuarter.getTime();
        for (var quarters = [], currentQuarter = startDateQuarter; currentQuarter.getTime() <= endTime; )
          quarters.push(toDate(currentQuarter)), (currentQuarter = addQuarters(currentQuarter, 1));
        return quarters;
      }
      function eachWeekOfInterval(dirtyInterval, options) {
        requiredArgs(1, arguments);
        var interval = dirtyInterval || {},
          startDate = toDate(interval.start),
          endDate = toDate(interval.end),
          endTime = endDate.getTime();
        if (!(startDate.getTime() <= endTime)) throw new RangeError('Invalid interval');
        var startDateWeek = startOfWeek(startDate, options),
          endDateWeek = startOfWeek(endDate, options);
        startDateWeek.setHours(15), endDateWeek.setHours(15), (endTime = endDateWeek.getTime());
        for (var weeks = [], currentWeek = startDateWeek; currentWeek.getTime() <= endTime; )
          currentWeek.setHours(0),
            weeks.push(toDate(currentWeek)),
            (currentWeek = addWeeks(currentWeek, 1)).setHours(15);
        return weeks;
      }
      function eachWeekendOfInterval(interval) {
        requiredArgs(1, arguments);
        for (var dateInterval = eachDayOfInterval(interval), weekends = [], index = 0; index < dateInterval.length; ) {
          var date = dateInterval[index++];
          isWeekend(date) && (weekends.push(date), isSunday(date) && (index += 5));
        }
        return weekends;
      }
      function startOfMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setDate(1), date.setHours(0, 0, 0, 0), date;
      }
      function endOfMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          month = date.getMonth();
        return date.setFullYear(date.getFullYear(), month + 1, 0), date.setHours(23, 59, 59, 999), date;
      }
      function eachWeekendOfMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var startDate = startOfMonth(dirtyDate);
        if (isNaN(startDate)) throw new RangeError('The passed date is invalid');
        var endDate = endOfMonth(dirtyDate);
        return eachWeekendOfInterval({ start: startDate, end: endDate });
      }
      function startOfYear(dirtyDate) {
        requiredArgs(1, arguments);
        var cleanDate = toDate(dirtyDate),
          date = new Date(0);
        return date.setFullYear(cleanDate.getFullYear(), 0, 1), date.setHours(0, 0, 0, 0), date;
      }
      function endOfYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear();
        return date.setFullYear(year + 1, 0, 0), date.setHours(23, 59, 59, 999), date;
      }
      function eachWeekendOfYear(dirtyDate) {
        requiredArgs(1, arguments);
        var startDate = startOfYear(dirtyDate);
        if (isNaN(startDate)) throw new RangeError('The passed date is invalid');
        var endDate = endOfYear(dirtyDate);
        return eachWeekendOfInterval({ start: startDate, end: endDate });
      }
      function eachYearOfInterval(dirtyInterval) {
        requiredArgs(1, arguments);
        var interval = dirtyInterval || {},
          startDate = toDate(interval.start),
          endDate = toDate(interval.end),
          endTime = endDate.getTime();
        if (!(startDate.getTime() <= endTime)) throw new RangeError('Invalid interval');
        var dates = [],
          currentDate = startDate;
        for (currentDate.setHours(0, 0, 0, 0), currentDate.setMonth(0, 1); currentDate.getTime() <= endTime; )
          dates.push(toDate(currentDate)), currentDate.setFullYear(currentDate.getFullYear() + 1);
        return dates;
      }
      function endOfDay(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setHours(23, 59, 59, 999), date;
      }
      function endOfDecade(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear(),
          decade = 9 + 10 * Math.floor(year / 10);
        return date.setFullYear(decade, 11, 31), date.setHours(23, 59, 59, 999), date;
      }
      function endOfHour(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setMinutes(59, 59, 999), date;
      }
      function endOfWeek(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        var date = toDate(dirtyDate),
          day = date.getDay(),
          diff = 6 + (day < weekStartsOn ? -7 : 0) - (day - weekStartsOn);
        return date.setDate(date.getDate() + diff), date.setHours(23, 59, 59, 999), date;
      }
      function endOfISOWeek(dirtyDate) {
        return requiredArgs(1, arguments), endOfWeek(dirtyDate, { weekStartsOn: 1 });
      }
      function endOfISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var year = getISOWeekYear(dirtyDate),
          fourthOfJanuaryOfNextYear = new Date(0);
        fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4), fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
        var date = startOfISOWeek(fourthOfJanuaryOfNextYear);
        return date.setMilliseconds(date.getMilliseconds() - 1), date;
      }
      function endOfMinute(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setSeconds(59, 999), date;
      }
      function endOfQuarter(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          currentMonth = date.getMonth(),
          month = currentMonth - (currentMonth % 3) + 3;
        return date.setMonth(month, 0), date.setHours(23, 59, 59, 999), date;
      }
      function endOfSecond(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setMilliseconds(999), date;
      }
      function endOfToday() {
        return endOfDay(Date.now());
      }
      function endOfTomorrow() {
        var now = new Date(),
          year = now.getFullYear(),
          month = now.getMonth(),
          day = now.getDate(),
          date = new Date(0);
        return date.setFullYear(year, month, day + 1), date.setHours(23, 59, 59, 999), date;
      }
      function endOfYesterday() {
        var now = new Date(),
          year = now.getFullYear(),
          month = now.getMonth(),
          day = now.getDate(),
          date = new Date(0);
        return date.setFullYear(year, month, day - 1), date.setHours(23, 59, 59, 999), date;
      }
      var formatDistanceLocale = {
        lessThanXSeconds: { one: 'less than a second', other: 'less than {{count}} seconds' },
        xSeconds: { one: '1 second', other: '{{count}} seconds' },
        halfAMinute: 'half a minute',
        lessThanXMinutes: { one: 'less than a minute', other: 'less than {{count}} minutes' },
        xMinutes: { one: '1 minute', other: '{{count}} minutes' },
        aboutXHours: { one: 'about 1 hour', other: 'about {{count}} hours' },
        xHours: { one: '1 hour', other: '{{count}} hours' },
        xDays: { one: '1 day', other: '{{count}} days' },
        aboutXWeeks: { one: 'about 1 week', other: 'about {{count}} weeks' },
        xWeeks: { one: '1 week', other: '{{count}} weeks' },
        aboutXMonths: { one: 'about 1 month', other: 'about {{count}} months' },
        xMonths: { one: '1 month', other: '{{count}} months' },
        aboutXYears: { one: 'about 1 year', other: 'about {{count}} years' },
        xYears: { one: '1 year', other: '{{count}} years' },
        overXYears: { one: 'over 1 year', other: 'over {{count}} years' },
        almostXYears: { one: 'almost 1 year', other: 'almost {{count}} years' },
      };
      function buildFormatLongFn(args) {
        return function (dirtyOptions) {
          var options = dirtyOptions || {},
            width = options.width ? String(options.width) : args.defaultWidth;
          return args.formats[width] || args.formats[args.defaultWidth];
        };
      }
      var formatLong = {
          date: buildFormatLongFn({
            formats: { full: 'EEEE, MMMM do, y', long: 'MMMM do, y', medium: 'MMM d, y', short: 'MM/dd/yyyy' },
            defaultWidth: 'full',
          }),
          time: buildFormatLongFn({
            formats: { full: 'h:mm:ss a zzzz', long: 'h:mm:ss a z', medium: 'h:mm:ss a', short: 'h:mm a' },
            defaultWidth: 'full',
          }),
          dateTime: buildFormatLongFn({
            formats: {
              full: "{{date}} 'at' {{time}}",
              long: "{{date}} 'at' {{time}}",
              medium: '{{date}}, {{time}}',
              short: '{{date}}, {{time}}',
            },
            defaultWidth: 'full',
          }),
        },
        formatRelativeLocale = {
          lastWeek: "'last' eeee 'at' p",
          yesterday: "'yesterday at' p",
          today: "'today at' p",
          tomorrow: "'tomorrow at' p",
          nextWeek: "eeee 'at' p",
          other: 'P',
        };
      function buildLocalizeFn(args) {
        return function (dirtyIndex, dirtyOptions) {
          var valuesArray,
            options = dirtyOptions || {};
          if ('formatting' === (options.context ? String(options.context) : 'standalone') && args.formattingValues) {
            var defaultWidth = args.defaultFormattingWidth || args.defaultWidth,
              width = options.width ? String(options.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
          } else {
            var _defaultWidth = args.defaultWidth,
              _width = options.width ? String(options.width) : args.defaultWidth;
            valuesArray = args.values[_width] || args.values[_defaultWidth];
          }
          return valuesArray[args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex];
        };
      }
      function buildMatchFn(args) {
        return function (dirtyString, dirtyOptions) {
          var string = String(dirtyString),
            options = dirtyOptions || {},
            width = options.width,
            matchPattern = (width && args.matchPatterns[width]) || args.matchPatterns[args.defaultMatchWidth],
            matchResult = string.match(matchPattern);
          if (!matchResult) return null;
          var value,
            matchedString = matchResult[0],
            parsePatterns = (width && args.parsePatterns[width]) || args.parsePatterns[args.defaultParseWidth];
          return (
            (value =
              '[object Array]' === Object.prototype.toString.call(parsePatterns)
                ? (function findIndex(array, predicate) {
                    for (var key = 0; key < array.length; key++) if (predicate(array[key])) return key;
                  })(parsePatterns, function (pattern) {
                    return pattern.test(matchedString);
                  })
                : (function findKey(object, predicate) {
                    for (var key in object) if (object.hasOwnProperty(key) && predicate(object[key])) return key;
                  })(parsePatterns, function (pattern) {
                    return pattern.test(matchedString);
                  })),
            (value = args.valueCallback ? args.valueCallback(value) : value),
            {
              value: (value = options.valueCallback ? options.valueCallback(value) : value),
              rest: string.slice(matchedString.length),
            }
          );
        };
      }
      var en_US = {
        code: 'en-US',
        formatDistance: function formatDistance(token, count, options) {
          var result;
          return (
            (options = options || {}),
            (result =
              'string' == typeof formatDistanceLocale[token]
                ? formatDistanceLocale[token]
                : 1 === count
                ? formatDistanceLocale[token].one
                : formatDistanceLocale[token].other.replace('{{count}}', count)),
            options.addSuffix ? (options.comparison > 0 ? 'in ' + result : result + ' ago') : result
          );
        },
        formatLong,
        formatRelative: function formatRelative(token, _date, _baseDate, _options) {
          return formatRelativeLocale[token];
        },
        localize: {
          ordinalNumber: function ordinalNumber(dirtyNumber, _dirtyOptions) {
            var number = Number(dirtyNumber),
              rem100 = number % 100;
            if (rem100 > 20 || rem100 < 10)
              switch (rem100 % 10) {
                case 1:
                  return number + 'st';
                case 2:
                  return number + 'nd';
                case 3:
                  return number + 'rd';
              }
            return number + 'th';
          },
          era: buildLocalizeFn({
            values: { narrow: ['B', 'A'], abbreviated: ['BC', 'AD'], wide: ['Before Christ', 'Anno Domini'] },
            defaultWidth: 'wide',
          }),
          quarter: buildLocalizeFn({
            values: {
              narrow: ['1', '2', '3', '4'],
              abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
              wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'],
            },
            defaultWidth: 'wide',
            argumentCallback: function (quarter) {
              return Number(quarter) - 1;
            },
          }),
          month: buildLocalizeFn({
            values: {
              narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
              abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
              wide: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December',
              ],
            },
            defaultWidth: 'wide',
          }),
          day: buildLocalizeFn({
            values: {
              narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
              short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
              abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
              wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            },
            defaultWidth: 'wide',
          }),
          dayPeriod: buildLocalizeFn({
            values: {
              narrow: {
                am: 'a',
                pm: 'p',
                midnight: 'mi',
                noon: 'n',
                morning: 'morning',
                afternoon: 'afternoon',
                evening: 'evening',
                night: 'night',
              },
              abbreviated: {
                am: 'AM',
                pm: 'PM',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'morning',
                afternoon: 'afternoon',
                evening: 'evening',
                night: 'night',
              },
              wide: {
                am: 'a.m.',
                pm: 'p.m.',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'morning',
                afternoon: 'afternoon',
                evening: 'evening',
                night: 'night',
              },
            },
            defaultWidth: 'wide',
            formattingValues: {
              narrow: {
                am: 'a',
                pm: 'p',
                midnight: 'mi',
                noon: 'n',
                morning: 'in the morning',
                afternoon: 'in the afternoon',
                evening: 'in the evening',
                night: 'at night',
              },
              abbreviated: {
                am: 'AM',
                pm: 'PM',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'in the morning',
                afternoon: 'in the afternoon',
                evening: 'in the evening',
                night: 'at night',
              },
              wide: {
                am: 'a.m.',
                pm: 'p.m.',
                midnight: 'midnight',
                noon: 'noon',
                morning: 'in the morning',
                afternoon: 'in the afternoon',
                evening: 'in the evening',
                night: 'at night',
              },
            },
            defaultFormattingWidth: 'wide',
          }),
        },
        match: {
          ordinalNumber: (function buildMatchPatternFn(args) {
            return function (dirtyString, dirtyOptions) {
              var string = String(dirtyString),
                options = dirtyOptions || {},
                matchResult = string.match(args.matchPattern);
              if (!matchResult) return null;
              var matchedString = matchResult[0],
                parseResult = string.match(args.parsePattern);
              if (!parseResult) return null;
              var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
              return {
                value: (value = options.valueCallback ? options.valueCallback(value) : value),
                rest: string.slice(matchedString.length),
              };
            };
          })({
            matchPattern: /^(\d+)(th|st|nd|rd)?/i,
            parsePattern: /\d+/i,
            valueCallback: function (value) {
              return parseInt(value, 10);
            },
          }),
          era: buildMatchFn({
            matchPatterns: {
              narrow: /^(b|a)/i,
              abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
              wide: /^(before christ|before common era|anno domini|common era)/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: { any: [/^b/i, /^(a|c)/i] },
            defaultParseWidth: 'any',
          }),
          quarter: buildMatchFn({
            matchPatterns: { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i },
            defaultMatchWidth: 'wide',
            parsePatterns: { any: [/1/i, /2/i, /3/i, /4/i] },
            defaultParseWidth: 'any',
            valueCallback: function (index) {
              return index + 1;
            },
          }),
          month: buildMatchFn({
            matchPatterns: {
              narrow: /^[jfmasond]/i,
              abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
              wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: {
              narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
              any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i],
            },
            defaultParseWidth: 'any',
          }),
          day: buildMatchFn({
            matchPatterns: {
              narrow: /^[smtwf]/i,
              short: /^(su|mo|tu|we|th|fr|sa)/i,
              abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
              wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
            },
            defaultMatchWidth: 'wide',
            parsePatterns: {
              narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
              any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
            },
            defaultParseWidth: 'any',
          }),
          dayPeriod: buildMatchFn({
            matchPatterns: {
              narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
              any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
            },
            defaultMatchWidth: 'any',
            parsePatterns: {
              any: {
                am: /^a/i,
                pm: /^p/i,
                midnight: /^mi/i,
                noon: /^no/i,
                morning: /morning/i,
                afternoon: /afternoon/i,
                evening: /evening/i,
                night: /night/i,
              },
            },
            defaultParseWidth: 'any',
          }),
        },
        options: { weekStartsOn: 0, firstWeekContainsDate: 1 },
      };
      function subMilliseconds(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMilliseconds(dirtyDate, -amount);
      }
      function addLeadingZeros(number, targetLength) {
        for (var sign = number < 0 ? '-' : '', output = Math.abs(number).toString(); output.length < targetLength; )
          output = '0' + output;
        return sign + output;
      }
      var lightFormatters = {
        y: function (date, token) {
          var signedYear = date.getUTCFullYear(),
            year = signedYear > 0 ? signedYear : 1 - signedYear;
          return addLeadingZeros('yy' === token ? year % 100 : year, token.length);
        },
        M: function (date, token) {
          var month = date.getUTCMonth();
          return 'M' === token ? String(month + 1) : addLeadingZeros(month + 1, 2);
        },
        d: function (date, token) {
          return addLeadingZeros(date.getUTCDate(), token.length);
        },
        a: function (date, token) {
          var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
          switch (token) {
            case 'a':
            case 'aa':
            case 'aaa':
              return dayPeriodEnumValue.toUpperCase();
            case 'aaaaa':
              return dayPeriodEnumValue[0];
            case 'aaaa':
            default:
              return 'am' === dayPeriodEnumValue ? 'a.m.' : 'p.m.';
          }
        },
        h: function (date, token) {
          return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
        },
        H: function (date, token) {
          return addLeadingZeros(date.getUTCHours(), token.length);
        },
        m: function (date, token) {
          return addLeadingZeros(date.getUTCMinutes(), token.length);
        },
        s: function (date, token) {
          return addLeadingZeros(date.getUTCSeconds(), token.length);
        },
        S: function (date, token) {
          var numberOfDigits = token.length,
            milliseconds = date.getUTCMilliseconds();
          return addLeadingZeros(Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3)), token.length);
        },
      };
      function startOfUTCISOWeek(dirtyDate) {
        requiredArgs(1, arguments);
        var weekStartsOn = 1,
          date = toDate(dirtyDate),
          day = date.getUTCDay(),
          diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
        return date.setUTCDate(date.getUTCDate() - diff), date.setUTCHours(0, 0, 0, 0), date;
      }
      function getUTCISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getUTCFullYear(),
          fourthOfJanuaryOfNextYear = new Date(0);
        fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4), fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
        var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear),
          fourthOfJanuaryOfThisYear = new Date(0);
        fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4), fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
        var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
        return date.getTime() >= startOfNextYear.getTime()
          ? year + 1
          : date.getTime() >= startOfThisYear.getTime()
          ? year
          : year - 1;
      }
      function startOfUTCISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var year = getUTCISOWeekYear(dirtyDate),
          fourthOfJanuary = new Date(0);
        fourthOfJanuary.setUTCFullYear(year, 0, 4), fourthOfJanuary.setUTCHours(0, 0, 0, 0);
        var date = startOfUTCISOWeek(fourthOfJanuary);
        return date;
      }
      function getUTCISOWeek(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
        return Math.round(diff / 6048e5) + 1;
      }
      function startOfUTCWeek(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        var date = toDate(dirtyDate),
          day = date.getUTCDay(),
          diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
        return date.setUTCDate(date.getUTCDate() - diff), date.setUTCHours(0, 0, 0, 0), date;
      }
      function getUTCWeekYear(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate, dirtyOptions),
          year = date.getUTCFullYear(),
          options = dirtyOptions || {},
          locale = options.locale,
          localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate,
          defaultFirstWeekContainsDate =
            null == localeFirstWeekContainsDate ? 1 : toInteger(localeFirstWeekContainsDate),
          firstWeekContainsDate =
            null == options.firstWeekContainsDate
              ? defaultFirstWeekContainsDate
              : toInteger(options.firstWeekContainsDate);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
          throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
        var firstWeekOfNextYear = new Date(0);
        firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate),
          firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
        var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions),
          firstWeekOfThisYear = new Date(0);
        firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate), firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
        var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
        return date.getTime() >= startOfNextYear.getTime()
          ? year + 1
          : date.getTime() >= startOfThisYear.getTime()
          ? year
          : year - 1;
      }
      function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate,
          defaultFirstWeekContainsDate =
            null == localeFirstWeekContainsDate ? 1 : toInteger(localeFirstWeekContainsDate),
          firstWeekContainsDate =
            null == options.firstWeekContainsDate
              ? defaultFirstWeekContainsDate
              : toInteger(options.firstWeekContainsDate),
          year = getUTCWeekYear(dirtyDate, dirtyOptions),
          firstWeek = new Date(0);
        firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate), firstWeek.setUTCHours(0, 0, 0, 0);
        var date = startOfUTCWeek(firstWeek, dirtyOptions);
        return date;
      }
      function getUTCWeek(dirtyDate, options) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
        return Math.round(diff / 6048e5) + 1;
      }
      var dayPeriodEnum_midnight = 'midnight',
        dayPeriodEnum_noon = 'noon',
        dayPeriodEnum_morning = 'morning',
        dayPeriodEnum_afternoon = 'afternoon',
        dayPeriodEnum_evening = 'evening',
        dayPeriodEnum_night = 'night';
      function formatTimezoneShort(offset, dirtyDelimiter) {
        var sign = offset > 0 ? '-' : '+',
          absOffset = Math.abs(offset),
          hours = Math.floor(absOffset / 60),
          minutes = absOffset % 60;
        if (0 === minutes) return sign + String(hours);
        var delimiter = dirtyDelimiter || '';
        return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
      }
      function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
        return offset % 60 == 0
          ? (offset > 0 ? '-' : '+') + addLeadingZeros(Math.abs(offset) / 60, 2)
          : formatTimezone(offset, dirtyDelimiter);
      }
      function formatTimezone(offset, dirtyDelimiter) {
        var delimiter = dirtyDelimiter || '',
          sign = offset > 0 ? '-' : '+',
          absOffset = Math.abs(offset);
        return sign + addLeadingZeros(Math.floor(absOffset / 60), 2) + delimiter + addLeadingZeros(absOffset % 60, 2);
      }
      var format_formatters = {
        G: function (date, token, localize) {
          var era = date.getUTCFullYear() > 0 ? 1 : 0;
          switch (token) {
            case 'G':
            case 'GG':
            case 'GGG':
              return localize.era(era, { width: 'abbreviated' });
            case 'GGGGG':
              return localize.era(era, { width: 'narrow' });
            case 'GGGG':
            default:
              return localize.era(era, { width: 'wide' });
          }
        },
        y: function (date, token, localize) {
          if ('yo' === token) {
            var signedYear = date.getUTCFullYear(),
              year = signedYear > 0 ? signedYear : 1 - signedYear;
            return localize.ordinalNumber(year, { unit: 'year' });
          }
          return lightFormatters.y(date, token);
        },
        Y: function (date, token, localize, options) {
          var signedWeekYear = getUTCWeekYear(date, options),
            weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
          return 'YY' === token
            ? addLeadingZeros(weekYear % 100, 2)
            : 'Yo' === token
            ? localize.ordinalNumber(weekYear, { unit: 'year' })
            : addLeadingZeros(weekYear, token.length);
        },
        R: function (date, token) {
          return addLeadingZeros(getUTCISOWeekYear(date), token.length);
        },
        u: function (date, token) {
          return addLeadingZeros(date.getUTCFullYear(), token.length);
        },
        Q: function (date, token, localize) {
          var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
          switch (token) {
            case 'Q':
              return String(quarter);
            case 'QQ':
              return addLeadingZeros(quarter, 2);
            case 'Qo':
              return localize.ordinalNumber(quarter, { unit: 'quarter' });
            case 'QQQ':
              return localize.quarter(quarter, { width: 'abbreviated', context: 'formatting' });
            case 'QQQQQ':
              return localize.quarter(quarter, { width: 'narrow', context: 'formatting' });
            case 'QQQQ':
            default:
              return localize.quarter(quarter, { width: 'wide', context: 'formatting' });
          }
        },
        q: function (date, token, localize) {
          var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
          switch (token) {
            case 'q':
              return String(quarter);
            case 'qq':
              return addLeadingZeros(quarter, 2);
            case 'qo':
              return localize.ordinalNumber(quarter, { unit: 'quarter' });
            case 'qqq':
              return localize.quarter(quarter, { width: 'abbreviated', context: 'standalone' });
            case 'qqqqq':
              return localize.quarter(quarter, { width: 'narrow', context: 'standalone' });
            case 'qqqq':
            default:
              return localize.quarter(quarter, { width: 'wide', context: 'standalone' });
          }
        },
        M: function (date, token, localize) {
          var month = date.getUTCMonth();
          switch (token) {
            case 'M':
            case 'MM':
              return lightFormatters.M(date, token);
            case 'Mo':
              return localize.ordinalNumber(month + 1, { unit: 'month' });
            case 'MMM':
              return localize.month(month, { width: 'abbreviated', context: 'formatting' });
            case 'MMMMM':
              return localize.month(month, { width: 'narrow', context: 'formatting' });
            case 'MMMM':
            default:
              return localize.month(month, { width: 'wide', context: 'formatting' });
          }
        },
        L: function (date, token, localize) {
          var month = date.getUTCMonth();
          switch (token) {
            case 'L':
              return String(month + 1);
            case 'LL':
              return addLeadingZeros(month + 1, 2);
            case 'Lo':
              return localize.ordinalNumber(month + 1, { unit: 'month' });
            case 'LLL':
              return localize.month(month, { width: 'abbreviated', context: 'standalone' });
            case 'LLLLL':
              return localize.month(month, { width: 'narrow', context: 'standalone' });
            case 'LLLL':
            default:
              return localize.month(month, { width: 'wide', context: 'standalone' });
          }
        },
        w: function (date, token, localize, options) {
          var week = getUTCWeek(date, options);
          return 'wo' === token ? localize.ordinalNumber(week, { unit: 'week' }) : addLeadingZeros(week, token.length);
        },
        I: function (date, token, localize) {
          var isoWeek = getUTCISOWeek(date);
          return 'Io' === token
            ? localize.ordinalNumber(isoWeek, { unit: 'week' })
            : addLeadingZeros(isoWeek, token.length);
        },
        d: function (date, token, localize) {
          return 'do' === token
            ? localize.ordinalNumber(date.getUTCDate(), { unit: 'date' })
            : lightFormatters.d(date, token);
        },
        D: function (date, token, localize) {
          var dayOfYear = (function getUTCDayOfYear(dirtyDate) {
            requiredArgs(1, arguments);
            var date = toDate(dirtyDate),
              timestamp = date.getTime();
            date.setUTCMonth(0, 1), date.setUTCHours(0, 0, 0, 0);
            var startOfYearTimestamp = date.getTime(),
              difference = timestamp - startOfYearTimestamp;
            return Math.floor(difference / 864e5) + 1;
          })(date);
          return 'Do' === token
            ? localize.ordinalNumber(dayOfYear, { unit: 'dayOfYear' })
            : addLeadingZeros(dayOfYear, token.length);
        },
        E: function (date, token, localize) {
          var dayOfWeek = date.getUTCDay();
          switch (token) {
            case 'E':
            case 'EE':
            case 'EEE':
              return localize.day(dayOfWeek, { width: 'abbreviated', context: 'formatting' });
            case 'EEEEE':
              return localize.day(dayOfWeek, { width: 'narrow', context: 'formatting' });
            case 'EEEEEE':
              return localize.day(dayOfWeek, { width: 'short', context: 'formatting' });
            case 'EEEE':
            default:
              return localize.day(dayOfWeek, { width: 'wide', context: 'formatting' });
          }
        },
        e: function (date, token, localize, options) {
          var dayOfWeek = date.getUTCDay(),
            localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
          switch (token) {
            case 'e':
              return String(localDayOfWeek);
            case 'ee':
              return addLeadingZeros(localDayOfWeek, 2);
            case 'eo':
              return localize.ordinalNumber(localDayOfWeek, { unit: 'day' });
            case 'eee':
              return localize.day(dayOfWeek, { width: 'abbreviated', context: 'formatting' });
            case 'eeeee':
              return localize.day(dayOfWeek, { width: 'narrow', context: 'formatting' });
            case 'eeeeee':
              return localize.day(dayOfWeek, { width: 'short', context: 'formatting' });
            case 'eeee':
            default:
              return localize.day(dayOfWeek, { width: 'wide', context: 'formatting' });
          }
        },
        c: function (date, token, localize, options) {
          var dayOfWeek = date.getUTCDay(),
            localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
          switch (token) {
            case 'c':
              return String(localDayOfWeek);
            case 'cc':
              return addLeadingZeros(localDayOfWeek, token.length);
            case 'co':
              return localize.ordinalNumber(localDayOfWeek, { unit: 'day' });
            case 'ccc':
              return localize.day(dayOfWeek, { width: 'abbreviated', context: 'standalone' });
            case 'ccccc':
              return localize.day(dayOfWeek, { width: 'narrow', context: 'standalone' });
            case 'cccccc':
              return localize.day(dayOfWeek, { width: 'short', context: 'standalone' });
            case 'cccc':
            default:
              return localize.day(dayOfWeek, { width: 'wide', context: 'standalone' });
          }
        },
        i: function (date, token, localize) {
          var dayOfWeek = date.getUTCDay(),
            isoDayOfWeek = 0 === dayOfWeek ? 7 : dayOfWeek;
          switch (token) {
            case 'i':
              return String(isoDayOfWeek);
            case 'ii':
              return addLeadingZeros(isoDayOfWeek, token.length);
            case 'io':
              return localize.ordinalNumber(isoDayOfWeek, { unit: 'day' });
            case 'iii':
              return localize.day(dayOfWeek, { width: 'abbreviated', context: 'formatting' });
            case 'iiiii':
              return localize.day(dayOfWeek, { width: 'narrow', context: 'formatting' });
            case 'iiiiii':
              return localize.day(dayOfWeek, { width: 'short', context: 'formatting' });
            case 'iiii':
            default:
              return localize.day(dayOfWeek, { width: 'wide', context: 'formatting' });
          }
        },
        a: function (date, token, localize) {
          var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
          switch (token) {
            case 'a':
            case 'aa':
            case 'aaa':
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'abbreviated', context: 'formatting' });
            case 'aaaaa':
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'narrow', context: 'formatting' });
            case 'aaaa':
            default:
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'wide', context: 'formatting' });
          }
        },
        b: function (date, token, localize) {
          var dayPeriodEnumValue,
            hours = date.getUTCHours();
          switch (
            ((dayPeriodEnumValue =
              12 === hours ? dayPeriodEnum_noon : 0 === hours ? dayPeriodEnum_midnight : hours / 12 >= 1 ? 'pm' : 'am'),
            token)
          ) {
            case 'b':
            case 'bb':
            case 'bbb':
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'abbreviated', context: 'formatting' });
            case 'bbbbb':
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'narrow', context: 'formatting' });
            case 'bbbb':
            default:
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'wide', context: 'formatting' });
          }
        },
        B: function (date, token, localize) {
          var dayPeriodEnumValue,
            hours = date.getUTCHours();
          switch (
            ((dayPeriodEnumValue =
              hours >= 17
                ? dayPeriodEnum_evening
                : hours >= 12
                ? dayPeriodEnum_afternoon
                : hours >= 4
                ? dayPeriodEnum_morning
                : dayPeriodEnum_night),
            token)
          ) {
            case 'B':
            case 'BB':
            case 'BBB':
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'abbreviated', context: 'formatting' });
            case 'BBBBB':
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'narrow', context: 'formatting' });
            case 'BBBB':
            default:
              return localize.dayPeriod(dayPeriodEnumValue, { width: 'wide', context: 'formatting' });
          }
        },
        h: function (date, token, localize) {
          if ('ho' === token) {
            var hours = date.getUTCHours() % 12;
            return 0 === hours && (hours = 12), localize.ordinalNumber(hours, { unit: 'hour' });
          }
          return lightFormatters.h(date, token);
        },
        H: function (date, token, localize) {
          return 'Ho' === token
            ? localize.ordinalNumber(date.getUTCHours(), { unit: 'hour' })
            : lightFormatters.H(date, token);
        },
        K: function (date, token, localize) {
          var hours = date.getUTCHours() % 12;
          return 'Ko' === token
            ? localize.ordinalNumber(hours, { unit: 'hour' })
            : addLeadingZeros(hours, token.length);
        },
        k: function (date, token, localize) {
          var hours = date.getUTCHours();
          return (
            0 === hours && (hours = 24),
            'ko' === token ? localize.ordinalNumber(hours, { unit: 'hour' }) : addLeadingZeros(hours, token.length)
          );
        },
        m: function (date, token, localize) {
          return 'mo' === token
            ? localize.ordinalNumber(date.getUTCMinutes(), { unit: 'minute' })
            : lightFormatters.m(date, token);
        },
        s: function (date, token, localize) {
          return 'so' === token
            ? localize.ordinalNumber(date.getUTCSeconds(), { unit: 'second' })
            : lightFormatters.s(date, token);
        },
        S: function (date, token) {
          return lightFormatters.S(date, token);
        },
        X: function (date, token, _localize, options) {
          var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
          if (0 === timezoneOffset) return 'Z';
          switch (token) {
            case 'X':
              return formatTimezoneWithOptionalMinutes(timezoneOffset);
            case 'XXXX':
            case 'XX':
              return formatTimezone(timezoneOffset);
            case 'XXXXX':
            case 'XXX':
            default:
              return formatTimezone(timezoneOffset, ':');
          }
        },
        x: function (date, token, _localize, options) {
          var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
          switch (token) {
            case 'x':
              return formatTimezoneWithOptionalMinutes(timezoneOffset);
            case 'xxxx':
            case 'xx':
              return formatTimezone(timezoneOffset);
            case 'xxxxx':
            case 'xxx':
            default:
              return formatTimezone(timezoneOffset, ':');
          }
        },
        O: function (date, token, _localize, options) {
          var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
          switch (token) {
            case 'O':
            case 'OO':
            case 'OOO':
              return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
            case 'OOOO':
            default:
              return 'GMT' + formatTimezone(timezoneOffset, ':');
          }
        },
        z: function (date, token, _localize, options) {
          var timezoneOffset = (options._originalDate || date).getTimezoneOffset();
          switch (token) {
            case 'z':
            case 'zz':
            case 'zzz':
              return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
            case 'zzzz':
            default:
              return 'GMT' + formatTimezone(timezoneOffset, ':');
          }
        },
        t: function (date, token, _localize, options) {
          var originalDate = options._originalDate || date;
          return addLeadingZeros(Math.floor(originalDate.getTime() / 1e3), token.length);
        },
        T: function (date, token, _localize, options) {
          return addLeadingZeros((options._originalDate || date).getTime(), token.length);
        },
      };
      function dateLongFormatter(pattern, formatLong) {
        switch (pattern) {
          case 'P':
            return formatLong.date({ width: 'short' });
          case 'PP':
            return formatLong.date({ width: 'medium' });
          case 'PPP':
            return formatLong.date({ width: 'long' });
          case 'PPPP':
          default:
            return formatLong.date({ width: 'full' });
        }
      }
      function timeLongFormatter(pattern, formatLong) {
        switch (pattern) {
          case 'p':
            return formatLong.time({ width: 'short' });
          case 'pp':
            return formatLong.time({ width: 'medium' });
          case 'ppp':
            return formatLong.time({ width: 'long' });
          case 'pppp':
          default:
            return formatLong.time({ width: 'full' });
        }
      }
      var format_longFormatters = {
          p: timeLongFormatter,
          P: function dateTimeLongFormatter(pattern, formatLong) {
            var dateTimeFormat,
              matchResult = pattern.match(/(P+)(p+)?/),
              datePattern = matchResult[1],
              timePattern = matchResult[2];
            if (!timePattern) return dateLongFormatter(pattern, formatLong);
            switch (datePattern) {
              case 'P':
                dateTimeFormat = formatLong.dateTime({ width: 'short' });
                break;
              case 'PP':
                dateTimeFormat = formatLong.dateTime({ width: 'medium' });
                break;
              case 'PPP':
                dateTimeFormat = formatLong.dateTime({ width: 'long' });
                break;
              case 'PPPP':
              default:
                dateTimeFormat = formatLong.dateTime({ width: 'full' });
            }
            return dateTimeFormat
              .replace('{{date}}', dateLongFormatter(datePattern, formatLong))
              .replace('{{time}}', timeLongFormatter(timePattern, formatLong));
          },
        },
        protectedDayOfYearTokens = ['D', 'DD'],
        protectedWeekYearTokens = ['YY', 'YYYY'];
      function isProtectedDayOfYearToken(token) {
        return -1 !== protectedDayOfYearTokens.indexOf(token);
      }
      function isProtectedWeekYearToken(token) {
        return -1 !== protectedWeekYearTokens.indexOf(token);
      }
      function throwProtectedError(token, format, input) {
        if ('YYYY' === token)
          throw new RangeError(
            'Use `yyyy` instead of `YYYY` (in `'
              .concat(format, '`) for formatting years to the input `')
              .concat(input, '`; see: https://git.io/fxCyr')
          );
        if ('YY' === token)
          throw new RangeError(
            'Use `yy` instead of `YY` (in `'
              .concat(format, '`) for formatting years to the input `')
              .concat(input, '`; see: https://git.io/fxCyr')
          );
        if ('D' === token)
          throw new RangeError(
            'Use `d` instead of `D` (in `'
              .concat(format, '`) for formatting days of the month to the input `')
              .concat(input, '`; see: https://git.io/fxCyr')
          );
        if ('DD' === token)
          throw new RangeError(
            'Use `dd` instead of `DD` (in `'
              .concat(format, '`) for formatting days of the month to the input `')
              .concat(input, '`; see: https://git.io/fxCyr')
          );
      }
      var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
        longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
        escapedStringRegExp = /^'([^]*?)'?$/,
        doubleQuoteRegExp = /''/g,
        unescapedLatinCharacterRegExp = /[a-zA-Z]/;
      function format_format(dirtyDate, dirtyFormatStr, dirtyOptions) {
        requiredArgs(2, arguments);
        var formatStr = String(dirtyFormatStr),
          options = dirtyOptions || {},
          locale = options.locale || en_US,
          localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate,
          defaultFirstWeekContainsDate =
            null == localeFirstWeekContainsDate ? 1 : toInteger(localeFirstWeekContainsDate),
          firstWeekContainsDate =
            null == options.firstWeekContainsDate
              ? defaultFirstWeekContainsDate
              : toInteger(options.firstWeekContainsDate);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
          throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
        var localeWeekStartsOn = locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        if (!locale.localize) throw new RangeError('locale must contain localize property');
        if (!locale.formatLong) throw new RangeError('locale must contain formatLong property');
        var originalDate = toDate(dirtyDate);
        if (!isValid(originalDate)) throw new RangeError('Invalid time value');
        var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate),
          utcDate = subMilliseconds(originalDate, timezoneOffset),
          formatterOptions = { firstWeekContainsDate, weekStartsOn, locale, _originalDate: originalDate },
          result = formatStr
            .match(longFormattingTokensRegExp)
            .map(function (substring) {
              var firstCharacter = substring[0];
              return 'p' === firstCharacter || 'P' === firstCharacter
                ? (0, format_longFormatters[firstCharacter])(substring, locale.formatLong, formatterOptions)
                : substring;
            })
            .join('')
            .match(formattingTokensRegExp)
            .map(function (substring) {
              if ("''" === substring) return "'";
              var firstCharacter = substring[0];
              if ("'" === firstCharacter) return cleanEscapedString(substring);
              var formatter = format_formatters[firstCharacter];
              if (formatter)
                return (
                  !options.useAdditionalWeekYearTokens &&
                    isProtectedWeekYearToken(substring) &&
                    throwProtectedError(substring, dirtyFormatStr, dirtyDate),
                  !options.useAdditionalDayOfYearTokens &&
                    isProtectedDayOfYearToken(substring) &&
                    throwProtectedError(substring, dirtyFormatStr, dirtyDate),
                  formatter(utcDate, substring, locale.localize, formatterOptions)
                );
              if (firstCharacter.match(unescapedLatinCharacterRegExp))
                throw new RangeError(
                  'Format string contains an unescaped latin alphabet character `' + firstCharacter + '`'
                );
              return substring;
            })
            .join('');
        return result;
      }
      function cleanEscapedString(input) {
        return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
      }
      function assign_assign(target, dirtyObject) {
        if (null == target) throw new TypeError('assign requires that input parameter not be null or undefined');
        for (var property in (dirtyObject = dirtyObject || {}))
          dirtyObject.hasOwnProperty(property) && (target[property] = dirtyObject[property]);
        return target;
      }
      function cloneObject(dirtyObject) {
        return assign_assign({}, dirtyObject);
      }
      function formatDistance_formatDistance(dirtyDate, dirtyBaseDate, dirtyOptions) {
        requiredArgs(2, arguments);
        var options = dirtyOptions || {},
          locale = options.locale || en_US;
        if (!locale.formatDistance) throw new RangeError('locale must contain formatDistance property');
        var comparison = compareAsc(dirtyDate, dirtyBaseDate);
        if (isNaN(comparison)) throw new RangeError('Invalid time value');
        var dateLeft,
          dateRight,
          localizeOptions = cloneObject(options);
        (localizeOptions.addSuffix = Boolean(options.addSuffix)),
          (localizeOptions.comparison = comparison),
          comparison > 0
            ? ((dateLeft = toDate(dirtyBaseDate)), (dateRight = toDate(dirtyDate)))
            : ((dateLeft = toDate(dirtyDate)), (dateRight = toDate(dirtyBaseDate)));
        var months,
          seconds = differenceInSeconds(dateRight, dateLeft),
          offsetInSeconds =
            (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3,
          minutes = Math.round((seconds - offsetInSeconds) / 60);
        if (minutes < 2)
          return options.includeSeconds
            ? seconds < 5
              ? locale.formatDistance('lessThanXSeconds', 5, localizeOptions)
              : seconds < 10
              ? locale.formatDistance('lessThanXSeconds', 10, localizeOptions)
              : seconds < 20
              ? locale.formatDistance('lessThanXSeconds', 20, localizeOptions)
              : seconds < 40
              ? locale.formatDistance('halfAMinute', null, localizeOptions)
              : seconds < 60
              ? locale.formatDistance('lessThanXMinutes', 1, localizeOptions)
              : locale.formatDistance('xMinutes', 1, localizeOptions)
            : 0 === minutes
            ? locale.formatDistance('lessThanXMinutes', 1, localizeOptions)
            : locale.formatDistance('xMinutes', minutes, localizeOptions);
        if (minutes < 45) return locale.formatDistance('xMinutes', minutes, localizeOptions);
        if (minutes < 90) return locale.formatDistance('aboutXHours', 1, localizeOptions);
        if (minutes < 1440) {
          var hours = Math.round(minutes / 60);
          return locale.formatDistance('aboutXHours', hours, localizeOptions);
        }
        if (minutes < 2520) return locale.formatDistance('xDays', 1, localizeOptions);
        if (minutes < 43200) {
          var days = Math.round(minutes / 1440);
          return locale.formatDistance('xDays', days, localizeOptions);
        }
        if (minutes < 86400)
          return (months = Math.round(minutes / 43200)), locale.formatDistance('aboutXMonths', months, localizeOptions);
        if ((months = differenceInMonths(dateRight, dateLeft)) < 12) {
          var nearestMonth = Math.round(minutes / 43200);
          return locale.formatDistance('xMonths', nearestMonth, localizeOptions);
        }
        var monthsSinceStartOfYear = months % 12,
          years = Math.floor(months / 12);
        return monthsSinceStartOfYear < 3
          ? locale.formatDistance('aboutXYears', years, localizeOptions)
          : monthsSinceStartOfYear < 9
          ? locale.formatDistance('overXYears', years, localizeOptions)
          : locale.formatDistance('almostXYears', years + 1, localizeOptions);
      }
      function formatDistanceStrict(dirtyDate, dirtyBaseDate, dirtyOptions) {
        requiredArgs(2, arguments);
        var options = dirtyOptions || {},
          locale = options.locale || en_US;
        if (!locale.formatDistance) throw new RangeError('locale must contain localize.formatDistance property');
        var comparison = compareAsc(dirtyDate, dirtyBaseDate);
        if (isNaN(comparison)) throw new RangeError('Invalid time value');
        var dateLeft,
          dateRight,
          localizeOptions = cloneObject(options);
        (localizeOptions.addSuffix = Boolean(options.addSuffix)),
          (localizeOptions.comparison = comparison),
          comparison > 0
            ? ((dateLeft = toDate(dirtyBaseDate)), (dateRight = toDate(dirtyDate)))
            : ((dateLeft = toDate(dirtyDate)), (dateRight = toDate(dirtyBaseDate)));
        var roundingMethodFn,
          roundingMethod = null == options.roundingMethod ? 'round' : String(options.roundingMethod);
        if ('floor' === roundingMethod) roundingMethodFn = Math.floor;
        else if ('ceil' === roundingMethod) roundingMethodFn = Math.ceil;
        else {
          if ('round' !== roundingMethod) throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
          roundingMethodFn = Math.round;
        }
        var unit,
          seconds = differenceInSeconds(dateRight, dateLeft),
          offsetInSeconds =
            (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3,
          minutes = roundingMethodFn((seconds - offsetInSeconds) / 60);
        if (
          'second' ===
          (unit =
            null == options.unit
              ? minutes < 1
                ? 'second'
                : minutes < 60
                ? 'minute'
                : minutes < 1440
                ? 'hour'
                : minutes < 43200
                ? 'day'
                : minutes < 525600
                ? 'month'
                : 'year'
              : String(options.unit))
        )
          return locale.formatDistance('xSeconds', seconds, localizeOptions);
        if ('minute' === unit) return locale.formatDistance('xMinutes', minutes, localizeOptions);
        if ('hour' === unit) {
          var hours = roundingMethodFn(minutes / 60);
          return locale.formatDistance('xHours', hours, localizeOptions);
        }
        if ('day' === unit) {
          var days = roundingMethodFn(minutes / 1440);
          return locale.formatDistance('xDays', days, localizeOptions);
        }
        if ('month' === unit) {
          var months = roundingMethodFn(minutes / 43200);
          return locale.formatDistance('xMonths', months, localizeOptions);
        }
        if ('year' === unit) {
          var years = roundingMethodFn(minutes / 525600);
          return locale.formatDistance('xYears', years, localizeOptions);
        }
        throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
      }
      function formatDistanceToNow(dirtyDate, dirtyOptions) {
        return requiredArgs(1, arguments), formatDistance_formatDistance(dirtyDate, Date.now(), dirtyOptions);
      }
      function formatDistanceToNowStrict(dirtyDate, dirtyOptions) {
        return requiredArgs(1, arguments), formatDistanceStrict(dirtyDate, Date.now(), dirtyOptions);
      }
      var defaultFormat = ['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds'];
      function formatDuration(duration) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (arguments.length < 1)
          throw new TypeError('1 argument required, but only '.concat(arguments.length, ' present'));
        var format = options.format || defaultFormat,
          locale = options.locale || en_US,
          zero = options.zero || !1,
          delimiter = options.delimiter || ' ',
          result = format
            .reduce(function (acc, unit) {
              var token = 'x'.concat(
                unit.replace(/(^.)/, function (m) {
                  return m.toUpperCase();
                })
              );
              return 'number' == typeof duration[unit] && (zero || duration[unit])
                ? acc.concat(locale.formatDistance(token, duration[unit]))
                : acc;
            }, [])
            .join(delimiter);
        return result;
      }
      function formatISO(dirtyDate, dirtyOptions) {
        if (arguments.length < 1)
          throw new TypeError('1 argument required, but only '.concat(arguments.length, ' present'));
        var originalDate = toDate(dirtyDate);
        if (!isValid(originalDate)) throw new RangeError('Invalid time value');
        var options = dirtyOptions || {},
          format = null == options.format ? 'extended' : String(options.format),
          representation = null == options.representation ? 'complete' : String(options.representation);
        if ('extended' !== format && 'basic' !== format) throw new RangeError("format must be 'extended' or 'basic'");
        if ('date' !== representation && 'time' !== representation && 'complete' !== representation)
          throw new RangeError("representation must be 'date', 'time', or 'complete'");
        var result = '',
          tzOffset = '',
          dateDelimiter = 'extended' === format ? '-' : '',
          timeDelimiter = 'extended' === format ? ':' : '';
        if ('time' !== representation) {
          var day = addLeadingZeros(originalDate.getDate(), 2),
            month = addLeadingZeros(originalDate.getMonth() + 1, 2),
            year = addLeadingZeros(originalDate.getFullYear(), 4);
          result = ''.concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
        }
        if ('date' !== representation) {
          var offset = originalDate.getTimezoneOffset();
          if (0 !== offset) {
            var absoluteOffset = Math.abs(offset),
              hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2),
              minuteOffset = addLeadingZeros(absoluteOffset % 60, 2),
              sign = offset < 0 ? '+' : '-';
            tzOffset = ''.concat(sign).concat(hourOffset, ':').concat(minuteOffset);
          } else tzOffset = 'Z';
          var hour = addLeadingZeros(originalDate.getHours(), 2),
            minute = addLeadingZeros(originalDate.getMinutes(), 2),
            second = addLeadingZeros(originalDate.getSeconds(), 2),
            separator = '' === result ? '' : 'T',
            time = [hour, minute, second].join(timeDelimiter);
          result = ''.concat(result).concat(separator).concat(time).concat(tzOffset);
        }
        return result;
      }
      function formatISO9075(dirtyDate, dirtyOptions) {
        if (arguments.length < 1)
          throw new TypeError('1 argument required, but only '.concat(arguments.length, ' present'));
        var originalDate = toDate(dirtyDate);
        if (!isValid(originalDate)) throw new RangeError('Invalid time value');
        var options = dirtyOptions || {},
          format = null == options.format ? 'extended' : String(options.format),
          representation = null == options.representation ? 'complete' : String(options.representation);
        if ('extended' !== format && 'basic' !== format) throw new RangeError("format must be 'extended' or 'basic'");
        if ('date' !== representation && 'time' !== representation && 'complete' !== representation)
          throw new RangeError("representation must be 'date', 'time', or 'complete'");
        var result = '',
          dateDelimiter = 'extended' === format ? '-' : '',
          timeDelimiter = 'extended' === format ? ':' : '';
        if ('time' !== representation) {
          var day = addLeadingZeros(originalDate.getDate(), 2),
            month = addLeadingZeros(originalDate.getMonth() + 1, 2),
            year = addLeadingZeros(originalDate.getFullYear(), 4);
          result = ''.concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
        }
        if ('date' !== representation) {
          var hour = addLeadingZeros(originalDate.getHours(), 2),
            minute = addLeadingZeros(originalDate.getMinutes(), 2),
            second = addLeadingZeros(originalDate.getSeconds(), 2),
            separator = '' === result ? '' : ' ';
          result = ''
            .concat(result)
            .concat(separator)
            .concat(hour)
            .concat(timeDelimiter)
            .concat(minute)
            .concat(timeDelimiter)
            .concat(second);
        }
        return result;
      }
      function formatISODuration(duration) {
        if ((requiredArgs(1, arguments), 'object' != typeof duration)) throw new Error('Duration must be an object');
        var _duration$years = duration.years,
          years = void 0 === _duration$years ? 0 : _duration$years,
          _duration$months = duration.months,
          months = void 0 === _duration$months ? 0 : _duration$months,
          _duration$days = duration.days,
          days = void 0 === _duration$days ? 0 : _duration$days,
          _duration$hours = duration.hours,
          hours = void 0 === _duration$hours ? 0 : _duration$hours,
          _duration$minutes = duration.minutes,
          minutes = void 0 === _duration$minutes ? 0 : _duration$minutes,
          _duration$seconds = duration.seconds,
          seconds = void 0 === _duration$seconds ? 0 : _duration$seconds;
        return 'P'
          .concat(years, 'Y')
          .concat(months, 'M')
          .concat(days, 'DT')
          .concat(hours, 'H')
          .concat(minutes, 'M')
          .concat(seconds, 'S');
      }
      function formatRFC3339(dirtyDate, dirtyOptions) {
        if (arguments.length < 1)
          throw new TypeError('1 arguments required, but only '.concat(arguments.length, ' present'));
        var originalDate = toDate(dirtyDate);
        if (!isValid(originalDate)) throw new RangeError('Invalid time value');
        var options = dirtyOptions || {},
          fractionDigits = null == options.fractionDigits ? 0 : toInteger(options.fractionDigits);
        if (!(fractionDigits >= 0 && fractionDigits <= 3))
          throw new RangeError('fractionDigits must be between 0 and 3 inclusively');
        var day = addLeadingZeros(originalDate.getDate(), 2),
          month = addLeadingZeros(originalDate.getMonth() + 1, 2),
          year = originalDate.getFullYear(),
          hour = addLeadingZeros(originalDate.getHours(), 2),
          minute = addLeadingZeros(originalDate.getMinutes(), 2),
          second = addLeadingZeros(originalDate.getSeconds(), 2),
          fractionalSecond = '';
        if (fractionDigits > 0) {
          var milliseconds = originalDate.getMilliseconds(),
            fractionalSeconds = Math.floor(milliseconds * Math.pow(10, fractionDigits - 3));
          fractionalSecond = '.' + addLeadingZeros(fractionalSeconds, fractionDigits);
        }
        var offset = '',
          tzOffset = originalDate.getTimezoneOffset();
        if (0 !== tzOffset) {
          var absoluteOffset = Math.abs(tzOffset),
            hourOffset = addLeadingZeros(absoluteOffset / 60, 2),
            minuteOffset = addLeadingZeros(absoluteOffset % 60, 2),
            sign = tzOffset < 0 ? '+' : '-';
          offset = ''.concat(sign).concat(hourOffset, ':').concat(minuteOffset);
        } else offset = 'Z';
        return ''
          .concat(year, '-')
          .concat(month, '-')
          .concat(day, 'T')
          .concat(hour, ':')
          .concat(minute, ':')
          .concat(second)
          .concat(fractionalSecond)
          .concat(offset);
      }
      var formatRFC7231_days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        formatRFC7231_months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      function formatRFC7231(dirtyDate) {
        if (arguments.length < 1)
          throw new TypeError('1 arguments required, but only '.concat(arguments.length, ' present'));
        var originalDate = toDate(dirtyDate);
        if (!isValid(originalDate)) throw new RangeError('Invalid time value');
        var dayName = formatRFC7231_days[originalDate.getUTCDay()],
          dayOfMonth = addLeadingZeros(originalDate.getUTCDate(), 2),
          monthName = formatRFC7231_months[originalDate.getUTCMonth()],
          year = originalDate.getUTCFullYear(),
          hour = addLeadingZeros(originalDate.getUTCHours(), 2),
          minute = addLeadingZeros(originalDate.getUTCMinutes(), 2),
          second = addLeadingZeros(originalDate.getUTCSeconds(), 2);
        return ''
          .concat(dayName, ', ')
          .concat(dayOfMonth, ' ')
          .concat(monthName, ' ')
          .concat(year, ' ')
          .concat(hour, ':')
          .concat(minute, ':')
          .concat(second, ' GMT');
      }
      function formatRelative_formatRelative(dirtyDate, dirtyBaseDate, dirtyOptions) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          baseDate = toDate(dirtyBaseDate),
          options = dirtyOptions || {},
          locale = options.locale || en_US;
        if (!locale.localize) throw new RangeError('locale must contain localize property');
        if (!locale.formatLong) throw new RangeError('locale must contain formatLong property');
        if (!locale.formatRelative) throw new RangeError('locale must contain formatRelative property');
        var token,
          diff = differenceInCalendarDays(date, baseDate);
        if (isNaN(diff)) throw new RangeError('Invalid time value');
        token =
          diff < -6
            ? 'other'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'yesterday'
            : diff < 1
            ? 'today'
            : diff < 2
            ? 'tomorrow'
            : diff < 7
            ? 'nextWeek'
            : 'other';
        var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date)),
          utcBaseDate = subMilliseconds(baseDate, getTimezoneOffsetInMilliseconds(baseDate)),
          formatStr = locale.formatRelative(token, utcDate, utcBaseDate, options);
        return format_format(date, formatStr, options);
      }
      function fromUnixTime(dirtyUnixTime) {
        requiredArgs(1, arguments);
        var unixTime = toInteger(dirtyUnixTime);
        return toDate(1e3 * unixTime);
      }
      function getDate(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          dayOfMonth = date.getDate();
        return dayOfMonth;
      }
      function getDay(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          day = date.getDay();
        return day;
      }
      function getDayOfYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          diff = differenceInCalendarDays(date, startOfYear(date)),
          dayOfYear = diff + 1;
        return dayOfYear;
      }
      function getDaysInMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear(),
          monthIndex = date.getMonth(),
          lastDayOfMonth = new Date(0);
        return (
          lastDayOfMonth.setFullYear(year, monthIndex + 1, 0),
          lastDayOfMonth.setHours(0, 0, 0, 0),
          lastDayOfMonth.getDate()
        );
      }
      function isLeapYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear();
        return year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);
      }
      function getDaysInYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return isNaN(date) ? NaN : isLeapYear(date) ? 366 : 365;
      }
      function getDecade(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear(),
          decade = 10 * Math.floor(year / 10);
        return decade;
      }
      function getHours(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          hours = date.getHours();
        return hours;
      }
      function getISODay(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          day = date.getDay();
        return 0 === day && (day = 7), day;
      }
      function getISOWeek(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
        return Math.round(diff / 6048e5) + 1;
      }
      function getISOWeeksInYear(dirtyDate) {
        requiredArgs(1, arguments);
        var thisYear = startOfISOWeekYear(dirtyDate),
          nextYear = startOfISOWeekYear(addWeeks(thisYear, 60)),
          diff = nextYear.valueOf() - thisYear.valueOf();
        return Math.round(diff / 6048e5);
      }
      function getMilliseconds(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          milliseconds = date.getMilliseconds();
        return milliseconds;
      }
      function getMinutes(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          minutes = date.getMinutes();
        return minutes;
      }
      function getMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          month = date.getMonth();
        return month;
      }
      function getOverlappingDaysInIntervals(dirtyIntervalLeft, dirtyIntervalRight) {
        requiredArgs(2, arguments);
        var intervalLeft = dirtyIntervalLeft || {},
          intervalRight = dirtyIntervalRight || {},
          leftStartTime = toDate(intervalLeft.start).getTime(),
          leftEndTime = toDate(intervalLeft.end).getTime(),
          rightStartTime = toDate(intervalRight.start).getTime(),
          rightEndTime = toDate(intervalRight.end).getTime();
        if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) throw new RangeError('Invalid interval');
        var isOverlapping = leftStartTime < rightEndTime && rightStartTime < leftEndTime;
        if (!isOverlapping) return 0;
        var overlapStartDate = rightStartTime < leftStartTime ? leftStartTime : rightStartTime,
          overlapEndDate = rightEndTime > leftEndTime ? leftEndTime : rightEndTime,
          differenceInMs = overlapEndDate - overlapStartDate;
        return Math.ceil(differenceInMs / 864e5);
      }
      function getSeconds(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          seconds = date.getSeconds();
        return seconds;
      }
      function getTime(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          timestamp = date.getTime();
        return timestamp;
      }
      function getUnixTime(dirtyDate) {
        return requiredArgs(1, arguments), Math.floor(getTime(dirtyDate) / 1e3);
      }
      function getWeekYear(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear(),
          options = dirtyOptions || {},
          locale = options.locale,
          localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate,
          defaultFirstWeekContainsDate =
            null == localeFirstWeekContainsDate ? 1 : toInteger(localeFirstWeekContainsDate),
          firstWeekContainsDate =
            null == options.firstWeekContainsDate
              ? defaultFirstWeekContainsDate
              : toInteger(options.firstWeekContainsDate);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
          throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
        var firstWeekOfNextYear = new Date(0);
        firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate), firstWeekOfNextYear.setHours(0, 0, 0, 0);
        var startOfNextYear = startOfWeek(firstWeekOfNextYear, dirtyOptions),
          firstWeekOfThisYear = new Date(0);
        firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate), firstWeekOfThisYear.setHours(0, 0, 0, 0);
        var startOfThisYear = startOfWeek(firstWeekOfThisYear, dirtyOptions);
        return date.getTime() >= startOfNextYear.getTime()
          ? year + 1
          : date.getTime() >= startOfThisYear.getTime()
          ? year
          : year - 1;
      }
      function startOfWeekYear(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate,
          defaultFirstWeekContainsDate =
            null == localeFirstWeekContainsDate ? 1 : toInteger(localeFirstWeekContainsDate),
          firstWeekContainsDate =
            null == options.firstWeekContainsDate
              ? defaultFirstWeekContainsDate
              : toInteger(options.firstWeekContainsDate),
          year = getWeekYear(dirtyDate, dirtyOptions),
          firstWeek = new Date(0);
        firstWeek.setFullYear(year, 0, firstWeekContainsDate), firstWeek.setHours(0, 0, 0, 0);
        var date = startOfWeek(firstWeek, dirtyOptions);
        return date;
      }
      function getWeek(dirtyDate, options) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime();
        return Math.round(diff / 6048e5) + 1;
      }
      function getWeekOfMonth(date, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        var currentDayOfMonth = getDate(date);
        if (isNaN(currentDayOfMonth)) return currentDayOfMonth;
        var startWeekDay = getDay(startOfMonth(date)),
          lastDayOfFirstWeek = 0,
          weekNumber = 1;
        if (
          currentDayOfMonth >
          (lastDayOfFirstWeek =
            startWeekDay >= weekStartsOn ? weekStartsOn + 7 - startWeekDay : weekStartsOn - startWeekDay)
        ) {
          var remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
          weekNumber += Math.ceil(remainingDaysAfterFirstWeek / 7);
        }
        return weekNumber;
      }
      function lastDayOfMonth_lastDayOfMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          month = date.getMonth();
        return date.setFullYear(date.getFullYear(), month + 1, 0), date.setHours(0, 0, 0, 0), date;
      }
      function getWeeksInMonth(date, options) {
        return (
          requiredArgs(1, arguments),
          differenceInCalendarWeeks(lastDayOfMonth_lastDayOfMonth(date), startOfMonth(date), options) + 1
        );
      }
      function getYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear();
        return year;
      }
      function subDays(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addDays(dirtyDate, -amount);
      }
      function subMonths(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMonths(dirtyDate, -amount);
      }
      function sub(dirtyDate, duration) {
        if ((requiredArgs(2, arguments), !duration || 'object' != typeof duration)) return new Date(NaN);
        var years = 'years' in duration ? toInteger(duration.years) : 0,
          months = 'months' in duration ? toInteger(duration.months) : 0,
          weeks = 'weeks' in duration ? toInteger(duration.weeks) : 0,
          days = 'days' in duration ? toInteger(duration.days) : 0,
          hours = 'hours' in duration ? toInteger(duration.hours) : 0,
          minutes = 'minutes' in duration ? toInteger(duration.minutes) : 0,
          seconds = 'seconds' in duration ? toInteger(duration.seconds) : 0,
          dateWithoutMonths = subMonths(toDate(dirtyDate), months + 12 * years),
          dateWithoutDays = subDays(dateWithoutMonths, days + 7 * weeks),
          minutestoSub = minutes + 60 * hours,
          secondstoSub = seconds + 60 * minutestoSub,
          mstoSub = 1e3 * secondstoSub,
          finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
        return finalDate;
      }
      function intervalToDuration(_ref) {
        var start = _ref.start,
          end = _ref.end;
        requiredArgs(1, arguments);
        var dateLeft = toDate(start),
          dateRight = toDate(end);
        if (!isValid(dateLeft)) throw new RangeError('Start Date is invalid');
        if (!isValid(dateRight)) throw new RangeError('End Date is invalid');
        var duration = { years: 0, months: 0, days: 0, hours: 0, minutes: 0, seconds: 0 },
          sign = compareAsc(dateLeft, dateRight);
        duration.years = Math.abs(differenceInYears(dateLeft, dateRight));
        var remainingMonths = sub(dateLeft, { years: sign * duration.years });
        duration.months = Math.abs(differenceInMonths(remainingMonths, dateRight));
        var remainingDays = sub(remainingMonths, { months: sign * duration.months });
        duration.days = Math.abs(differenceInDays(remainingDays, dateRight));
        var remainingHours = sub(remainingDays, { days: sign * duration.days });
        duration.hours = Math.abs(differenceInHours(remainingHours, dateRight));
        var remainingMinutes = sub(remainingHours, { hours: sign * duration.hours });
        duration.minutes = Math.abs(differenceInMinutes(remainingMinutes, dateRight));
        var remainingSeconds = sub(remainingMinutes, { minutes: sign * duration.minutes });
        return (duration.seconds = Math.abs(differenceInSeconds(remainingSeconds, dateRight))), duration;
      }
      function isAfter(dirtyDate, dirtyDateToCompare) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          dateToCompare = toDate(dirtyDateToCompare);
        return date.getTime() > dateToCompare.getTime();
      }
      function isBefore(dirtyDate, dirtyDateToCompare) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          dateToCompare = toDate(dirtyDateToCompare);
        return date.getTime() < dateToCompare.getTime();
      }
      function isDate(value) {
        return (
          requiredArgs(1, arguments),
          value instanceof Date ||
            ('object' == typeof value && '[object Date]' === Object.prototype.toString.call(value))
        );
      }
      function isEqual(dirtyLeftDate, dirtyRightDate) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyLeftDate),
          dateRight = toDate(dirtyRightDate);
        return dateLeft.getTime() === dateRight.getTime();
      }
      function isExists(year, month, day) {
        if (arguments.length < 3) throw new TypeError('3 argument required, but only ' + arguments.length + ' present');
        var date = new Date(year, month, day);
        return date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;
      }
      function isFirstDayOfMonth(dirtyDate) {
        return requiredArgs(1, arguments), 1 === toDate(dirtyDate).getDate();
      }
      function isFriday(dirtyDate) {
        return requiredArgs(1, arguments), 5 === toDate(dirtyDate).getDay();
      }
      function isFuture(dirtyDate) {
        return requiredArgs(1, arguments), toDate(dirtyDate).getTime() > Date.now();
      }
      function isLastDayOfMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return endOfDay(date).getTime() === endOfMonth(date).getTime();
      }
      function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
        requiredArgs(2, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        var date = toDate(dirtyDate),
          day = toInteger(dirtyDay),
          currentDay = date.getUTCDay(),
          remainder = day % 7,
          dayIndex = (remainder + 7) % 7,
          diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
        return date.setUTCDate(date.getUTCDate() + diff), date;
      }
      var numericPatterns_month = /^(1[0-2]|0?\d)/,
        numericPatterns_date = /^(3[0-1]|[0-2]?\d)/,
        numericPatterns_dayOfYear = /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
        numericPatterns_week = /^(5[0-3]|[0-4]?\d)/,
        numericPatterns_hour23h = /^(2[0-3]|[0-1]?\d)/,
        numericPatterns_hour24h = /^(2[0-4]|[0-1]?\d)/,
        numericPatterns_hour11h = /^(1[0-1]|0?\d)/,
        numericPatterns_hour12h = /^(1[0-2]|0?\d)/,
        numericPatterns_minute = /^[0-5]?\d/,
        numericPatterns_second = /^[0-5]?\d/,
        numericPatterns_singleDigit = /^\d/,
        numericPatterns_twoDigits = /^\d{1,2}/,
        numericPatterns_threeDigits = /^\d{1,3}/,
        numericPatterns_fourDigits = /^\d{1,4}/,
        numericPatterns_anyDigitsSigned = /^-?\d+/,
        numericPatterns_singleDigitSigned = /^-?\d/,
        numericPatterns_twoDigitsSigned = /^-?\d{1,2}/,
        numericPatterns_threeDigitsSigned = /^-?\d{1,3}/,
        numericPatterns_fourDigitsSigned = /^-?\d{1,4}/,
        timezonePatterns_basicOptionalMinutes = /^([+-])(\d{2})(\d{2})?|Z/,
        timezonePatterns_basic = /^([+-])(\d{2})(\d{2})|Z/,
        timezonePatterns_basicOptionalSeconds = /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
        timezonePatterns_extended = /^([+-])(\d{2}):(\d{2})|Z/,
        timezonePatterns_extendedOptionalSeconds = /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/;
      function parseNumericPattern(pattern, string, valueCallback) {
        var matchResult = string.match(pattern);
        if (!matchResult) return null;
        var value = parseInt(matchResult[0], 10);
        return { value: valueCallback ? valueCallback(value) : value, rest: string.slice(matchResult[0].length) };
      }
      function parseTimezonePattern(pattern, string) {
        var matchResult = string.match(pattern);
        return matchResult
          ? 'Z' === matchResult[0]
            ? { value: 0, rest: string.slice(1) }
            : {
                value:
                  ('+' === matchResult[1] ? 1 : -1) *
                  (36e5 * (matchResult[2] ? parseInt(matchResult[2], 10) : 0) +
                    6e4 * (matchResult[3] ? parseInt(matchResult[3], 10) : 0) +
                    1e3 * (matchResult[5] ? parseInt(matchResult[5], 10) : 0)),
                rest: string.slice(matchResult[0].length),
              }
          : null;
      }
      function parseAnyDigitsSigned(string, valueCallback) {
        return parseNumericPattern(numericPatterns_anyDigitsSigned, string, valueCallback);
      }
      function parseNDigits(n, string, valueCallback) {
        switch (n) {
          case 1:
            return parseNumericPattern(numericPatterns_singleDigit, string, valueCallback);
          case 2:
            return parseNumericPattern(numericPatterns_twoDigits, string, valueCallback);
          case 3:
            return parseNumericPattern(numericPatterns_threeDigits, string, valueCallback);
          case 4:
            return parseNumericPattern(numericPatterns_fourDigits, string, valueCallback);
          default:
            return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
        }
      }
      function parseNDigitsSigned(n, string, valueCallback) {
        switch (n) {
          case 1:
            return parseNumericPattern(numericPatterns_singleDigitSigned, string, valueCallback);
          case 2:
            return parseNumericPattern(numericPatterns_twoDigitsSigned, string, valueCallback);
          case 3:
            return parseNumericPattern(numericPatterns_threeDigitsSigned, string, valueCallback);
          case 4:
            return parseNumericPattern(numericPatterns_fourDigitsSigned, string, valueCallback);
          default:
            return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
        }
      }
      function dayPeriodEnumToHours(enumValue) {
        switch (enumValue) {
          case 'morning':
            return 4;
          case 'evening':
            return 17;
          case 'pm':
          case 'noon':
          case 'afternoon':
            return 12;
          case 'am':
          case 'midnight':
          case 'night':
          default:
            return 0;
        }
      }
      function normalizeTwoDigitYear(twoDigitYear, currentYear) {
        var result,
          isCommonEra = currentYear > 0,
          absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
        if (absCurrentYear <= 50) result = twoDigitYear || 100;
        else {
          var rangeEnd = absCurrentYear + 50;
          result = twoDigitYear + 100 * Math.floor(rangeEnd / 100) - (twoDigitYear >= rangeEnd % 100 ? 100 : 0);
        }
        return isCommonEra ? result : 1 - result;
      }
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function isLeapYearIndex(year) {
        return year % 400 == 0 || (year % 4 == 0 && year % 100 != 0);
      }
      var _lib_parsers = {
          G: {
            priority: 140,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'G':
                case 'GG':
                case 'GGG':
                  return match.era(string, { width: 'abbreviated' }) || match.era(string, { width: 'narrow' });
                case 'GGGGG':
                  return match.era(string, { width: 'narrow' });
                case 'GGGG':
                default:
                  return (
                    match.era(string, { width: 'wide' }) ||
                    match.era(string, { width: 'abbreviated' }) ||
                    match.era(string, { width: 'narrow' })
                  );
              }
            },
            set: function (date, flags, value, _options) {
              return (flags.era = value), date.setUTCFullYear(value, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['R', 'u', 't', 'T'],
          },
          y: {
            priority: 130,
            parse: function (string, token, match, _options) {
              var valueCallback = function (year) {
                return { year, isTwoDigitYear: 'yy' === token };
              };
              switch (token) {
                case 'y':
                  return parseNDigits(4, string, valueCallback);
                case 'yo':
                  return match.ordinalNumber(string, { unit: 'year', valueCallback });
                default:
                  return parseNDigits(token.length, string, valueCallback);
              }
            },
            validate: function (_date, value, _options) {
              return value.isTwoDigitYear || value.year > 0;
            },
            set: function (date, flags, value, _options) {
              var currentYear = date.getUTCFullYear();
              if (value.isTwoDigitYear) {
                var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
                return date.setUTCFullYear(normalizedTwoDigitYear, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
              }
              var year = 'era' in flags && 1 !== flags.era ? 1 - value.year : value.year;
              return date.setUTCFullYear(year, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T'],
          },
          Y: {
            priority: 130,
            parse: function (string, token, match, _options) {
              var valueCallback = function (year) {
                return { year, isTwoDigitYear: 'YY' === token };
              };
              switch (token) {
                case 'Y':
                  return parseNDigits(4, string, valueCallback);
                case 'Yo':
                  return match.ordinalNumber(string, { unit: 'year', valueCallback });
                default:
                  return parseNDigits(token.length, string, valueCallback);
              }
            },
            validate: function (_date, value, _options) {
              return value.isTwoDigitYear || value.year > 0;
            },
            set: function (date, flags, value, options) {
              var currentYear = getUTCWeekYear(date, options);
              if (value.isTwoDigitYear) {
                var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
                return (
                  date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate),
                  date.setUTCHours(0, 0, 0, 0),
                  startOfUTCWeek(date, options)
                );
              }
              var year = 'era' in flags && 1 !== flags.era ? 1 - value.year : value.year;
              return (
                date.setUTCFullYear(year, 0, options.firstWeekContainsDate),
                date.setUTCHours(0, 0, 0, 0),
                startOfUTCWeek(date, options)
              );
            },
            incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T'],
          },
          R: {
            priority: 130,
            parse: function (string, token, _match, _options) {
              return parseNDigitsSigned('R' === token ? 4 : token.length, string);
            },
            set: function (_date, _flags, value, _options) {
              var firstWeekOfYear = new Date(0);
              return (
                firstWeekOfYear.setUTCFullYear(value, 0, 4),
                firstWeekOfYear.setUTCHours(0, 0, 0, 0),
                startOfUTCISOWeek(firstWeekOfYear)
              );
            },
            incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T'],
          },
          u: {
            priority: 130,
            parse: function (string, token, _match, _options) {
              return parseNDigitsSigned('u' === token ? 4 : token.length, string);
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCFullYear(value, 0, 1), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T'],
          },
          Q: {
            priority: 120,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'Q':
                case 'QQ':
                  return parseNDigits(token.length, string);
                case 'Qo':
                  return match.ordinalNumber(string, { unit: 'quarter' });
                case 'QQQ':
                  return (
                    match.quarter(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.quarter(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'QQQQQ':
                  return match.quarter(string, { width: 'narrow', context: 'formatting' });
                case 'QQQQ':
                default:
                  return (
                    match.quarter(string, { width: 'wide', context: 'formatting' }) ||
                    match.quarter(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.quarter(string, { width: 'narrow', context: 'formatting' })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 1 && value <= 4;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCMonth(3 * (value - 1), 1), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T'],
          },
          q: {
            priority: 120,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'q':
                case 'qq':
                  return parseNDigits(token.length, string);
                case 'qo':
                  return match.ordinalNumber(string, { unit: 'quarter' });
                case 'qqq':
                  return (
                    match.quarter(string, { width: 'abbreviated', context: 'standalone' }) ||
                    match.quarter(string, { width: 'narrow', context: 'standalone' })
                  );
                case 'qqqqq':
                  return match.quarter(string, { width: 'narrow', context: 'standalone' });
                case 'qqqq':
                default:
                  return (
                    match.quarter(string, { width: 'wide', context: 'standalone' }) ||
                    match.quarter(string, { width: 'abbreviated', context: 'standalone' }) ||
                    match.quarter(string, { width: 'narrow', context: 'standalone' })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 1 && value <= 4;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCMonth(3 * (value - 1), 1), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T'],
          },
          M: {
            priority: 110,
            parse: function (string, token, match, _options) {
              var valueCallback = function (value) {
                return value - 1;
              };
              switch (token) {
                case 'M':
                  return parseNumericPattern(numericPatterns_month, string, valueCallback);
                case 'MM':
                  return parseNDigits(2, string, valueCallback);
                case 'Mo':
                  return match.ordinalNumber(string, { unit: 'month', valueCallback });
                case 'MMM':
                  return (
                    match.month(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.month(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'MMMMM':
                  return match.month(string, { width: 'narrow', context: 'formatting' });
                case 'MMMM':
                default:
                  return (
                    match.month(string, { width: 'wide', context: 'formatting' }) ||
                    match.month(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.month(string, { width: 'narrow', context: 'formatting' })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 11;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCMonth(value, 1), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T'],
          },
          L: {
            priority: 110,
            parse: function (string, token, match, _options) {
              var valueCallback = function (value) {
                return value - 1;
              };
              switch (token) {
                case 'L':
                  return parseNumericPattern(numericPatterns_month, string, valueCallback);
                case 'LL':
                  return parseNDigits(2, string, valueCallback);
                case 'Lo':
                  return match.ordinalNumber(string, { unit: 'month', valueCallback });
                case 'LLL':
                  return (
                    match.month(string, { width: 'abbreviated', context: 'standalone' }) ||
                    match.month(string, { width: 'narrow', context: 'standalone' })
                  );
                case 'LLLLL':
                  return match.month(string, { width: 'narrow', context: 'standalone' });
                case 'LLLL':
                default:
                  return (
                    match.month(string, { width: 'wide', context: 'standalone' }) ||
                    match.month(string, { width: 'abbreviated', context: 'standalone' }) ||
                    match.month(string, { width: 'narrow', context: 'standalone' })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 11;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCMonth(value, 1), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T'],
          },
          w: {
            priority: 100,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'w':
                  return parseNumericPattern(numericPatterns_week, string);
                case 'wo':
                  return match.ordinalNumber(string, { unit: 'week' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 1 && value <= 53;
            },
            set: function (date, _flags, value, options) {
              return startOfUTCWeek(
                (function setUTCWeek(dirtyDate, dirtyWeek, options) {
                  requiredArgs(2, arguments);
                  var date = toDate(dirtyDate),
                    week = toInteger(dirtyWeek),
                    diff = getUTCWeek(date, options) - week;
                  return date.setUTCDate(date.getUTCDate() - 7 * diff), date;
                })(date, value, options),
                options
              );
            },
            incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T'],
          },
          I: {
            priority: 100,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'I':
                  return parseNumericPattern(numericPatterns_week, string);
                case 'Io':
                  return match.ordinalNumber(string, { unit: 'week' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 1 && value <= 53;
            },
            set: function (date, _flags, value, options) {
              return startOfUTCISOWeek(
                (function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
                  requiredArgs(2, arguments);
                  var date = toDate(dirtyDate),
                    isoWeek = toInteger(dirtyISOWeek),
                    diff = getUTCISOWeek(date) - isoWeek;
                  return date.setUTCDate(date.getUTCDate() - 7 * diff), date;
                })(date, value, options),
                options
              );
            },
            incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T'],
          },
          d: {
            priority: 90,
            subPriority: 1,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'd':
                  return parseNumericPattern(numericPatterns_date, string);
                case 'do':
                  return match.ordinalNumber(string, { unit: 'date' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (date, value, _options) {
              var isLeapYear = isLeapYearIndex(date.getUTCFullYear()),
                month = date.getUTCMonth();
              return isLeapYear
                ? value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month]
                : value >= 1 && value <= DAYS_IN_MONTH[month];
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCDate(value), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T'],
          },
          D: {
            priority: 90,
            subPriority: 1,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'D':
                case 'DD':
                  return parseNumericPattern(numericPatterns_dayOfYear, string);
                case 'Do':
                  return match.ordinalNumber(string, { unit: 'date' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (date, value, _options) {
              return isLeapYearIndex(date.getUTCFullYear()) ? value >= 1 && value <= 366 : value >= 1 && value <= 365;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCMonth(0, value), date.setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T'],
          },
          E: {
            priority: 90,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'E':
                case 'EE':
                case 'EEE':
                  return (
                    match.day(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.day(string, { width: 'short', context: 'formatting' }) ||
                    match.day(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'EEEEE':
                  return match.day(string, { width: 'narrow', context: 'formatting' });
                case 'EEEEEE':
                  return (
                    match.day(string, { width: 'short', context: 'formatting' }) ||
                    match.day(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'EEEE':
                default:
                  return (
                    match.day(string, { width: 'wide', context: 'formatting' }) ||
                    match.day(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.day(string, { width: 'short', context: 'formatting' }) ||
                    match.day(string, { width: 'narrow', context: 'formatting' })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 6;
            },
            set: function (date, _flags, value, options) {
              return (date = setUTCDay(date, value, options)).setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T'],
          },
          e: {
            priority: 90,
            parse: function (string, token, match, options) {
              var valueCallback = function (value) {
                var wholeWeekDays = 7 * Math.floor((value - 1) / 7);
                return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
              };
              switch (token) {
                case 'e':
                case 'ee':
                  return parseNDigits(token.length, string, valueCallback);
                case 'eo':
                  return match.ordinalNumber(string, { unit: 'day', valueCallback });
                case 'eee':
                  return (
                    match.day(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.day(string, { width: 'short', context: 'formatting' }) ||
                    match.day(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'eeeee':
                  return match.day(string, { width: 'narrow', context: 'formatting' });
                case 'eeeeee':
                  return (
                    match.day(string, { width: 'short', context: 'formatting' }) ||
                    match.day(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'eeee':
                default:
                  return (
                    match.day(string, { width: 'wide', context: 'formatting' }) ||
                    match.day(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.day(string, { width: 'short', context: 'formatting' }) ||
                    match.day(string, { width: 'narrow', context: 'formatting' })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 6;
            },
            set: function (date, _flags, value, options) {
              return (date = setUTCDay(date, value, options)).setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T'],
          },
          c: {
            priority: 90,
            parse: function (string, token, match, options) {
              var valueCallback = function (value) {
                var wholeWeekDays = 7 * Math.floor((value - 1) / 7);
                return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
              };
              switch (token) {
                case 'c':
                case 'cc':
                  return parseNDigits(token.length, string, valueCallback);
                case 'co':
                  return match.ordinalNumber(string, { unit: 'day', valueCallback });
                case 'ccc':
                  return (
                    match.day(string, { width: 'abbreviated', context: 'standalone' }) ||
                    match.day(string, { width: 'short', context: 'standalone' }) ||
                    match.day(string, { width: 'narrow', context: 'standalone' })
                  );
                case 'ccccc':
                  return match.day(string, { width: 'narrow', context: 'standalone' });
                case 'cccccc':
                  return (
                    match.day(string, { width: 'short', context: 'standalone' }) ||
                    match.day(string, { width: 'narrow', context: 'standalone' })
                  );
                case 'cccc':
                default:
                  return (
                    match.day(string, { width: 'wide', context: 'standalone' }) ||
                    match.day(string, { width: 'abbreviated', context: 'standalone' }) ||
                    match.day(string, { width: 'short', context: 'standalone' }) ||
                    match.day(string, { width: 'narrow', context: 'standalone' })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 6;
            },
            set: function (date, _flags, value, options) {
              return (date = setUTCDay(date, value, options)).setUTCHours(0, 0, 0, 0), date;
            },
            incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T'],
          },
          i: {
            priority: 90,
            parse: function (string, token, match, _options) {
              var valueCallback = function (value) {
                return 0 === value ? 7 : value;
              };
              switch (token) {
                case 'i':
                case 'ii':
                  return parseNDigits(token.length, string);
                case 'io':
                  return match.ordinalNumber(string, { unit: 'day' });
                case 'iii':
                  return (
                    match.day(string, { width: 'abbreviated', context: 'formatting', valueCallback }) ||
                    match.day(string, { width: 'short', context: 'formatting', valueCallback }) ||
                    match.day(string, { width: 'narrow', context: 'formatting', valueCallback })
                  );
                case 'iiiii':
                  return match.day(string, { width: 'narrow', context: 'formatting', valueCallback });
                case 'iiiiii':
                  return (
                    match.day(string, { width: 'short', context: 'formatting', valueCallback }) ||
                    match.day(string, { width: 'narrow', context: 'formatting', valueCallback })
                  );
                case 'iiii':
                default:
                  return (
                    match.day(string, { width: 'wide', context: 'formatting', valueCallback }) ||
                    match.day(string, { width: 'abbreviated', context: 'formatting', valueCallback }) ||
                    match.day(string, { width: 'short', context: 'formatting', valueCallback }) ||
                    match.day(string, { width: 'narrow', context: 'formatting', valueCallback })
                  );
              }
            },
            validate: function (_date, value, _options) {
              return value >= 1 && value <= 7;
            },
            set: function (date, _flags, value, options) {
              return (
                (date = (function setUTCISODay(dirtyDate, dirtyDay) {
                  requiredArgs(2, arguments);
                  var day = toInteger(dirtyDay);
                  day % 7 == 0 && (day -= 7);
                  var weekStartsOn = 1,
                    date = toDate(dirtyDate),
                    currentDay = date.getUTCDay(),
                    remainder = day % 7,
                    dayIndex = (remainder + 7) % 7,
                    diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
                  return date.setUTCDate(date.getUTCDate() + diff), date;
                })(date, value, options)).setUTCHours(0, 0, 0, 0),
                date
              );
            },
            incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T'],
          },
          a: {
            priority: 80,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'a':
                case 'aa':
                case 'aaa':
                  return (
                    match.dayPeriod(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'aaaaa':
                  return match.dayPeriod(string, { width: 'narrow', context: 'formatting' });
                case 'aaaa':
                default:
                  return (
                    match.dayPeriod(string, { width: 'wide', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'narrow', context: 'formatting' })
                  );
              }
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date;
            },
            incompatibleTokens: ['b', 'B', 'H', 'K', 'k', 't', 'T'],
          },
          b: {
            priority: 80,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'b':
                case 'bb':
                case 'bbb':
                  return (
                    match.dayPeriod(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'bbbbb':
                  return match.dayPeriod(string, { width: 'narrow', context: 'formatting' });
                case 'bbbb':
                default:
                  return (
                    match.dayPeriod(string, { width: 'wide', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'narrow', context: 'formatting' })
                  );
              }
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date;
            },
            incompatibleTokens: ['a', 'B', 'H', 'K', 'k', 't', 'T'],
          },
          B: {
            priority: 80,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'B':
                case 'BB':
                case 'BBB':
                  return (
                    match.dayPeriod(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'narrow', context: 'formatting' })
                  );
                case 'BBBBB':
                  return match.dayPeriod(string, { width: 'narrow', context: 'formatting' });
                case 'BBBB':
                default:
                  return (
                    match.dayPeriod(string, { width: 'wide', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'abbreviated', context: 'formatting' }) ||
                    match.dayPeriod(string, { width: 'narrow', context: 'formatting' })
                  );
              }
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0), date;
            },
            incompatibleTokens: ['a', 'b', 't', 'T'],
          },
          h: {
            priority: 70,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'h':
                  return parseNumericPattern(numericPatterns_hour12h, string);
                case 'ho':
                  return match.ordinalNumber(string, { unit: 'hour' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 1 && value <= 12;
            },
            set: function (date, _flags, value, _options) {
              var isPM = date.getUTCHours() >= 12;
              return (
                isPM && value < 12
                  ? date.setUTCHours(value + 12, 0, 0, 0)
                  : isPM || 12 !== value
                  ? date.setUTCHours(value, 0, 0, 0)
                  : date.setUTCHours(0, 0, 0, 0),
                date
              );
            },
            incompatibleTokens: ['H', 'K', 'k', 't', 'T'],
          },
          H: {
            priority: 70,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'H':
                  return parseNumericPattern(numericPatterns_hour23h, string);
                case 'Ho':
                  return match.ordinalNumber(string, { unit: 'hour' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 23;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCHours(value, 0, 0, 0), date;
            },
            incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T'],
          },
          K: {
            priority: 70,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'K':
                  return parseNumericPattern(numericPatterns_hour11h, string);
                case 'Ko':
                  return match.ordinalNumber(string, { unit: 'hour' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 11;
            },
            set: function (date, _flags, value, _options) {
              return (
                date.getUTCHours() >= 12 && value < 12
                  ? date.setUTCHours(value + 12, 0, 0, 0)
                  : date.setUTCHours(value, 0, 0, 0),
                date
              );
            },
            incompatibleTokens: ['a', 'b', 'h', 'H', 'k', 't', 'T'],
          },
          k: {
            priority: 70,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'k':
                  return parseNumericPattern(numericPatterns_hour24h, string);
                case 'ko':
                  return match.ordinalNumber(string, { unit: 'hour' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 1 && value <= 24;
            },
            set: function (date, _flags, value, _options) {
              var hours = value <= 24 ? value % 24 : value;
              return date.setUTCHours(hours, 0, 0, 0), date;
            },
            incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T'],
          },
          m: {
            priority: 60,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 'm':
                  return parseNumericPattern(numericPatterns_minute, string);
                case 'mo':
                  return match.ordinalNumber(string, { unit: 'minute' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 59;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCMinutes(value, 0, 0), date;
            },
            incompatibleTokens: ['t', 'T'],
          },
          s: {
            priority: 50,
            parse: function (string, token, match, _options) {
              switch (token) {
                case 's':
                  return parseNumericPattern(numericPatterns_second, string);
                case 'so':
                  return match.ordinalNumber(string, { unit: 'second' });
                default:
                  return parseNDigits(token.length, string);
              }
            },
            validate: function (_date, value, _options) {
              return value >= 0 && value <= 59;
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCSeconds(value, 0), date;
            },
            incompatibleTokens: ['t', 'T'],
          },
          S: {
            priority: 30,
            parse: function (string, token, _match, _options) {
              return parseNDigits(token.length, string, function (value) {
                return Math.floor(value * Math.pow(10, 3 - token.length));
              });
            },
            set: function (date, _flags, value, _options) {
              return date.setUTCMilliseconds(value), date;
            },
            incompatibleTokens: ['t', 'T'],
          },
          X: {
            priority: 10,
            parse: function (string, token, _match, _options) {
              switch (token) {
                case 'X':
                  return parseTimezonePattern(timezonePatterns_basicOptionalMinutes, string);
                case 'XX':
                  return parseTimezonePattern(timezonePatterns_basic, string);
                case 'XXXX':
                  return parseTimezonePattern(timezonePatterns_basicOptionalSeconds, string);
                case 'XXXXX':
                  return parseTimezonePattern(timezonePatterns_extendedOptionalSeconds, string);
                case 'XXX':
                default:
                  return parseTimezonePattern(timezonePatterns_extended, string);
              }
            },
            set: function (date, flags, value, _options) {
              return flags.timestampIsSet ? date : new Date(date.getTime() - value);
            },
            incompatibleTokens: ['t', 'T', 'x'],
          },
          x: {
            priority: 10,
            parse: function (string, token, _match, _options) {
              switch (token) {
                case 'x':
                  return parseTimezonePattern(timezonePatterns_basicOptionalMinutes, string);
                case 'xx':
                  return parseTimezonePattern(timezonePatterns_basic, string);
                case 'xxxx':
                  return parseTimezonePattern(timezonePatterns_basicOptionalSeconds, string);
                case 'xxxxx':
                  return parseTimezonePattern(timezonePatterns_extendedOptionalSeconds, string);
                case 'xxx':
                default:
                  return parseTimezonePattern(timezonePatterns_extended, string);
              }
            },
            set: function (date, flags, value, _options) {
              return flags.timestampIsSet ? date : new Date(date.getTime() - value);
            },
            incompatibleTokens: ['t', 'T', 'X'],
          },
          t: {
            priority: 40,
            parse: function (string, _token, _match, _options) {
              return parseAnyDigitsSigned(string);
            },
            set: function (_date, _flags, value, _options) {
              return [new Date(1e3 * value), { timestampIsSet: !0 }];
            },
            incompatibleTokens: '*',
          },
          T: {
            priority: 20,
            parse: function (string, _token, _match, _options) {
              return parseAnyDigitsSigned(string);
            },
            set: function (_date, _flags, value, _options) {
              return [new Date(value), { timestampIsSet: !0 }];
            },
            incompatibleTokens: '*',
          },
        },
        parse_formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
        parse_longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
        parse_escapedStringRegExp = /^'([^]*?)'?$/,
        parse_doubleQuoteRegExp = /''/g,
        notWhitespaceRegExp = /\S/,
        parse_unescapedLatinCharacterRegExp = /[a-zA-Z]/;
      function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
        requiredArgs(3, arguments);
        var dateString = String(dirtyDateString),
          formatString = String(dirtyFormatString),
          options = dirtyOptions || {},
          locale = options.locale || en_US;
        if (!locale.match) throw new RangeError('locale must contain match property');
        var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate,
          defaultFirstWeekContainsDate =
            null == localeFirstWeekContainsDate ? 1 : toInteger(localeFirstWeekContainsDate),
          firstWeekContainsDate =
            null == options.firstWeekContainsDate
              ? defaultFirstWeekContainsDate
              : toInteger(options.firstWeekContainsDate);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7))
          throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
        var localeWeekStartsOn = locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        if ('' === formatString) return '' === dateString ? toDate(dirtyReferenceDate) : new Date(NaN);
        var i,
          subFnOptions = { firstWeekContainsDate, weekStartsOn, locale },
          setters = [{ priority: 10, subPriority: -1, set: dateToSystemTimezone, index: 0 }],
          tokens = formatString
            .match(parse_longFormattingTokensRegExp)
            .map(function (substring) {
              var firstCharacter = substring[0];
              return 'p' === firstCharacter || 'P' === firstCharacter
                ? (0, format_longFormatters[firstCharacter])(substring, locale.formatLong, subFnOptions)
                : substring;
            })
            .join('')
            .match(parse_formattingTokensRegExp),
          usedTokens = [];
        for (i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          !options.useAdditionalWeekYearTokens &&
            isProtectedWeekYearToken(token) &&
            throwProtectedError(token, formatString, dirtyDateString),
            !options.useAdditionalDayOfYearTokens &&
              isProtectedDayOfYearToken(token) &&
              throwProtectedError(token, formatString, dirtyDateString);
          var firstCharacter = token[0],
            parser = _lib_parsers[firstCharacter];
          if (parser) {
            var incompatibleTokens = parser.incompatibleTokens;
            if (Array.isArray(incompatibleTokens)) {
              for (var incompatibleToken = void 0, _i = 0; _i < usedTokens.length; _i++) {
                var usedToken = usedTokens[_i].token;
                if (-1 !== incompatibleTokens.indexOf(usedToken) || usedToken === firstCharacter) {
                  incompatibleToken = usedTokens[_i];
                  break;
                }
              }
              if (incompatibleToken)
                throw new RangeError(
                  "The format string mustn't contain `"
                    .concat(incompatibleToken.fullToken, '` and `')
                    .concat(token, '` at the same time')
                );
            } else if ('*' === parser.incompatibleTokens && usedTokens.length)
              throw new RangeError(
                "The format string mustn't contain `".concat(token, '` and any other token at the same time')
              );
            usedTokens.push({ token: firstCharacter, fullToken: token });
            var parseResult = parser.parse(dateString, token, locale.match, subFnOptions);
            if (!parseResult) return new Date(NaN);
            setters.push({
              priority: parser.priority,
              subPriority: parser.subPriority || 0,
              set: parser.set,
              validate: parser.validate,
              value: parseResult.value,
              index: setters.length,
            }),
              (dateString = parseResult.rest);
          } else {
            if (firstCharacter.match(parse_unescapedLatinCharacterRegExp))
              throw new RangeError(
                'Format string contains an unescaped latin alphabet character `' + firstCharacter + '`'
              );
            if (
              ("''" === token ? (token = "'") : "'" === firstCharacter && (token = parse_cleanEscapedString(token)),
              0 !== dateString.indexOf(token))
            )
              return new Date(NaN);
            dateString = dateString.slice(token.length);
          }
        }
        if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) return new Date(NaN);
        var uniquePrioritySetters = setters
            .map(function (setter) {
              return setter.priority;
            })
            .sort(function (a, b) {
              return b - a;
            })
            .filter(function (priority, index, array) {
              return array.indexOf(priority) === index;
            })
            .map(function (priority) {
              return setters
                .filter(function (setter) {
                  return setter.priority === priority;
                })
                .sort(function (a, b) {
                  return b.subPriority - a.subPriority;
                });
            })
            .map(function (setterArray) {
              return setterArray[0];
            }),
          date = toDate(dirtyReferenceDate);
        if (isNaN(date)) return new Date(NaN);
        var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date)),
          flags = {};
        for (i = 0; i < uniquePrioritySetters.length; i++) {
          var setter = uniquePrioritySetters[i];
          if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) return new Date(NaN);
          var result = setter.set(utcDate, flags, setter.value, subFnOptions);
          result[0] ? ((utcDate = result[0]), assign_assign(flags, result[1])) : (utcDate = result);
        }
        return utcDate;
      }
      function dateToSystemTimezone(date, flags) {
        if (flags.timestampIsSet) return date;
        var convertedDate = new Date(0);
        return (
          convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()),
          convertedDate.setHours(
            date.getUTCHours(),
            date.getUTCMinutes(),
            date.getUTCSeconds(),
            date.getUTCMilliseconds()
          ),
          convertedDate
        );
      }
      function parse_cleanEscapedString(input) {
        return input.match(parse_escapedStringRegExp)[1].replace(parse_doubleQuoteRegExp, "'");
      }
      function isMatch(dateString, formatString, dirtyOptions) {
        return requiredArgs(2, arguments), isValid(parse(dateString, formatString, new Date(), dirtyOptions));
      }
      function isMonday(dirtyDate) {
        return requiredArgs(1, arguments), 1 === toDate(dirtyDate).getDay();
      }
      function isPast(dirtyDate) {
        return requiredArgs(1, arguments), toDate(dirtyDate).getTime() < Date.now();
      }
      function startOfHour(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setMinutes(0, 0, 0), date;
      }
      function isSameHour(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeftStartOfHour = startOfHour(dirtyDateLeft),
          dateRightStartOfHour = startOfHour(dirtyDateRight);
        return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
      }
      function isSameWeek(dirtyDateLeft, dirtyDateRight, dirtyOptions) {
        requiredArgs(2, arguments);
        var dateLeftStartOfWeek = startOfWeek(dirtyDateLeft, dirtyOptions),
          dateRightStartOfWeek = startOfWeek(dirtyDateRight, dirtyOptions);
        return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
      }
      function isSameISOWeek(dirtyDateLeft, dirtyDateRight) {
        return requiredArgs(2, arguments), isSameWeek(dirtyDateLeft, dirtyDateRight, { weekStartsOn: 1 });
      }
      function isSameISOWeekYear(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeftStartOfYear = startOfISOWeekYear(dirtyDateLeft),
          dateRightStartOfYear = startOfISOWeekYear(dirtyDateRight);
        return dateLeftStartOfYear.getTime() === dateRightStartOfYear.getTime();
      }
      function startOfMinute(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setSeconds(0, 0), date;
      }
      function isSameMinute(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeftStartOfMinute = startOfMinute(dirtyDateLeft),
          dateRightStartOfMinute = startOfMinute(dirtyDateRight);
        return dateLeftStartOfMinute.getTime() === dateRightStartOfMinute.getTime();
      }
      function isSameMonth(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight);
        return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
      }
      function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft),
          dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
        return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
      }
      function startOfSecond(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        return date.setMilliseconds(0), date;
      }
      function isSameSecond(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeftStartOfSecond = startOfSecond(dirtyDateLeft),
          dateRightStartOfSecond = startOfSecond(dirtyDateRight);
        return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
      }
      function isSameYear(dirtyDateLeft, dirtyDateRight) {
        requiredArgs(2, arguments);
        var dateLeft = toDate(dirtyDateLeft),
          dateRight = toDate(dirtyDateRight);
        return dateLeft.getFullYear() === dateRight.getFullYear();
      }
      function isThisHour(dirtyDate) {
        return requiredArgs(1, arguments), isSameHour(Date.now(), dirtyDate);
      }
      function isThisISOWeek(dirtyDate) {
        return requiredArgs(1, arguments), isSameISOWeek(dirtyDate, Date.now());
      }
      function isThisMinute(dirtyDate) {
        return requiredArgs(1, arguments), isSameMinute(Date.now(), dirtyDate);
      }
      function isThisMonth(dirtyDate) {
        return requiredArgs(1, arguments), isSameMonth(Date.now(), dirtyDate);
      }
      function isThisQuarter(dirtyDate) {
        return requiredArgs(1, arguments), isSameQuarter(Date.now(), dirtyDate);
      }
      function isThisSecond(dirtyDate) {
        return requiredArgs(1, arguments), isSameSecond(Date.now(), dirtyDate);
      }
      function isThisWeek(dirtyDate, options) {
        return requiredArgs(1, arguments), isSameWeek(dirtyDate, Date.now(), options);
      }
      function isThisYear(dirtyDate) {
        return requiredArgs(1, arguments), isSameYear(dirtyDate, Date.now());
      }
      function isThursday(dirtyDate) {
        return requiredArgs(1, arguments), 4 === toDate(dirtyDate).getDay();
      }
      function isToday(dirtyDate) {
        return requiredArgs(1, arguments), isSameDay(dirtyDate, Date.now());
      }
      function isTomorrow(dirtyDate) {
        return requiredArgs(1, arguments), isSameDay(dirtyDate, addDays(Date.now(), 1));
      }
      function isTuesday(dirtyDate) {
        return requiredArgs(1, arguments), 2 === toDate(dirtyDate).getDay();
      }
      function isWednesday(dirtyDate) {
        return requiredArgs(1, arguments), 3 === toDate(dirtyDate).getDay();
      }
      function isWithinInterval(dirtyDate, dirtyInterval) {
        requiredArgs(2, arguments);
        var interval = dirtyInterval || {},
          time = toDate(dirtyDate).getTime(),
          startTime = toDate(interval.start).getTime(),
          endTime = toDate(interval.end).getTime();
        if (!(startTime <= endTime)) throw new RangeError('Invalid interval');
        return time >= startTime && time <= endTime;
      }
      function isYesterday(dirtyDate) {
        return requiredArgs(1, arguments), isSameDay(dirtyDate, subDays(Date.now(), 1));
      }
      function lastDayOfDecade(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear(),
          decade = 9 + 10 * Math.floor(year / 10);
        return date.setFullYear(decade + 1, 0, 0), date.setHours(0, 0, 0, 0), date;
      }
      function lastDayOfWeek(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) throw new RangeError('weekStartsOn must be between 0 and 6');
        var date = toDate(dirtyDate),
          day = date.getDay(),
          diff = 6 + (day < weekStartsOn ? -7 : 0) - (day - weekStartsOn);
        return date.setHours(0, 0, 0, 0), date.setDate(date.getDate() + diff), date;
      }
      function lastDayOfISOWeek(dirtyDate) {
        return requiredArgs(1, arguments), lastDayOfWeek(dirtyDate, { weekStartsOn: 1 });
      }
      function lastDayOfISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var year = getISOWeekYear(dirtyDate),
          fourthOfJanuary = new Date(0);
        fourthOfJanuary.setFullYear(year + 1, 0, 4), fourthOfJanuary.setHours(0, 0, 0, 0);
        var date = startOfISOWeek(fourthOfJanuary);
        return date.setDate(date.getDate() - 1), date;
      }
      function lastDayOfQuarter(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          currentMonth = date.getMonth(),
          month = currentMonth - (currentMonth % 3) + 3;
        return date.setMonth(month, 0), date.setHours(0, 0, 0, 0), date;
      }
      function lastDayOfYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear();
        return date.setFullYear(year + 1, 0, 0), date.setHours(0, 0, 0, 0), date;
      }
      var lightFormat_formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g,
        lightFormat_escapedStringRegExp = /^'([^]*?)'?$/,
        lightFormat_doubleQuoteRegExp = /''/g,
        lightFormat_unescapedLatinCharacterRegExp = /[a-zA-Z]/;
      function lightFormat(dirtyDate, dirtyFormatStr) {
        requiredArgs(2, arguments);
        var formatStr = String(dirtyFormatStr),
          originalDate = toDate(dirtyDate);
        if (!isValid(originalDate)) throw new RangeError('Invalid time value');
        var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate),
          utcDate = subMilliseconds(originalDate, timezoneOffset),
          result = formatStr
            .match(lightFormat_formattingTokensRegExp)
            .map(function (substring) {
              if ("''" === substring) return "'";
              var firstCharacter = substring[0];
              if ("'" === firstCharacter) return lightFormat_cleanEscapedString(substring);
              var formatter = lightFormatters[firstCharacter];
              if (formatter) return formatter(utcDate, substring, null, {});
              if (firstCharacter.match(lightFormat_unescapedLatinCharacterRegExp))
                throw new RangeError(
                  'Format string contains an unescaped latin alphabet character `' + firstCharacter + '`'
                );
              return substring;
            })
            .join('');
        return result;
      }
      function lightFormat_cleanEscapedString(input) {
        return input.match(lightFormat_escapedStringRegExp)[1].replace(lightFormat_doubleQuoteRegExp, "'");
      }
      function max(dirtyDatesArray) {
        var datesArray, result;
        if ((requiredArgs(1, arguments), dirtyDatesArray && 'function' == typeof dirtyDatesArray.forEach))
          datesArray = dirtyDatesArray;
        else {
          if ('object' != typeof dirtyDatesArray || null === dirtyDatesArray) return new Date(NaN);
          datesArray = Array.prototype.slice.call(dirtyDatesArray);
        }
        return (
          datesArray.forEach(function (dirtyDate) {
            var currentDate = toDate(dirtyDate);
            (void 0 === result || result < currentDate || isNaN(currentDate)) && (result = currentDate);
          }),
          result || new Date(NaN)
        );
      }
      function min(dirtyDatesArray) {
        var datesArray, result;
        if ((requiredArgs(1, arguments), dirtyDatesArray && 'function' == typeof dirtyDatesArray.forEach))
          datesArray = dirtyDatesArray;
        else {
          if ('object' != typeof dirtyDatesArray || null === dirtyDatesArray) return new Date(NaN);
          datesArray = Array.prototype.slice.call(dirtyDatesArray);
        }
        return (
          datesArray.forEach(function (dirtyDate) {
            var currentDate = toDate(dirtyDate);
            (void 0 === result || result > currentDate || isNaN(currentDate)) && (result = currentDate);
          }),
          result || new Date(NaN)
        );
      }
      var patterns = { dateTimeDelimiter: /[T ]/, timeZoneDelimiter: /[Z ]/i, timezone: /([Z+-].*)$/ },
        dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/,
        timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/,
        timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
      function parseISO(argument, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {},
          additionalDigits = null == options.additionalDigits ? 2 : toInteger(options.additionalDigits);
        if (2 !== additionalDigits && 1 !== additionalDigits && 0 !== additionalDigits)
          throw new RangeError('additionalDigits must be 0, 1 or 2');
        if ('string' != typeof argument && '[object String]' !== Object.prototype.toString.call(argument))
          return new Date(NaN);
        var date,
          dateStrings = splitDateString(argument);
        if (dateStrings.date) {
          var parseYearResult = parseYear(dateStrings.date, additionalDigits);
          date = parseDate(parseYearResult.restDateString, parseYearResult.year);
        }
        if (isNaN(date) || !date) return new Date(NaN);
        var offset,
          timestamp = date.getTime(),
          time = 0;
        if (dateStrings.time && ((time = parseTime(dateStrings.time)), isNaN(time) || null === time))
          return new Date(NaN);
        if (!dateStrings.timezone) {
          var dirtyDate = new Date(timestamp + time),
            result = new Date(
              dirtyDate.getUTCFullYear(),
              dirtyDate.getUTCMonth(),
              dirtyDate.getUTCDate(),
              dirtyDate.getUTCHours(),
              dirtyDate.getUTCMinutes(),
              dirtyDate.getUTCSeconds(),
              dirtyDate.getUTCMilliseconds()
            );
          return result.setFullYear(dirtyDate.getUTCFullYear()), result;
        }
        return (
          (offset = parseTimezone(dateStrings.timezone)),
          isNaN(offset) ? new Date(NaN) : new Date(timestamp + time + offset)
        );
      }
      function splitDateString(dateString) {
        var timeString,
          dateStrings = {},
          array = dateString.split(patterns.dateTimeDelimiter);
        if (array.length > 2) return dateStrings;
        if (
          (/:/.test(array[0])
            ? ((dateStrings.date = null), (timeString = array[0]))
            : ((dateStrings.date = array[0]),
              (timeString = array[1]),
              patterns.timeZoneDelimiter.test(dateStrings.date) &&
                ((dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0]),
                (timeString = dateString.substr(dateStrings.date.length, dateString.length)))),
          timeString)
        ) {
          var token = patterns.timezone.exec(timeString);
          token
            ? ((dateStrings.time = timeString.replace(token[1], '')), (dateStrings.timezone = token[1]))
            : (dateStrings.time = timeString);
        }
        return dateStrings;
      }
      function parseYear(dateString, additionalDigits) {
        var regex = new RegExp(
            '^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)'
          ),
          captures = dateString.match(regex);
        if (!captures) return { year: null };
        var year = captures[1] && parseInt(captures[1]),
          century = captures[2] && parseInt(captures[2]);
        return {
          year: null == century ? year : 100 * century,
          restDateString: dateString.slice((captures[1] || captures[2]).length),
        };
      }
      function parseDate(dateString, year) {
        if (null === year) return null;
        var captures = dateString.match(dateRegex);
        if (!captures) return null;
        var isWeekDate = !!captures[4],
          dayOfYear = parseDateUnit(captures[1]),
          month = parseDateUnit(captures[2]) - 1,
          day = parseDateUnit(captures[3]),
          week = parseDateUnit(captures[4]),
          dayOfWeek = parseDateUnit(captures[5]) - 1;
        if (isWeekDate)
          return (function validateWeekDate(_year, week, day) {
            return week >= 1 && week <= 53 && day >= 0 && day <= 6;
          })(0, week, dayOfWeek)
            ? (function dayOfISOWeekYear(isoWeekYear, week, day) {
                var date = new Date(0);
                date.setUTCFullYear(isoWeekYear, 0, 4);
                var fourthOfJanuaryDay = date.getUTCDay() || 7,
                  diff = 7 * (week - 1) + day + 1 - fourthOfJanuaryDay;
                return date.setUTCDate(date.getUTCDate() + diff), date;
              })(year, week, dayOfWeek)
            : new Date(NaN);
        var date = new Date(0);
        return (function validateDate(year, month, date) {
          return (
            month >= 0 &&
            month <= 11 &&
            date >= 1 &&
            date <= (daysInMonths[month] || (parseISO_isLeapYearIndex(year) ? 29 : 28))
          );
        })(year, month, day) &&
          (function validateDayOfYearDate(year, dayOfYear) {
            return dayOfYear >= 1 && dayOfYear <= (parseISO_isLeapYearIndex(year) ? 366 : 365);
          })(year, dayOfYear)
          ? (date.setUTCFullYear(year, month, Math.max(dayOfYear, day)), date)
          : new Date(NaN);
      }
      function parseDateUnit(value) {
        return value ? parseInt(value) : 1;
      }
      function parseTime(timeString) {
        var captures = timeString.match(timeRegex);
        if (!captures) return null;
        var hours = parseTimeUnit(captures[1]),
          minutes = parseTimeUnit(captures[2]),
          seconds = parseTimeUnit(captures[3]);
        return (function validateTime(hours, minutes, seconds) {
          if (24 === hours) return 0 === minutes && 0 === seconds;
          return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
        })(hours, minutes, seconds)
          ? 36e5 * hours + 6e4 * minutes + 1e3 * seconds
          : NaN;
      }
      function parseTimeUnit(value) {
        return (value && parseFloat(value.replace(',', '.'))) || 0;
      }
      function parseTimezone(timezoneString) {
        if ('Z' === timezoneString) return 0;
        var captures = timezoneString.match(timezoneRegex);
        if (!captures) return 0;
        var sign = '+' === captures[1] ? -1 : 1,
          hours = parseInt(captures[2]),
          minutes = (captures[3] && parseInt(captures[3])) || 0;
        return (function validateTimezone(_hours, minutes) {
          return minutes >= 0 && minutes <= 59;
        })(0, minutes)
          ? sign * (36e5 * hours + 6e4 * minutes)
          : NaN;
      }
      var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function parseISO_isLeapYearIndex(year) {
        return year % 400 == 0 || (year % 4 == 0 && year % 100);
      }
      function parseJSON(argument) {
        if ((requiredArgs(1, arguments), 'string' == typeof argument)) {
          var parts = argument.match(
            /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|\+00:?00)?/
          );
          return parts
            ? new Date(
                Date.UTC(
                  +parts[1],
                  parts[2] - 1,
                  +parts[3],
                  +parts[4],
                  +parts[5],
                  +parts[6],
                  +((parts[7] || '0') + '00').substring(0, 3)
                )
              )
            : new Date(NaN);
        }
        return toDate(argument);
      }
      function roundToNearestMinutes(dirtyDate, options) {
        if (arguments.length < 1) throw new TypeError('1 argument required, but only none provided present');
        var nearestTo = options && 'nearestTo' in options ? toInteger(options.nearestTo) : 1;
        if (nearestTo < 1 || nearestTo > 30) throw new RangeError('`options.nearestTo` must be between 1 and 30');
        var date = toDate(dirtyDate),
          seconds = date.getSeconds(),
          minutes = date.getMinutes() + seconds / 60,
          roundedMinutes = Math.floor(minutes / nearestTo) * nearestTo,
          remainderMinutes = minutes % nearestTo,
          addedMinutes = Math.round(remainderMinutes / nearestTo) * nearestTo;
        return new Date(
          date.getFullYear(),
          date.getMonth(),
          date.getDate(),
          date.getHours(),
          roundedMinutes + addedMinutes
        );
      }
      function setMonth(dirtyDate, dirtyMonth) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          month = toInteger(dirtyMonth),
          year = date.getFullYear(),
          day = date.getDate(),
          dateWithDesiredMonth = new Date(0);
        dateWithDesiredMonth.setFullYear(year, month, 15), dateWithDesiredMonth.setHours(0, 0, 0, 0);
        var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
        return date.setMonth(month, Math.min(day, daysInMonth)), date;
      }
      function set(dirtyDate, values) {
        if ((requiredArgs(2, arguments), 'object' != typeof values || null === values))
          throw new RangeError('values parameter must be an object');
        var date = toDate(dirtyDate);
        return isNaN(date)
          ? new Date(NaN)
          : (null != values.year && date.setFullYear(values.year),
            null != values.month && (date = setMonth(date, values.month)),
            null != values.date && date.setDate(toInteger(values.date)),
            null != values.hours && date.setHours(toInteger(values.hours)),
            null != values.minutes && date.setMinutes(toInteger(values.minutes)),
            null != values.seconds && date.setSeconds(toInteger(values.seconds)),
            null != values.milliseconds && date.setMilliseconds(toInteger(values.milliseconds)),
            date);
      }
      function setDate(dirtyDate, dirtyDayOfMonth) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          dayOfMonth = toInteger(dirtyDayOfMonth);
        return date.setDate(dayOfMonth), date;
      }
      function setDay(dirtyDate, dirtyDay, dirtyOptions) {
        requiredArgs(2, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn,
          defaultWeekStartsOn = null == localeWeekStartsOn ? 0 : toInteger(localeWeekStartsOn),
          weekStartsOn = null == options.weekStartsOn ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6))
          throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
        var date = toDate(dirtyDate, options),
          day = toInteger(dirtyDay),
          currentDay = date.getDay(),
          remainder = day % 7,
          dayIndex = (remainder + 7) % 7,
          delta = 7 - weekStartsOn,
          diff =
            day < 0 || day > 6
              ? day - ((currentDay + delta) % 7)
              : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);
        return addDays(date, diff, options);
      }
      function setDayOfYear(dirtyDate, dirtyDayOfYear) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          dayOfYear = toInteger(dirtyDayOfYear);
        return date.setMonth(0), date.setDate(dayOfYear), date;
      }
      function setHours(dirtyDate, dirtyHours) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          hours = toInteger(dirtyHours);
        return date.setHours(hours), date;
      }
      function setISODay(dirtyDate, dirtyDay) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          day = toInteger(dirtyDay),
          currentDay = getISODay(date),
          diff = day - currentDay;
        return addDays(date, diff);
      }
      function setISOWeek(dirtyDate, dirtyISOWeek) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          isoWeek = toInteger(dirtyISOWeek),
          diff = getISOWeek(date) - isoWeek;
        return date.setDate(date.getDate() - 7 * diff), date;
      }
      function setMilliseconds(dirtyDate, dirtyMilliseconds) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          milliseconds = toInteger(dirtyMilliseconds);
        return date.setMilliseconds(milliseconds), date;
      }
      function setMinutes(dirtyDate, dirtyMinutes) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          minutes = toInteger(dirtyMinutes);
        return date.setMinutes(minutes), date;
      }
      function setQuarter(dirtyDate, dirtyQuarter) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          quarter = toInteger(dirtyQuarter),
          oldQuarter = Math.floor(date.getMonth() / 3) + 1,
          diff = quarter - oldQuarter;
        return setMonth(date, date.getMonth() + 3 * diff);
      }
      function setSeconds(dirtyDate, dirtySeconds) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          seconds = toInteger(dirtySeconds);
        return date.setSeconds(seconds), date;
      }
      function setWeek(dirtyDate, dirtyWeek, dirtyOptions) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          week = toInteger(dirtyWeek),
          diff = getWeek(date, dirtyOptions) - week;
        return date.setDate(date.getDate() - 7 * diff), date;
      }
      function setWeekYear(dirtyDate, dirtyWeekYear, dirtyOptions) {
        requiredArgs(2, arguments);
        var options = dirtyOptions || {},
          locale = options.locale,
          localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate,
          defaultFirstWeekContainsDate =
            null == localeFirstWeekContainsDate ? 1 : toInteger(localeFirstWeekContainsDate),
          firstWeekContainsDate =
            null == options.firstWeekContainsDate
              ? defaultFirstWeekContainsDate
              : toInteger(options.firstWeekContainsDate),
          date = toDate(dirtyDate),
          weekYear = toInteger(dirtyWeekYear),
          diff = differenceInCalendarDays(date, startOfWeekYear(date, dirtyOptions)),
          firstWeek = new Date(0);
        return (
          firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate),
          firstWeek.setHours(0, 0, 0, 0),
          (date = startOfWeekYear(firstWeek, dirtyOptions)).setDate(date.getDate() + diff),
          date
        );
      }
      function setYear(dirtyDate, dirtyYear) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate),
          year = toInteger(dirtyYear);
        return isNaN(date) ? new Date(NaN) : (date.setFullYear(year), date);
      }
      function startOfDecade(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate),
          year = date.getFullYear(),
          decade = 10 * Math.floor(year / 10);
        return date.setFullYear(decade, 0, 1), date.setHours(0, 0, 0, 0), date;
      }
      function startOfToday() {
        return startOfDay(Date.now());
      }
      function startOfTomorrow() {
        var now = new Date(),
          year = now.getFullYear(),
          month = now.getMonth(),
          day = now.getDate(),
          date = new Date(0);
        return date.setFullYear(year, month, day + 1), date.setHours(0, 0, 0, 0), date;
      }
      function startOfYesterday() {
        var now = new Date(),
          year = now.getFullYear(),
          month = now.getMonth(),
          day = now.getDate(),
          date = new Date(0);
        return date.setFullYear(year, month, day - 1), date.setHours(0, 0, 0, 0), date;
      }
      function subBusinessDays(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addBusinessDays(dirtyDate, -amount);
      }
      function subHours(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addHours(dirtyDate, -amount);
      }
      function subMinutes(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMinutes(dirtyDate, -amount);
      }
      function subQuarters(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addQuarters(dirtyDate, -amount);
      }
      function subSeconds(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addSeconds(dirtyDate, -amount);
      }
      function subWeeks(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addWeeks(dirtyDate, -amount);
      }
      function subYears(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addYears(dirtyDate, -amount);
      }
      var maxTime = 24 * Math.pow(10, 8) * 60 * 60 * 1e3,
        minTime = -maxTime;
    },
  ],
]);
